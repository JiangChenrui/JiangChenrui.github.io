<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CondenseNet</title>
    <url>/2019/05/09/CondenseNet/</url>
    <content><![CDATA[<p><a href="https://arxiv.org/abs/1711.09224">论文地址</a><br><a href="https://github.com/ShichenLiu/CondenseNet">代码地址</a></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>&emsp;&emsp;</p>
<h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h2><p><img src="/2019/05/09/CondenseNet/Figure1.png" alt="figure1"><br><img src="/2019/05/09/CondenseNet/Figure2.png" alt="figure2"></p>
<p>&emsp;&emsp;</p>
<h2 id="CondenseNets"><a href="#CondenseNets" class="headerlink" title="CondenseNets"></a>CondenseNets</h2><p>&emsp;&emsp;在DenseNet的基础上使用1x1的分组卷积效果不好，作者认为这是由使用前面的特征图与当前特征图合并做输入引起的。这与典型的卷积输入有两点不同：1.它们有固定的秩序，2.它们更加多样化。不相关组的特征分配会妨碍特征在网络的再利用。作者对输入的特征图进行随机置换减小了对准确性的负面影响，但在相同的计算成本下比smaller DenseNets准确率低。<br>&emsp;&emsp;在DenseNet中已经证明：将早期的特征作为后期层的输入对特征重用是十分有效的。但是并不是所有的早期特征对随后的层有影响，很难预测哪些特征应该被使用。为了解决这个问题，我们提出了一种在训练中自动学习输入特征分组的方法。学习组结构允许每个滤波器选择它自己最相关的一组输入。<br><img src="/2019/05/09/CondenseNet/Figure3.png" alt="figure3">  </p>
<h2 id="学习组卷积"><a href="#学习组卷积" class="headerlink" title="学习组卷积"></a>学习组卷积</h2><p>&emsp;&emsp;我们通过多阶段过程学习组卷积，如图3和图4所示。训练迭代的前半部分包括压缩阶段。在这里，我们重复训练网络，稀疏诱导正则化，进行固定次数的迭代，然后修剪掉具有权重比较低的不重要滤波器。培训的后半部分包括优化阶段，我们在分组修复后学习过滤器。执行修剪时，我们确保来自同一组的过滤器共享相同的稀疏模式。结果，一旦训练完成（测试阶段），可以使用标准组卷积来实现稀疏化层。由于组卷积由许多深度学习库有效实现，因此在理论上和实践中都可以节省大量计算量。我们将在下面介绍我们的方法。  </p>
<h3 id="滤波器分组"><a href="#滤波器分组" class="headerlink" title="滤波器分组"></a>滤波器分组</h3><p>&emsp;&emsp;卷积过程用4D张量$O\times R\times W\times H$表示，其中O表示输出通道数，R表示输入通道数，W和H表示滤波器的长宽。训练前将滤波器分为相同大小的G组，$F_{ij}^{g}$表示组g内第i个输出的第j个输入的权重。  </p>
<h3 id="压缩标准"><a href="#压缩标准" class="headerlink" title="压缩标准"></a>压缩标准</h3><p>&emsp;&emsp;在训练过程中，筛选出没组中不重要的输入特征的子集。第j个输入特征的对于滤波器组g的重要性通过它在组内所有输出之间的权重的平均值来评估，即$\sum<em>{i=1}^{O/G}{|F</em>{ij}^{g}|}$，换句话说，如果它们的L1范数比其他列的L1范数小，则我们删除$F^{g}$中的列（通过将它们归零）。这使卷积层在结构上稀疏：来自同一组的滤波器总是接收与相同的特征输入。  </p>
<h3 id="Group-Lasso"><a href="#Group-Lasso" class="headerlink" title="Group Lasso"></a>Group Lasso</h3><p>&emsp;&emsp;为减少权重修剪带来的负面影响，L1正则化通常用来诱导稀疏性。为了是同一组滤波器有相同的稀疏输入，我们使用以下的组稀疏性计算方法：</p>
<script type="math/tex; mode=display">\sum_{g=1}^{G}\sum_{j=1}^{R}\sqrt{\sum_{i=1}^{O/G}{F_{ij}^{g}}^2}</script><p>&emsp;&emsp;组正则化将$F_{g}$中所有的元素置为0，因为平方根中的项由该列中的最大元素控制。这会使模型向组水平的稀疏方面发展。  </p>
<h3 id="压缩因子"><a href="#压缩因子" class="headerlink" title="压缩因子"></a>压缩因子</h3><p>&emsp;&emsp;除了学习组卷积能够自动发现良好的连接模式之外，它们还比标准组卷积更灵活。 特别是，组使用的特征图的比例不一定需要是1/G。 我们定义了一个可能与G不同的凝聚因子C，并允许每个组选择输入的R/C。  </p>
<h3 id="压缩步骤"><a href="#压缩步骤" class="headerlink" title="压缩步骤"></a>压缩步骤</h3><p>&emsp;&emsp;与在预训练网络中修剪权重的方法相比，我们的权重修剪过程被整合到训练过程中。 如图3所示（使用C = 3），在每个C-1压缩阶段结束时，我们修剪滤波器权重的1/C。 在训练结束时，每个滤波器组中仅保留1/C的权重。 在我们的所有实验中，我们将凝聚阶段的训练时期的数量设置为$M/2(c-1)$，其中M表示训练时期的总数 ，使得训练时期的前半部分用于压缩。 在训练过程的后半部分，优化阶段，我们训练了稀疏模型。（实际操作中将剪掉的分支置为0）。</p>
<h3 id="学习率"><a href="#学习率" class="headerlink" title="学习率"></a>学习率</h3><p>&emsp;&emsp;<br>我们采用Loshchilov等人的余弦形状学习率表。它可以平滑地退化学习率，并且通常可以提高准确度。 图4将学习率显示为训练时期（品红色）的函数，以及在CIFAR-10数据集上训练的CondenseNet的相应训练损失（蓝色曲线）。在时期150处的损失的突然增加是由最终的冷凝操作引起的，其消除了剩余重量的一半。 然而，该图显示该模型在优化阶段从该修剪步骤逐渐恢复。<br><img src="/2019/05/09/CondenseNet/Figure4.png" alt="figure4">  </p>
<h3 id="索引层"><a href="#索引层" class="headerlink" title="索引层"></a>索引层</h3><p>&emsp;&emsp;在训练完成后，我们移除修剪的权重并将稀疏模型转化为具有常规模式的网络，在图三的测试步骤中可以看到索引层。索引层在输入滤波器重新排列进行输出，以便于现有的常规组卷积的实现。图1显示了训练期间（中间）和测试期间（右侧）CondenseNet层的转换。 在训练期间，1×1卷积是学习组卷积（L-Conv），但在测试期间，在索引层的帮助下，它变为标准组卷积（G-Conv）。</p>
<h2 id="网络设计"><a href="#网络设计" class="headerlink" title="网络设计"></a>网络设计</h2><p>&emsp;&emsp;除了使用上面介绍的学习组卷积之外，我们还对常规DenseNet架构进行了两处更改。这些更改旨在进一步简化体系结构并提高其计算效率。图5说明了我们对DenseNet架构所做的两项更改。<br><img src="/2019/05/09/CondenseNet/Figure5.png" alt="figure5">  </p>
<h3 id="增长增长率"><a href="#增长增长率" class="headerlink" title="增长增长率"></a>增长增长率</h3><p>&emsp;&emsp;原始的DenseNet设计每层增加$k$个特征图，表示增长率。在DenseNet中，较深的层更依赖于高水平的特征而不是低水平的特征，这激励我们提高网络的捷径连接。我们发现可以通过随深度增长而提高增长率来实现。这增加了后期层相对于前面层的比率。将增长率变化设置为$k=2^{m-1}k_{0}$，其中m是密集块的索引，k0是常量。 这种设定增长率的方式不会引入任何额外的超参数。 “增长增长率”（IGR）策略在模型的后续层中放置了更大比例的参数。 这大大提高了计算效率，但在某些情况下可能会降低参数效率。根据具体的硬件限制而定。</p>
<h3 id="完全密集连接"><a href="#完全密集连接" class="headerlink" title="完全密集连接"></a>完全密集连接</h3><p>&emsp;&emsp;为了鼓励功能重用，甚至比原来的DenseNet架构更多，我们将输入层连接到网络中的所有后续层，即使这些层位于不同的密集块中（参见图5）。由于密集块具有不同的特征分辨率，因此当我们使用平均池作为低分辨率层的输入时，我们对具有更高分辨率的特征映射进行下采样。<br><img src="/2019/05/09/CondenseNet/Figure6.png" alt="Figure6"><br><img src="/2019/05/09/CondenseNet/Figure7.png" alt="Figure7"><br><img src="/2019/05/09/CondenseNet/Figure8.png" alt="Figure8"></p>
<h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h3><p><img src="/2019/05/09/CondenseNet/Table1.png" alt="Table1"><br><img src="/2019/05/09/CondenseNet/Table2.png" alt="Table2"><br><img src="/2019/05/09/CondenseNet/Table3.png" alt="Table3"><br><img src="/2019/05/09/CondenseNet/Table4.png" alt="Table4"><br>&emsp;&emsp;</p>
]]></content>
      <categories>
        <category>论文阅读</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>轻量级网络</tag>
      </tags>
  </entry>
  <entry>
    <title>EfficientNet</title>
    <url>/2019/07/19/EfficientNet/</url>
    <content><![CDATA[<p><a href="https://arxiv.org/pdf/1905.11946.pdf">论文</a><br><a href="https://blog.csdn.net/u014380165/article/details/90812249">参考博客</a><br><a href="https://github.com/tensorflow/tpu/tree/master/models/official/efficientnet">代码地址1</a><br><a href="https://github.com/lukemelas/EfficientNet-PyTorch">代码地址2</a></p>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>&emsp;&emsp;卷积神经网络是在固定的资源预算下开发的，如果有更多的资源可用，可以相应地得到更高的准确率。在本文中，我们系统地研究模型压缩并确认小心地平衡网络深度、宽度和分辨率能够带来更好的效果。通过这一观察，我们提出了一种新的缩放方法：使用简单高效的复合系数统一缩放所有的维度，包括深度、宽度以及分辨率。我们证明这种方法在压缩MobileNets和ResNets网络是有效的。<br>&emsp;&emsp;为了更进一步，我们使用<font color="#ff000">神经架构搜索</font>来设计新的基础结构，进行缩放以获得一系列模型，称为EffientNets，它比以前的ConvNets具有更高的准确性和效率。特别地，我们的EfficientNet-B7在ImageNet上实现了最先进的84.4％top-1 / 97.1％top-5精度，同时比现有最好的ConvNet小8.4倍，推理速度快6.1倍。我们的EfficientNets在CIFAR-100（91.7％），Flowers（98.8％）和其他3个传输学习数据集上也能很好地传输和实现最先进的精度，参数的数量级减少了一个数量级。<br><img src="/2019/07/19/EfficientNet/Figure1.png" alt="Figure1"></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>&emsp;&emsp;缩放ConvNets被广泛地用来实现更高的准确率。比如，ResNet可以通过使用更多的层从18缩放到200，GPipe通过将基础结构缩放为原来的四倍实现了在ImageNet数据集top-1 84.3%的准确率。然而，网络缩放的方式不能被理解，并且没有一个确切的缩放方式。最常见的方式是网络深度或宽度的缩放。另一个比较常见的，但是最近很流行的方法是通过图片分辨率的缩放来缩放网络。在之前的工作中，缩放宽度、深度和分辨率的某一项是十分常见的。尽管可以任意缩放二维或三维，但任意缩放需要繁琐的手动调整，并且仍然经常产生次优的精度和效率。<br>&emsp;&emsp;在这篇文章中，我们试图去研究和重新思考ConvNets的缩放过程。我们提出了一个核心问题：是不是存在一种原则性的缩放网络的方法来实现更高的准确率和效率？我们的实验研究表明，平衡网络宽度、深度和分辨率的所有维度是至关重要的，并且令人惊讶的是，通过简单地用恒定比率来缩放他们，可以实现这种平衡。基于这一观察，我们提出了验证简单而有效的复合缩放方法。与任意缩放这些因子的传统实践不同，我们的方法使用一组固定的缩放系数统一地缩放网络宽度、深度和分辨率。通过这一观察，我们提出了一种简单但是有效的复合缩放方法。与任意缩放这些因子的传统方法不同，我们的方法使用一组固定的缩放系数统一地缩放网络宽度，深度和分辨率。比如，我们想要使用$2^N$来扩展网络，我们能够简单地使用$\alpha ^N$增加网络深度，$\beta ^N$增加网络深度，图片的尺寸使用$\gamma ^N$，其中α，β，γ是通过原始小模型上的小网格搜索确定的常系数。图2展示了我们的模型和其它模型的区别。<br><img src="/2019/07/19/EfficientNet/Figure2.png" alt="Figure2"><br>&emsp;&emsp;直观地讲，复合缩放方法是十分有意义的，因为输入的图片越大，网络就需要更多的层去扩大感受野，以及更多的通道去在更大的图片上去捕获更加细粒度的特征。我们证明了我们的缩放方法在现有的MobileNets和ResNet上运行良好。值得注意的是，模型扩展的有效性在很大程度上取决于基础网络;为了更进一步，我们使用神经架构搜索开发新的基础网络，并将其扩展以获得一系列模型，称为EfficientNets。图1总结了ImageNet性能，其中我们的EfficientNets明显优于其他ConvNets。特别是，我们的EfficientNet-B7超越了现有的最佳GPipe精度，但使用的参数减少了8.4倍，推理速度提高了6.1倍。与广泛使用的ResNet-50相比，我们的EfficientNet-B4使用类似的FLOPS将top-1精度从76.3％提高到82.6％（+6.3％）。</p>
<h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h2><p><strong>ConvNet Accuracy:</strong> 自AlexNet赢得2012年ImageNet竞赛以来，ConvNets通过扩大规模变得越来越准确：2014年ImageNet获胜者GoogleNet实现了74.8％的top-1精度，大约6.8 M参数，2017 ImageNet获胜者SENet以145M参数实现了82.7％的top-1精度。最近，GPipe使用557M参数进一步将最先进的ImageNet top-1验证精度推高到84.3％：它非常大，只能通过专门的管道并行库进行训练通过划分网络并将每个部分分散到不同的加速器。虽然这些模型主要是为ImageNet设计的，但最近的研究表明，更好的ImageNet模型在各种转移学习数据集和其他计算机视觉任务（如物体检测）中表现更好。虽然更高的精度对于许多应用来说至关重要，但我们已经达到硬件存储器限制，因此进一步提高精度需要更高的效率。<br><strong>ConvNet Efficiency:</strong> 深度神经网络通常使用模型准确率和效率之间的交换，随着智能手机的普及，手工设计的高效网络模型也十分常见，比如SqueezeNets、MobileNets和ShuffleNets。最近，神经架构搜索在设计高效的移动大小的ConvNets中变得越来越流行，并且通过广泛调整网络宽度，深度，实现了比手工制作的移动ConvNets更高的效率、卷积内核类型和大小。但是，目前还不清楚如何将这些技术应用于具有更大设计空间和更昂贵成本的大型模型。在本文中，我们的目标是研究超大型ConvNets的模型效率，超越了最先进的精度。为了实现这一目标，我们采用模型缩放。<br><strong>Model Scaling：</strong> 模型缩放：有许多方法可以根据不同的资源约束扩展ConvNet：ResNet可以通过调整网络深度来缩小（例如，ResNet-18）或向上（例如，ResNet-200），而WideResNet和MobileNets可以通过网络宽度进行缩放。众所周知，更大的输入图像尺寸将有助于提高FLOPS开销的准确性。 虽然先前的研究已经证明网络的深度和宽度对于ConvNets的表现力都很重要，但它仍然是 如何有效地扩展ConvNet以实现更高的效率和准确性的开放性问题。我们的工作系统地和经验地研究了网络宽度，深度和分辨率的所有三个维度的ConvNet缩放。</p>
<h2 id="复合模型缩放"><a href="#复合模型缩放" class="headerlink" title="复合模型缩放"></a>复合模型缩放</h2><p>&emsp;&emsp;在本节中，我们将制定缩放问题，研究不同的方法，并提出我们新的缩放方法。</p>
<h3 id="问题的公式"><a href="#问题的公式" class="headerlink" title="问题的公式"></a>问题的公式</h3><p><img src="/2019/07/19/EfficientNet/formulate1.png" alt="formulate1"><br>&emsp;&emsp;一个神经网络可以由公式（1）所表示，F表示在第i个stage进行L次重复操作。与其它神经网络专注于寻找最佳的结构F不同，我们致力于在固定的结构F上寻找不同的H、W、C和L来达到更好的效果。为了方便训练，我们使C、L和r（分辨率）按照固定的比率进行缩放。<br><img src="/2019/07/19/EfficientNet/formulate2.png" alt="formulate2"><br>&emsp;&emsp;问题可以用公式（2）来进行描述，转化为了寻找d、w和r使得准确率最高，d、w、r分别代表模型在深度、宽度和分辨率上的缩放程度。</p>
<h3 id="缩放尺寸"><a href="#缩放尺寸" class="headerlink" title="缩放尺寸"></a>缩放尺寸</h3><p>&emsp;&emsp;深度、宽度和分辨率三者之间的缩放互相依赖而且在不同的环境下有不同的表现，因此传统方法主要从它们中的一个进行缩放。</p>
<p><strong>深度:</strong> 网络缩放最常用的方式就是深度的变化，更大的深度意味着可以提取出更丰富和更复杂的特征，但是也会有梯度消失问题的存在。虽然之后出现的捷径连接和BN可以缓解这一问题，但是深度的提升对应准确率的提升却微乎其微，如ResNet1000和ResNet101。</p>
<p><img src="/2019/07/19/EfficientNet/Figure3.png" alt="Figure3"><br><strong>宽度：</strong> 在小网络中进行宽度的缩放是十分常见的。扩大宽度可以增加感受野，但是极宽且浅的网络难以捕获高层的特征，如图3所示，宽度的扩展会迅速饱和。</p>
<p><strong>分辨率</strong> 使用更高分辨率的图片，卷积神经网络可以捕获更细粒度的图像。</p>
<p><strong>结论一</strong> 增加网络的宽度、深度和分辨率都可以提高模型的准确率，但是对于大网络来说，准确率增加的速度会降低。</p>
<h3 id="复合缩放"><a href="#复合缩放" class="headerlink" title="复合缩放"></a>复合缩放</h3><p><img src="/2019/07/19/EfficientNet/Figure4.png" alt="Figure4"><br>&emsp;&emsp;我们凭经验观察到不同的尺度缩放不是独立的。直观地，对于更高分辨率的图像，我们应该增加网络深度，使得更大的感受域可以帮助捕获包括更大图像中的更多像素的类似特征。相应地，我们还应该在分辨率更高时增加网络宽度，为了在高分辨率图像中捕获具有更多像素的更细粒度的图案。这些直觉表明我们需要协调和平衡不同的缩放尺寸，而不是传统的单维缩放。<br>&emsp;&emsp;如图4所示，单纯地缩放某一维度的效果要差与同时缩放三个维度。</p>
<p><strong>结论二</strong> 为了更好地提高准确率和效率，在尺寸缩放过程中平衡缩放宽度、深度和分辨率是十分重要的。</p>
<p><img src="/2019/07/19/EfficientNet/formulate3.png" alt="formulate"><br>&emsp;&emsp;缩放比例按公式3进行。</p>
<h2 id="EfficientNet结构"><a href="#EfficientNet结构" class="headerlink" title="EfficientNet结构"></a>EfficientNet结构</h2><p>&emsp;&emsp;α,β2,γ2 的乘积为2，确定了整体的计算量大小（深度扩大2倍，运算量增加2倍，宽度和分辨率扩大2倍，运算量增加4倍），训练中先固定Φ=1，然后通过网络搜索寻找合适的α、β、γ，然后固定α、β、γ，使用不同的Φ得到其它网络结构。</p>
<p><img src="/2019/07/19/EfficientNet/Table1.png" alt="Table1"><br><img src="/2019/07/19/EfficientNet/Table2.png" alt="Table2"><br><img src="/2019/07/19/EfficientNet/Table3.png" alt="Table3"><br><img src="/2019/07/19/EfficientNet/Table4.png" alt="Table4"><br><img src="/2019/07/19/EfficientNet/Table5.png" alt="Table5"><br><img src="/2019/07/19/EfficientNet/Table6.png" alt="Table6"><br><img src="/2019/07/19/EfficientNet/Table7.png" alt="Table7"><br><img src="/2019/07/19/EfficientNet/Figure5.png" alt="Figure5"><br><img src="/2019/07/19/EfficientNet/Figure6.png" alt="Figure6"><br><img src="/2019/07/19/EfficientNet/Figure7.png" alt="Figure7"><br><img src="/2019/07/19/EfficientNet/Figure8.png" alt="Figure8"></p>
]]></content>
      <categories>
        <category>论文阅读</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>轻量级网络</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode刷题总结</title>
    <url>/2019/01/23/LeetCode%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="数组用法"><a href="#数组用法" class="headerlink" title="数组用法"></a>数组用法</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//元素交换</span></span><br><span class="line"><span class="built_in">swap</span>(a[<span class="number">1</span>], a[<span class="number">3</span>]);</span><br><span class="line"><span class="comment">//sort排序</span></span><br><span class="line"><span class="built_in">sort</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>());</span><br><span class="line"><span class="comment">//数组颠倒</span></span><br><span class="line"><span class="built_in">reverse</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line"><span class="comment">//数组元素置为0</span></span><br><span class="line"><span class="built_in">memset</span>(a, <span class="number">0</span>, a.<span class="built_in">size</span>());</span><br><span class="line"><span class="comment">//数组取值</span></span><br><span class="line">a.<span class="built_in">push_back</span>();</span><br><span class="line"><span class="comment">//定义二维数组</span></span><br><span class="line">vector&lt; vector&lt;<span class="type">int</span>&gt; &gt; result</span><br></pre></td></tr></table></figure>
<h2 id="set集合的用法"><a href="#set集合的用法" class="headerlink" title="set集合的用法"></a>set集合的用法</h2><p>集合中没有重复元素</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个int类型的集合</span></span><br><span class="line">set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">set&lt;<span class="type">int</span>&gt;::iterator it;</span><br><span class="line"><span class="comment">//插入元素10（插入的数值默认从小到大排序）</span></span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line"><span class="comment">//删除元素10</span></span><br><span class="line">s.<span class="built_in">erase</span>(<span class="number">10</span>);</span><br><span class="line"><span class="comment">//清空集合</span></span><br><span class="line">s.<span class="built_in">clear</span>();</span><br><span class="line"><span class="comment">//集合元素的个数</span></span><br><span class="line">s.<span class="built_in">size</span>();</span><br><span class="line"><span class="comment">//判断集合是否为空</span></span><br><span class="line">s.<span class="built_in">empty</span>();</span><br><span class="line"><span class="comment">//查找集合中是否与元素10，有的话返回10，没有则返回s.end()</span></span><br><span class="line">it = s.<span class="built_in">find</span>(<span class="number">10</span>);</span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure>
<p>mutiset：多重集合与set最大的区别是它可以插入重复元素，如果删除的话，相同的会一起删除，如果查找的话，返回该元素的迭代器的位置，若有相同，返回第一个元素的地址，其它使用和set基本类似。  </p>
<h2 id="map用法"><a href="#map用法" class="headerlink" title="map用法"></a><a href="https://www.cnblogs.com/fnlingnzb-learner/p/5833051.html">map用法</a></h2><p>c++中map中的元素按key升序排列，基本格式为map<string, int> m，需要使用头文件#include<map>。  </map></string,></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数据的插入</span></span><br><span class="line">map&lt;<span class="type">int</span>, string&gt; studentsID;</span><br><span class="line">studentsID.<span class="built_in">instert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, string&gt;(<span class="number">1</span>, <span class="string">&quot;student_one&quot;</span>));</span><br><span class="line">studentsID.<span class="built_in">instert</span>(map&lt;<span class="type">int</span>, string&gt;::<span class="built_in">value_type</span>(<span class="number">2</span>, <span class="string">&quot;student_two&quot;</span>));</span><br><span class="line">studentID[<span class="number">3</span>]=<span class="string">&quot;student_three&quot;</span>;</span><br></pre></td></tr></table></figure>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//排序</span></span><br><span class="line"><span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line"><span class="comment">//将所有字符转换成小写</span></span><br><span class="line"><span class="built_in">transform</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>(), s.<span class="built_in">begin</span>(),::tolower);</span><br><span class="line"><span class="comment">//截取字符串</span></span><br><span class="line"><span class="comment">//标准库的string有一个substr函数用来截取子字符串。一般使用时传入两个参数，第一个是开始的坐标（第一个字符是0），第二个是截取的长度。</span></span><br><span class="line"><span class="function">string <span class="title">name</span><span class="params">(<span class="string">&quot;rockderia&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">firstname</span><span class="params">(name.substr(<span class="number">0</span>,<span class="number">4</span>))</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a><a href="https://www.zhihu.com/question/38206659">位运算</a></h2><p>异或（^）：相同为0，不同为1<br>与运算（&amp;）：同时为1，才为1<br>或运算（|）：同时为0，才为0<br>取反（~）<br>左移（&lt;&lt;）：左边的二进制丢失，右边补0，左移最高位不包括1，左移相当于该数乘2；<br>右移（&gt;&gt;）:正数左补0，负数左补1<br>不同长度的数据进行位运算时，系统会自动补齐。</p>
<h3 id="不使用-、-、×、-实现加法函数"><a href="#不使用-、-、×、-实现加法函数" class="headerlink" title="不使用+、-、×、/实现加法函数"></a>不使用+、-、×、/实现加法函数</h3><ol>
<li>先使用异或运算计算每位二进制相加的结果，</li>
<li>然后进行与运算并左移一位计算进位数，</li>
<li>重复执行，直到进位数为0。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">MyAdd</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (num2 != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> temp = num1 ^ num2;</span><br><span class="line">        num2 = (num1 &amp; num2) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        num1 = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>栈具有先进后出的特性  </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认构造函数</span></span><br><span class="line">stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"><span class="comment">// 复制构造函数</span></span><br><span class="line">stack&lt;<span class="type">int</span>, list&lt;<span class="type">int</span>&gt;&gt; s1;</span><br><span class="line">stack&lt;<span class="type">int</span>, list&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">s2</span>(s1);</span><br><span class="line"><span class="comment">// 入栈</span></span><br><span class="line">s.<span class="built_in">push</span>();</span><br><span class="line"><span class="comment">// 出栈，不会显示内容</span></span><br><span class="line">s.<span class="built_in">pop</span>();</span><br><span class="line"><span class="comment">// 提取栈顶元素</span></span><br><span class="line">s.<span class="built_in">top</span>();</span><br><span class="line"><span class="comment">// 判断是否非空</span></span><br><span class="line">s.<span class="built_in">empty</span>() <span class="comment">// true表示未空，false表示非空</span></span><br><span class="line"><span class="comment">// 返回栈中数目</span></span><br><span class="line">s.<span class="built_in">size</span>()</span><br></pre></td></tr></table></figure>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义队列</span></span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="comment">// 入队</span></span><br><span class="line">q.<span class="built_in">push</span>(x)</span><br><span class="line"><span class="comment">// 出队</span></span><br><span class="line">q.<span class="built_in">pop</span>()</span><br><span class="line"><span class="comment">// 访问队首元素</span></span><br><span class="line">q.<span class="built_in">front</span>()</span><br><span class="line"><span class="comment">// 访问队尾元素</span></span><br><span class="line">q.<span class="built_in">back</span>()</span><br><span class="line"><span class="comment">// 判断队列是否为空</span></span><br><span class="line">q.<span class="built_in">empty</span>()</span><br><span class="line"><span class="comment">// 访问队列中元素个数</span></span><br><span class="line">q.<span class="built_in">size</span>()</span><br></pre></td></tr></table></figure>
<p>队列具有先进先出的特性  </p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>LeetCode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>MobileNetV3</title>
    <url>/2019/06/03/MobileNetV3/</url>
    <content><![CDATA[<p><a href="https://arxiv.org/pdf/1905.02244.pdf">论文地址</a></p>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>&emsp;&emsp;我们基于互补搜索技术的组合以及新颖的架构设计呈现下一代MobileNets。MobileNetV3通过硬件网络架构搜索（NAS）与NetAdapt算法相结合的方式调整到移动电话CPU，然后通过新颖的架构改进进行改进。本文开始探索自动搜索算法和网络设计如何协同工作，以利用互补的方法来改善整体的现状。通过这个过程，我们为发布创建了两个新的MobileNet模型：MobileNetV3-Large和MobileNetV3-Small，它们针对高资源和低资源使用情况。然后，这些模型被适应并应用于对象检测和语义分割的任务。对于语义分割（或任何密集像素预测）的任务，我们提出了一种新的有效分割解码器Lite Reduced Atrous Spatial Pyramid Pooling（LR-ASPP）。我们实现了移动分类，检测和分割的最新技术成果。MobileNetV3-Large在ImageNet分类上的准确度提高了3.2％，与MobileNetV2相比，延迟降低了15％。与MobileNetV2相比，MobileNetV3-Small的准确度提高了4.6％，同时将延迟降低了5％。MobileNetV3-大检测速度提高了25％，与COCO检测时的MobileNetV2大致相同。MobileNetV3-Large LR-ASPP比MobileNetV2 R-ASPP快30％，与Cityscapes细分的准确度相似。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>&emsp;&emsp;高效的神经网络在移动应用程序中变得无处不在，从而实现全新的设备体验。它们也是个人隐私的关键推动因素，允许用户获得神经网络的好处，而无需将数据发送到服务器进行评估。神经网络效率的进步不仅可以通过更高的准确性和更低的延迟来改善用户体验，还可以通过降低功耗来帮助延长电池寿命。<br>&emsp;&emsp;本文描述了我们开发MobileNetV3大型和小型模型的方法，以便提供下一代高精度高效神经网络模型，为设备上的计算机视觉提供动力。新网络推动了最新技术的发展，并演示了如何将自动搜索与新颖的架构改进相结合，以构建有效的模型。<br>&emsp;&emsp;本文的目标是开发最佳的移动计算机视觉架构，优化移动设备上的准确度。为实现这一目标，我们引入了（1）互补搜索技术，（2）适用于移动设置的非线性高效新版本，（3）新的高效网络设计,（4）新的有效分段解码器。我们提供了彻底的实验，证明了在各种用例和手机上评估的每项技术的功效和价值。<br>&emsp;&emsp;本文的结构如下。我们首先讨论第2节中的相关工作。第3节回顾了用于移动模型的有效构建块。第4节回顾了体系结构搜索以及MnasNet和NetAdapt算法的互补性。第5节描述了新颖的架构设计，提高了通过联合搜索找到的模型的效率。第6节介绍了分类，检测和分割的广泛实验，以便证明有效性并理解不同元素的贡献。第7节包含结论和未来的工作。<br><img src="/2019/06/03/MobileNetV3/Figure1.png" alt="Figure1"><br><img src="/2019/06/03/MobileNetV3/Figure2.png" alt="Figure2"></p>
<h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h2><p>&emsp;&emsp;近年来，设计深度神经网络架构以实现精度和效率之间的最佳平衡是一个活跃的研究领域。新颖的手工结构和算法神经结构搜索都在推动这一领域发挥了重要作用。<br>&emsp;&emsp;SqueezeNet[22]广泛使用1x1卷积，挤压和扩展模块主要集中在减少参数数量上。最近的工作将重点从减少参数转移到减少操作数（MAdds）和实际测量的延迟。MobileNetV1[19]采用深度可分离卷积来大幅提高计算效率。MobileNetV2[39]通过引入具有反向残差和线性瓶颈的资源有效块来扩展这一点。ShuffleNet[49]利用组卷积和信道混洗操作来进一步减少MAdds。CondenseNet[21]在训练阶段学习群组卷积，以保持层之间有用的密集连接，以便重新使用特征。ShiftNet[46]提出了与逐点卷积交织的移位操作，以取代昂贵的空间卷积。<br>&emsp;&emsp;为了使架构设计过程自动化，首先引入强化学习（RL）来搜索具有竞争精度的高效架构[53,54,3,27,35]。完全可配置的搜索空间可以呈指数级增长并且难以处理。因此，架构搜索的早期工作集中在单元级结构搜索上，并且在所有层中重用相同的单元。最近，[43]探索了一种块级分层搜索空间，允许在网络的不同分辨率块处使用不同的层结构。为了降低搜索的计算成本，在[28,5,45]中使用可分的架构搜索框架，使用基于梯度的优化。着眼于将现有网络适应受约束的移动平台，[48,15,12]提出了更有效的自动网络简化算法。<br>&emsp;&emsp;量化[23,25,47,41,51,52,37]是通过降低精度算法来提高网络效率的另一个重要的补充努力。最后，知识蒸馏[4,17]提供了一种额外的补充方法，可以在大型“教师”网络的指导下生成小型精确的“学生”网络。  </p>
<h2 id="高效的移动构建模块"><a href="#高效的移动构建模块" class="headerlink" title="高效的移动构建模块"></a>高效的移动构建模块</h2><p>&emsp;&emsp;移动模型建立在越来越高效的构建块上。MobileNetV1[19]引入了深度可分离卷积作为传统卷积层的有效替代。深度可分离卷积通过将空间滤波与特征生成机制分离来有效地分解传统卷积。深度可分离卷积由两个单独的层定义：用于空间滤波的轻重量深度卷积和用于特征生成的较重的1x1逐点卷积。<br>&emsp;&emsp;MobileNetV2[39]引入了线性瓶颈和倒置残差结构，以通过利用问题的低等级性质来制造更高效的层结构。该结构如图3所示，由1x1扩展卷积后跟深度卷积和1x1投影层定义。当且仅当它们具有相同数量的通道时，输入和输出才与剩余连接相连。这种结构在输入和输出处保持紧凑的表示，同时在内部扩展到更高维的特征空间，以增加非线性每通道变换的表现力。<br><img src="/2019/06/03/MobileNetV3/Figure3.png" alt="Figure3"><br>&emsp;&emsp;MnasNet[43]基于MobileNetV2结构，将基于压缩和激发的轻量级注意模块引入瓶颈结构。请注意，压缩和激励模块集成在与[20]中提出的基于ResNet的模块不同的位置。模块放置在扩展中的深度滤波器之后，以便将注意力应用于最大的表示，如图4所示。<br><img src="/2019/06/03/MobileNetV3/Figure4.png" alt="Figure4"><br>&emsp;&emsp;对于MobileNetV3，我们使用这些层的组合作为构建块，以便构建最有效的模型。层也升级了修改的swish非线性[36,13,16]。压缩和激励以及swish非线性都使用了sigmoid，这可能是低效的计算以及在定点算术中保持精度的挑战，所以我们用hard sigmoid[2,11]代替它，如5.2节所述。  </p>
<h2 id="网络搜索"><a href="#网络搜索" class="headerlink" title="网络搜索"></a>网络搜索</h2><p>&emsp;&emsp;网络搜索已经证明它是发现和优化网络架构的一个非常强大的工具[53,53,5,48]。对于MobileNetV3，我们使用平台感知NAS通过优化每个网络块来搜索全局网络结构。然后，我们使用NetAdapt算法在每层中搜索过滤器的数量。这些技术是互补的，可以组合起来有效地找到给定硬件平台的优化模型。  </p>
<h3 id="用于分块搜索的平台遥感NAS"><a href="#用于分块搜索的平台遥感NAS" class="headerlink" title="用于分块搜索的平台遥感NAS"></a>用于分块搜索的平台遥感NAS</h3><p>&emsp;&emsp;</p>
]]></content>
      <categories>
        <category>论文阅读</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>轻量级网络</tag>
      </tags>
  </entry>
  <entry>
    <title>MobileNetV2 倒置残差和线性瓶颈</title>
    <url>/2019/01/23/MoblieNetV2/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/u011974639/article/details/79199588">参考博客</a><br><a href="https://arxiv.org/pdf/1801.04381.pdf">论文地址</a>  </p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>&emsp;&emsp;神经网络在机器智能领域有革命性地作用，比如在图像识别任务中超过了人类的识别准确率。然而，提高准确率的同时带来了新的代价：先进的网络需要的高计算能力超越了许多手机和嵌入式应用计算能力。<br>&emsp;&emsp;本文介绍了一种新的为移动和资源受限环境特殊定制的神经网络结构。我们的网络在保持相同准确率的情况下通过减少计算量和内存需求，推动了移动定制计算机视觉模型的水平。<br>&emsp;&emsp;我们主要贡献是一种新的层模块：具有线性瓶颈的倒置残差。这个模块采用了一种低维的压缩表示作为输入，首先扩展成高维然后使用轻量级深度卷积过滤。随后使用线性卷积将特征投影回低维表示。官方实现TensorFlow-Slim提供一部分操作。<br>&emsp;&emsp;该模块可以在任何现代框架中使用标准操作有效地实现，并允许我们的模型使用标准基准测试在多个性能点上击败最新技术。此外，这种卷积模块特别适用于移动设计，因为它可以通过永远不会完全实现大型中间张量来显着减少推理期间所需的内存占用。这减少了许多嵌入式硬件设计中对主存储器访问的需求，这些设计提供了少量非常快速的软件控制的高速缓冲存储器。  </p>
<h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h2><p>&emsp;&emsp;在最近几年，调整深度神经网络的架构以在准确率和性能之间有一个最佳平衡成为一个积极研究的领域。早期的网络如AlexNet,VGGNet,GoogLeNet以及ResNet，这些网络的设计都进行了大量的手工体系结构搜索和训练算法改进。最近在网络架构探索上有了很多进展，比如超参数还有各种网络修剪方法以及连通性学习。大量的工作也致力于内部卷积模块的连接架构的改变，比如ShuffleNet[20]或引入了稀疏性[21]和其它[22]。<br>&emsp;&emsp;最近，[23, 24, 25, 26]引入了架构探索的新方向，将遗传算法和强化学习加入了其中。然而一个缺点是得到的网络最终会十分复杂。本文的目的是找到然后是神经网络更好地运作并用它指导最简单的网络设计。我们的方法应该被视为[23]描述方法的一种互补和相近的工作。在这种情况下，我们的方法类似于[20,22]所采用的方法并允许进一步改善性能，同时提供内部操作的一部分。我们的网络设计基于MobileNetV1。保留了它的简洁性而且不要求任何特殊操作就能显著提升准确率，实现了移动应用的多图像分类和检测任务的最新技术。  </p>
<h2 id="预备、讨论和直觉"><a href="#预备、讨论和直觉" class="headerlink" title="预备、讨论和直觉"></a>预备、讨论和直觉</h2><h3 id="深度可分离卷积"><a href="#深度可分离卷积" class="headerlink" title="深度可分离卷积"></a>深度可分离卷积</h3><p>&emsp;&emsp;深度可分离卷积是现在很多高效神经网络模块的关键部分，并且我们也将其应用到我们的网络中。基础思想是使用分解的版本代替全卷积层，将全卷积层分为深度卷积和点卷积两个部分。第一次深度卷积是使用单个卷积滤波器在每个输入通道上进行轻量级滤波。第二次点卷积使用1x1的卷积主要负责通过计算输入通道的线性组合来建立新的特征。<br>&emsp;&emsp;标准卷积在输入通道为$d_i$输出通道为$d_j$，卷积和大小为$k*k$的情况下计算量为:</p>
<script type="math/tex; mode=display">h*w*d_i*d_j*k^2</script><p>&emsp;&emsp;深度可分离卷积的计算量为:</p>
<script type="math/tex; mode=display">h*w*d_{i}*(k^2+d_{j})</script><p>实验证实深度可分离卷积在性能上与常规卷积几乎相同，但计算量大致变为原来的$1/k^2$。我们使用的k为3。  </p>
<h3 id="线性瓶颈"><a href="#线性瓶颈" class="headerlink" title="线性瓶颈"></a>线性瓶颈</h3><p><img src="/2019/01/23/MoblieNetV2/MobileNetV2_Figure1.png" alt="Figure1"><br>&emsp;&emsp;思考一个深度神经网络由n层组成$L_i$，每个$L_i$有</p>
<script type="math/tex; mode=display">h_{i}*w_{i}*d_{i}</script><p>激活张量。这节我们讨论这些张量的基础特性，我们将这些张量视为$h<em>{i}*w</em>{i}$个像素点的$d_i$维的容器。非正式地，对于一个真实图片的输入集合，我们说激活层集合组成了“多方面兴趣”。长期以来，人们一直以为神经网络的多方面兴趣可以嵌入到低维的子空间中。换句话说，当我们查看深度卷积层的所有单个d通道像素时，在这些值中编码的信息实际上位于某些流形中，而这些流形又可嵌入到低维子空间中。<br>&emsp;&emsp;乍一看，这些事实可以简单地通过减少层的尺寸来捕获和利用从而减少操作空间的尺寸。这在MobileNetV1中成功地通过宽度乘数有效地平衡计算量和准确率。遵循这种直觉，这种宽度乘数方法允许人们减少激活空间的尺寸，直到感兴趣的流体经过整个空间。然而，当我们回想深度卷积网络实际上在每次坐标变换时都有非线性时比如ReLU，这种直觉会崩溃。例如，应用于1D空间中的线的ReLU产生“射线”，与在Rn空间中一样，它通常产生具有n关节的分段线性曲线。<br><img src="/2019/01/23/MoblieNetV2/MobileNetV2_Figure2.png" alt="Figure2"><br>&emsp;&emsp;很容易看出，在通常情况下，ReLU转换层的结果有非零的体积S，通过对输入进行线性转换B获得测绘内部S的点，这意味部分对应于全维输出的输入空间受限于线性变换。换句话说，<font color="#ff000" size="3">深度网络仅仅在非零部分具有线性分类器的能力。</font><br>&emsp;&emsp;在另一方面<font color="#ff000" size="3">当ReLU合并通道时，必然会损失通道信息。</font>但是我们如果有很多通道，并且激活流形中有一个机构，那么信息可能会保留在其它通道中。在附录中，我们展示了如果输入流形能够被嵌入到激活空间的显著低维子空间中，之后ReLU变换会保留信息同时在可表达功能集中引入所需的复杂性。<br>&emsp;&emsp;总而言之，我们强调了两个属性，这两个属性表明感兴趣的流形应位于高纬度激活空间的低纬度子空间：  </p>
<ul>
<li><p>1.如果感兴趣的流形在ReLU变换后保持了非零量，与线性变换相同。  </p>
</li>
<li><p>2.ReLU在保留输入流形的全部信息是十分重要的，但是仅在输入流形位于输入空间的低维子空间时有效。  </p>
</li>
</ul>
<p>&emsp;&emsp;这两个见解为我们提供了优化存在的神经网络结构的经验暗示：假如感兴趣的流形是低维的，我们能够在卷积模块中插入线性瓶颈来捕获它。通过实验证明，<font color="#ff000" size="3">线性模块是十分重要的，因为它阻止非线性破坏太多信息。</font>在第六节中，我们凭经验证明，在瓶颈中使用非线性层确实会使性能受到几个百分点的影响，从而进一步验证了我们的假设3。 我们注意到在[29]中报告了有助于非线性的类似报告，其中从传统残差块的输入中去除了非线性并且导致CIFAR数据集的性能提高。<br>&emsp;&emsp;对于本文的其余部分，我们将利用瓶颈卷积。 我们将输入瓶颈尺寸与内部尺寸之间的比率称为膨胀比。  </p>
<h3 id="残差倒置"><a href="#残差倒置" class="headerlink" title="残差倒置"></a>残差倒置</h3><p><img src="/2019/01/23/MoblieNetV2/MobileNetV2_Figure3.png" alt="Figure3"><br>&emsp;&emsp;瓶颈网络和残差块十分相似，其中每个块包含一个输入，之后是几个瓶颈，然后是扩展。然而，受到瓶颈模块实际上包含所有必要信息的直观启发，虽然扩展层仅仅作为伴随张量的非线性变换的实现细节，但我们在瓶颈之间直接使用快捷方式。<br>&emsp;&emsp;图3提供了设计差异的示意图。 插入快捷方式的动机类似于经典残差连接的动机：我们希望提高梯度在乘数层上传播的能力。 然而，倒置设计的内存效率要高得多（详见第5节），并且在我们的实验中效果稍好一些。<br><img src="/2019/01/23/MoblieNetV2/MobileNetV2_Table1.png" alt="Table1"><br>&emsp;&emsp;瓶颈卷积的运行时间和参数数量。基本结构如表一所示。对于大型为$h*w$的块，扩展因子为t，内核大小为k，输入通道为$d^{‘}$输出通道为$d^{‘’}$，矩阵乘法计算总量为</p>
<script type="math/tex; mode=display">
h*w*d^{'}*t(d^{'}+k^{2}+d^{''})</script><p>与（1）相比多了额外的项,因为我们确实有一个额外的1×1卷积，但是我们网络的性质允许我们使用更小的输入和输出维度。 在表3中，我们比较了MobileNetV1，MobileNetV2和ShuffleNet之间每个分辨率所需的大小。  </p>
<h3 id="信息流动的说明"><a href="#信息流动的说明" class="headerlink" title="信息流动的说明"></a>信息流动的说明</h3><p>&emsp;&emsp;我们的架构有个很有趣的特性：它能够对构建块（瓶颈块）的输入输出域进行自然分离，这是一种将输入转换为输出的非线性函数。前者可以看出每层网络的容量，后者可以看做是表现能力。这与传统的卷积模块存在差异，包括常规网络和分离网络，它们的容量和表现力混在一起并且是输出层深度的函数。<br>&emsp;&emsp;特别是，在我们的例子中，当内层深度为0时，由于快捷连接，底层卷积是身份函数。当膨胀比小于1时，这是一个经典的残余卷积块[8,30]。但是，出于我们的目的，我们表明膨胀率大于1是最有用的。<br>&emsp;&emsp;这种解释使我们能够将网络的表现力与其容量分开研究，并且我们认为有必要进一步探索这种分离，以便更好地理解网络属性。  </p>
<h2 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h2><p><img src="/2019/01/23/MoblieNetV2/MobileNetV2_Table2.png" alt="Table2"><br>&emsp;&emsp;现在描述我们的网络细节。如前面所述的基础模块是带有残差模块的深度可分离卷积。模块细节在表一。MobileNetV2的结构包括32层滤波器，如表二所示结构，有19层residual bottleneck(17?)。我们使用ReLU6做非线性计算，因为它在低精度运算上有很好的鲁棒性。我们使用3x3的卷积核，并且使用dropout和batch normalization。<br>&emsp;&emsp;除第一层外，我们在整个网络中使用恒定的扩展速率。在我们的实验中，我们发现5到10之间的扩展速率导致几乎相同的性能曲线，较小的网络通过略小的扩展速率获得更好的结果，而较大的网络具有稍微更好的性能和更大的扩展速率。<br>&emsp;&emsp;对于我们所有的主要实验，我们使用应用于输入张量大小的扩展因子6。例如，对于采用64通道输入张量并产生具有128个通道的张量的瓶颈层，中间扩展层则为64·6 = 384个通道。<br>&emsp;&emsp;平衡超参数：我们通过使用输入图像分辨率和宽度乘数作为可调超参数来定制我们的架构到不同的性能点，可以根据所需的精度/性能权衡进行调整。 我们的主要网络（宽度乘数1,224×224）具有3亿乘法的计算成本，并使用340万个参数。我们探索性能权衡，输入分辨率从96到224，宽度乘数从0.35到1.4。网络计算成本范围从7M MAdds到585M MAdds，而模型大小在1.7M和6.9M参数之间变化。<br>&emsp;&emsp;一个小的实现差异，[27]是对于小于1的乘数，我们将宽度乘数应用于除最后一个卷积层之外的所有层。这可以提高较小网络的性能。  </p>
<h2 id="实验记录"><a href="#实验记录" class="headerlink" title="实验记录"></a>实验记录</h2><h3 id="存取效率推断"><a href="#存取效率推断" class="headerlink" title="存取效率推断"></a>存取效率推断</h3><p><img src="/2019/01/23/MoblieNetV2/MobileNetV2_Figure4.png" alt="Figure4"><br>&emsp;&emsp;内存的大小由瓶颈张量的大小决定，而不是瓶颈内部张量的大小决定的（并且更大）。<br>&emsp;&emsp;我们的瓶颈残差模块先扩展后压缩。  </p>
<p><img src="/2019/01/23/MoblieNetV2/MobileNetV2_Figure5.png" alt="Figure5">  </p>
<p><img src="/2019/01/23/MoblieNetV2/MobileNetV2_Figure6.png" alt="Figure6">  </p>
<h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><h3 id="ImageNet分类"><a href="#ImageNet分类" class="headerlink" title="ImageNet分类"></a>ImageNet分类</h3><p>&emsp;&emsp;训练设置：我们使用TensorFlow训练我们的模型[31]。 我们使用标准的RMSPropOptimizer，将衰减和动量设置为0.9。我们在每一层之后使用批量标准化，标准重量衰减设置为0.00004。在MobileNetV1 [27]设置之后，我们使用0.045的初始学习率和每个时期0.98的学习率衰减率。我们使用16个GPU异步工作器，批量大小为96。  </p>
<p>&emsp;&emsp;结果:我们将我们的网络与MobileNetV1，ShuffleNet和NASNet-A模型进行比较。表4显示了一些选定模型的统计数据，其完整性能图如图5所示。<br><img src="/2019/01/23/MoblieNetV2/MobileNetV2_Table4.png" alt="Table4">  </p>
<h3 id="目标检测"><a href="#目标检测" class="headerlink" title="目标检测"></a>目标检测</h3><p>&emsp;&emsp;我们评估和比较MobileNetV1和MobileNetV2在SSD在COCO数据集上中特征提取的性能，我们也比较了YOLOv2和单个SSD作为基准。<br>&emsp;&emsp;SSDLite：我们将SSD的预测层的常规卷积全部替换为深度分离卷积，这种模型适用于移动设备，称为SSDlite，SSDlite显著地减少了计算量和参数，如表5所示。表6显示了所有的计算结果。<br><img src="/2019/01/23/MoblieNetV2/MobileNetV2_Table5.png" alt="Table5">  </p>
<p><img src="/2019/01/23/MoblieNetV2/MobileNetV2_Table6.png" alt="Table6">  </p>
<h3 id="语义分割"><a href="#语义分割" class="headerlink" title="语义分割"></a>语义分割</h3><h3 id="强化学习"><a href="#强化学习" class="headerlink" title="强化学习"></a>强化学习</h3><h2 id="讨论和未来工作"><a href="#讨论和未来工作" class="headerlink" title="讨论和未来工作"></a>讨论和未来工作</h2>]]></content>
      <categories>
        <category>论文阅读</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>轻量级网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Residual Attention Network</title>
    <url>/2019/03/18/Residual-Attention-Network/</url>
    <content><![CDATA[<p><a href="https://arxiv.org/pdf/1704.06904">论文地址</a>  </p>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>&emsp;&emsp;在这个工作中，我们提出了“残差注意网络”，它是一种使用注意力机制的卷积神经网络，能够将最先进的前馈神经网络机制融合到端对端的训练中。我们的残差注意网络是由生成注意力感知特征的注意力模块堆叠而成的。注意力感知特征会随着层数的加深自适应地改变。在每个注意力模块的内部，自上而下自下而上的前馈结构能够将前馈和反馈结构展开到单个的前馈过程中。重要的事，我们提出的注意力残差学习非常深的残差注意网络，能够轻松地扩展到数百层。<br>&emsp;&emsp;我们对CIFAR-10和CIFAR-100数据集进行了广泛的分析，以验证上述每个模块的有效性。我们的剩余注意力网络在三个基准数据集上实现了最先进的物体识别性能，包括CIFAR-10（3.90％误差），CIFAR-100（20.45％误差）和ImageNet（4.8％单一模型和单一作物，顶部 - 5错误）。请注意，与ResNet-200相比，我们的方法实现了0.6％的前1精度提升，46％的主干深度和69％的前向FLOP。该实验还表明，我们的网络可以抵御嘈杂的标签。  </p>
<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h2><p>&emsp;&emsp;不止是友好的脸，而且红色也会引起我们的注意。在之前的文献中已经广泛地研究了混合特征。<font color="#ff000">注意力不仅服务于选择聚焦位置，而且鼓励该位置处目标的不同表示</font>。之前的工作将注意力漂移作为一个序列过程来捕捉不同的参与方面。然而，据我们所知，在图像分类任务没有注意力机制中被应用于前馈网络结构来实现最先进的结果。最近在图像分类任务的先进工作都是致力于使用非常深的结构训练前馈神经网络。<br>&emsp;&emsp;受到注意力机制和深度神经网络进步的鼓舞，我们提出了残差注意力网络(RAN)，一种使用混合注意力机制的非常深的结构。RAN是由多个能够生成注意力感知特征的注意力模块组成。随着层数的加深，来自不同模块的注意力特征会自适应地改变。<br>&emsp;&emsp;除了注意力机制带来的更具辨别力的特征表示外，我们的模型还具有以下吸引人的特性：<br>（1）增加注意力模块导致模型能力提升，因为不同种类的注意力被广泛地捕获。<font color="#ff000">图一</font>显示了在热气球图片上不同种类注意力。天空注意力掩膜虚化了背景表现，气球底部的注意力掩膜突出了气球的底部。<br><img src="/2019/03/18/Residual-Attention-Network/figure1.png" alt="figure1"><br>（2）它使得端对端的训练方式可以融入到最先进的深度网络结构中。特别地，我们的网络可以扩展到数百层。我们的残留注意网络在CIFAR-10，CIFAR-100和具有挑战性的ImageNet图像分类数据集上超越了最先进的残留网络，显着减少了计算（69％前向FLOP）。<br>&emsp;&emsp;所有上述方法可以通过以下方法实现：<br>（1）堆叠网络结构：我们的RAN通过堆叠注意力模块组成。堆叠结构是混合注意力机制的基本应用，因此，不同类别的注意力能够被不同的注意力模块捕获。<br>（2）注意力残差学习：直接堆叠注意模块会导致明显的性能下降。因此，我们提出了注意力残留学习机制来优化具有数百层的非常深的残留注意网络。<br>（3）自上而下自下而上的前馈注意力机制：自上而下自下而上的前馈结构以及成功用于人类行为检测和图像分割。我们使用这种结构作为注意力模块的一部分，用来在功能上添加软权重。这种结构可以在单个前馈过程中模拟自下而上的快速前馈过程和自上而下的注意反馈，这使我们能够自上而下地开发端到端的可训练网络。我们工作中自下而上自上而下的结构与堆叠沙漏网络的不同之处在于其引导特征学习的意图。  </p>
<h2 id="2-相关工作"><a href="#2-相关工作" class="headerlink" title="2 相关工作"></a>2 相关工作</h2><p>&emsp;&emsp;来自人类感知过程的证据[23]显示了注意机制的重要性，它使用顶级信息来指导自下而上的前馈过程。 最近，已经尝试将注意力应用于深度神经网络。 Deep Boltzmann Machine（DBM）[21]通过其在训练阶段的重建过程包含自上而下的关注。 注意机制也被广泛应用于递归神经网络（RNN）和长期短期记忆（LSTM）[13]，以解决顺序决策任务[25,29,21,18]。按顺序收集信息并决定下个特征学习步骤的关注内容。<br>&emsp;&emsp;残差学习致力于学习身份映射间的残差。 该技术极大地增加了前馈神经网络的深度。 与我们的工作类似，[25,29,21,18]使用残余学习和注意机制来从残余学习中受益。 使用注意机制捕获两个信息源（查询和查询上下文）以在他们的工作中互相帮助。 在我们的工作中，单个信息源（图像）被分成两个不同的信息源并重复组合。 并且应用残差学习来缓解重复分裂和组合带来的问题。<br>&emsp;&emsp;在图像分类中，使用不同的方法应用自上而下的注意机制：顺序过程，区域建议和控制门。 顺序过程[23,12,37,7]将图像分类建模为顺序决策。 因此，可以类似地应用以上注意力。 该公式允许使用RNN和LSTM进行端到端优化，并且可以以目标驱动的方式捕获不同类型的注意力。<br>&emsp;&emsp;区域提案[26,4,8,38]已成功应用于图像检测任务。 在图像分类中，在前馈分类之前添加附加区域建议阶段。 建议的区域包含最高信息，并在第二阶段用于特征学习。 与区域提案依赖于大量监督的图像检测不同，例如 地面真实边界框或详细的分割掩模[6]，无监督学习[35]通常用于生成图像分类的区域提议。<br>&emsp;&emsp;控制门被广泛地用于LSTM中，在注意力图像分类中，用顶层信息更新神经元的控制门，并且在训练期间影响前馈过程[2,30]。 然而，在训练步骤中涉及新过程，强化学习[30]或优化[2]。 Highway Network[29]扩展了控制门，解决了深度卷积神经网络的梯度退化问题。<br>&emsp;&emsp;然而，图像分类的最新进展侧重于使用“非常深”结构训练前馈卷积神经网络[27,33,10]。 前馈卷积网络模拟人类皮层的自下而上的路径。 已经提出了各种方法来进一步提高深度卷积神经网络的判别能力。 VGG [27]，Inception [33]和残差学习[10]被提出来训练非常深的神经网络。 随机深度[14]，批量标准化[15]和Dropout [28]利用正则化进行收敛并避免过度拟合和退化。<br>&emsp;&emsp;在最近的工作[3,17]中产生的软关注可以对卷积网络进行端到端的训练。 我们的剩余注意力网络以创新的方式将快速发展的前馈网络结构中的软关注融入其中。 最近提出的空间变换器模块[17]实现了关于门牌号识别任务的最新结果。 捕获顶部信息的深度网络模块用于生成仿射变换。 仿射变换应用于输入图像以获得关注区域，然后馈送到另一个深度网络模块。 通过使用可执行空间变换的可微网络层，可以端到端地训练整个过程。 注意尺度[3]使用软注意作为比例选择机制，并在图像分割任务中获得最先进的结果。<br>&emsp;&emsp;我们的残留注意网络中软关注结构的设计受到最近开发的定位任务的启发，即分割[22,25,1]和人体姿态估计[24]。 这些任务激励研究人员使用细粒度特征图来探索结构。 框架倾向于级联自下而上和自上而下的结构。 自下而上的前馈结构产生具有强语义信息的低分辨率特征映射。 之后，自上而下的网络产生密集的特征，以推断每个像素。 在底部和顶部特征图之间采用跳过连接[22]，并在图像分割上实现了最先进的结果。 最近堆叠的沙漏网络[24]融合了来自多个尺度的信息，以预测人体姿势，并从编码全局和本地信息中获益。  </p>
<h2 id="3-RAN"><a href="#3-RAN" class="headerlink" title="3 RAN"></a>3 RAN</h2><p>&emsp;&emsp;我们的残差注意网络是由叠加注意力模块组成的。每个注意力模块可以分为两个分支：主干分支和掩膜分支。主干分支用于特征提取，并且能够使用任何最先进的网络结构。在这个工作中，我们使用预激活的残差单元ResNeXt和Inception作为我们RAN网络的基础单元来组成注意力模块。</p>
]]></content>
      <categories>
        <category>论文阅读</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>attention</tag>
        <tag>图像分类</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL学习记录</title>
    <url>/2020/09/24/SQL%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>ShuffleNet</title>
    <url>/2019/01/23/ShuffleNet/</url>
    <content><![CDATA[<p>[论文地址]</p>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>&emsp;&emsp;我们介绍一种被设计用于计算能力有限的移动装置的卷积网络ShuffleNet，新的结构使用逐点群卷积和通道混洗方式，在保持准确率的情况下极大地减少运算量。在一个基于ARM的移动装置中，ShuffleNet在和AlexNet保持相同的准确率的情况下速度提升了13倍。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>&emsp;&emsp;目前更大更深的网络是主流趋势，主要是为了解决主流视觉识别任务。准确率最高的网络有上百层网络和上千层通道，需要的上百亿的FLOPs(每秒浮点数运算）。这篇报告与之完全对立，在保持最高的准确率的同时把计算量控制在10~100个百万FLOPs内，专注于公共移动平台，如无人机，机器人和智能手机。之前的工作主要致力于剪枝、压缩和使用小存储量代替基础网络结构。我们致力于提出一种新的适用于计算量有限制的基础网络结构。<br>&emsp;&emsp;我们注意到现在最先进的网络如Xception和ResNeXt在小网络的作用及其有限，因为密集的1X1卷积.因此我们提出<font color="#ff000" size="3">逐点群卷积</font>来降低1x1卷积的计算复杂度，群卷积会带来一些负面作用，我们使用<font color="#ff000" size="3">通道混洗</font>来解决这个问题。基于这两种方法，我们建立了一种高效结构，命名为ShuffleNet。与流行的结构相比，我们的结构可以允许更多的特征图通道在给定计算量的前提下，能够编码更多的信息，这对小网络的表现十分重要。</p>
<h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h2><h3 id="高效模型的设计"><a href="#高效模型的设计" class="headerlink" title="高效模型的设计"></a>高效模型的设计</h3><p>&emsp;&emsp;过去几年深度神经网络在计算机视觉任务上取得了成功，其中模型设计起了很大的作用。在可嵌入设备中运行更大更深的网络的需求不断增加，这激励了高效模型设计的研究。例如，GoogleNet与简单地堆叠卷积层的网络相比，增加了网络的深度并且复杂度更低。SqueezeNet在控制准确率的情况下显著地减少了计算量和参数。ResNet使用有效的bottleneck结构来提升性能。SENet介绍了一种能够花费较小计算量来提升性能的结构单元。</p>
<h3 id="组卷积"><a href="#组卷积" class="headerlink" title="组卷积"></a>组卷积</h3><p>&emsp;&emsp;组卷积的概念是AlexNet中提出来的，当时是为了两块GPU进行运算，并且在ResNeXt中证明了其有效性。深度分离卷积在Xception中提出并且分离卷积在Inception系列中得到推广。MobileNet使用深度分离卷积并且在轻量级网络中获得了最先进的结果。我们的工作是推广群卷积和一种新形式的深度分离卷积。</p>
<h3 id="通道混洗"><a href="#通道混洗" class="headerlink" title="通道混洗"></a>通道混洗</h3><p>&emsp;&emsp;在我们的认知中，通道混洗在高效网络模型设计中很少被提及。虽然CNNC库cuda-convnet支持随机通道卷积，这个操作相当于在组卷积后进行随机通道交换。这种“随机混洗”有不同的用途但是之后很少有人探索。最近有个two-stage卷积的工作采用了这个方法但是并没有深入研究通道混洗本身以及它在小模型设计上的作用.</p>
<h3 id="模型加速"><a href="#模型加速" class="headerlink" title="模型加速"></a>模型加速</h3><p>&emsp;&emsp;这个部分致力于加速推理同时保持预训练模型的准确率。对网络的连接和通道进行剪枝来减少网络在预训练模型的冗余连接以保模型性能。在文献中，量化和因式分解备用来减少冗余计算来加速推理。不修改参数，FFT和其它方法使用卷积方法工具来减少训练的时间消耗。把大网络的知识提炼到小网络，使训练小网络更加简单。</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="对分组卷积的通道混洗"><a href="#对分组卷积的通道混洗" class="headerlink" title="对分组卷积的通道混洗"></a>对分组卷积的通道混洗</h3><p><img src="/2019/01/23/ShuffleNet/ShuffleNet_figure_1.png" alt="Figure1"><br>&emsp;&emsp;现在的卷积神经网络通常由相同结构组成的重复模块构成。1x1的卷积没有全部采用的原因是1x1卷积需要相当大的复杂度.在小网络中，昂贵的逐点卷积会因复杂度限制而控制通道数量，这可能显著地减少准确率.<br>&emsp;&emsp;解决这个问题的直接方案是<font color="#ff000" size="3">通道稀疏连接</font>，比如包括1x1卷积的分组卷积。确保每个输入通道组上进行相应的卷积，组卷积就会显著地降低计算成本。但是这会带来新的问题：一些通道的输出仅仅来源于输入通道的一小部分。图1（a）说明了这种情况。很明显地看出，每个输出组只与它的输入组之间有联系。这个特性阻隔了通道组和弱表示的信息流动。<br>&emsp;&emsp;如果我们允许分组卷积可以从不同的组中获得输入数据，(如Figure1(b)),输入通道和输出通道就会全部建立联系。对于上一层分组卷积产生的特征图，我们可以把每个组的通道分离成更小的组，然后将这些组随机排序作为下一层网络每个组的输入。这个操作可以使用通道卷积方便快捷地实现（如Figure1（c））：计算拥有$g*n$个通道数g个组的卷积层；我们需要先将数据改变形状变为$(g,n)$,然后转换和扁平化作为下一层的输入。在其中我们注意到这个操作在经过两层不同分组的卷积后依然有效。更重要的是，通道混洗过程是十分微小的，这意味着它能够嵌入到端对端的网络训练中。<br>&emsp;&emsp;通道混洗操作使得使用大量分组卷积层的有效网络变得可能.在下一个部分我们将介绍一个使用分组卷积和通道混洗结构的有效的网络单元。</p>
<h3 id="ShuffleNet单元"><a href="#ShuffleNet单元" class="headerlink" title="ShuffleNet单元"></a>ShuffleNet单元</h3><p><img src="/2019/01/23/ShuffleNet/ShuffleNet_figure_2.png" alt="Figure2"><br>&emsp;&emsp;基于通道混洗操作的优点，我们提出了专门为小网络设计的新结构ShuffleNet单元。我们的设计基于ResNet的bottleneck模块（如Figure2（a））。这是一个残差模块。在他的残差分支中，我们在bottleneck模块的特征图提取模块采用了适合运算的3x3的深度卷积。之后，我们将第一个1x1卷积替代为逐点群卷积，之后进行通道混洗，这样来组成ShuffleNet单元，如Figure2（b）。第二个逐点群卷积的作用是将通道恢复到与捷径路线相同的尺寸。简单来说，我们在第二个逐点群卷积后并没有采用通道混洗，因为采用与否对结果没有影响。在ShuffleNet单元哪个位置设置步长的问题上，我们简单地进行了两个修改（如Figure2（c））：在捷径路线上添加3x3的平均值池化层；使用<font color="#ff000" size="3">通道级联（channel concatenation)</font>代替元素相加，这样可以在很少的额外计算下扩大通道尺寸。<br>&emsp;&emsp;与ResNet和RexNeXt相比较，我们的模型有更少的计算量。输入为<script type="math/tex">c*h*w</script>bottleneck通道数为m,ResNet单元要求<script type="math/tex">hw(2cm+9m^2)</script>FLOPs，ResNeXt单元要求<script type="math/tex">hw(2cm+9m^2/g)</script>FLOPs。ShuffleNet单元需要<script type="math/tex">hw(2cm/g+9m)</script>FLOPs，g是卷积的分组数。换句话说，在相同的计算量预算下，ShuffleNet可以使用更广泛的特征图。我们发现这对小网络是十分重要的，因为小网络在获取信息的过程中通道数量是不足的。<br>&emsp;&emsp;另外，ShuffleNet深度卷积仅应用于bottleneck特征图。虽然深度卷积在理论上有很少的计算量，但我们发现将它移植到低功耗的移动设备上是十分困难的，与其他密集网络相比，ShuffleNet网络可能会在计算与内存存取上存在不平衡。</p>
<h3 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h3><p><img src="/2019/01/23/ShuffleNet/ShuffleNet_table_1.png" alt="Table 1"><br>&emsp;&emsp;基于ShuffleNet单元，我们建立了如Table 1的ShuffleNet网络结构。提出的网络主要是由三个阶段聚集组成的ShuffleNet单元组成的。每个阶段首先建立的模块采用的步长为2.其它的超参数设置相同，并且下一个阶段的输出通道数翻倍。我们将bottleneck的通道数设置为输出通道的1/4.我们打算提供一种尽可能简单的基本设计，尽管我们发现进一步的超参数设置可能会带来更好的结果。<br>&emsp;&emsp;在ShuffleNet单元中，分组数g控制着逐点卷积的稀疏性。Table 1展示了不同组数的效果，我们采用的输出通道数尽可能使复杂度不变。效果十分明显，在相同的复杂度下大的分组导致更多的输出通道（这也意味着更多的卷积核），这意味着在输入通道有限的情况下大分组可以编码更多的信息。<br>&emsp;&emsp;Table 1是网络的完全体，之后的ShuffleNet<script type="math/tex">s*</script>意味着网络的复杂度大致是原网络的$s^2$.</p>
<h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2>]]></content>
      <categories>
        <category>论文阅读</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>轻量级网络</tag>
      </tags>
  </entry>
  <entry>
    <title>ShuffleNetV2</title>
    <url>/2019/01/23/ShuffleNetV2/</url>
    <content><![CDATA[<p><a href="https://arxiv.org/pdf/1807.11164.pdf">论文地址</a></p>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>&emsp;&emsp;近年来，神经网络的结构设计极大地被间接度量计算复杂度（如FLOPs）导向，直接度量速度还会被其它因素诸如内存存取消耗和平台特性所影响。因此，我们的工作打算计算目标平台的直接度量，而不仅仅考虑间接度量FLOPs。基于一系列的限制性实验，我们的工作获得了一些有效的网络设计的实用指南。相应地，我们提出了ShuffleNet V2这种新的网络结构。进行了全面的消融实验后，我们证实了在速度和准确率进行权衡的情况下，ShuffleNet V2是最先进的。  </p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><img src="/2019/01/23/ShuffleNetV2/ShuffleNetV2_Figure1.png" alt="Figure1">  </p>
<p>&emsp;&emsp;深度神经网络经过最近几年的发展变得更加准确和更加快速。但是在高准确率下计算复杂度这个重要问题被忽略了。实际任务中要求在目标平台（如硬件）和应用场景（如需要低延迟的自动驾驶）这些计算有限制的情况下得到最高的准确率。这激励了一些轻量级网络的研究，并且需要在速度和准确率之间做更好地平衡，此类网络有Xception,MobileNet,MobileNet V2,ShuffleNet和CondenseNet。这些工作中分组卷积和深度卷积有十分重要的作用。<br>&emsp;&emsp;计算复杂度采用最广泛的度量是FLOPs。但FLOPs是一个间接度量。它只是一个近似值，而且和我们关注的直接度量如速度或延迟通常情况下是不等的，这种差异已经被许多工作证实。因此，仅仅使用FLOPs作为复杂度度量是不充分的，并且会导致设计的架构不是最优的。<br>&emsp;&emsp;导致间接度量（FLOPs）和直接度量（速度）的差异主要有两个。首先FLOPs没有顾忌对速度有影响的几个重要因素。<font color="#ff000" size="3">一个因素是内存访问消耗</font>，这种消耗在某些操作比如分组卷积占有很大一部分运行时间,这可能是大型设备比如GPU的瓶颈。这个成本在网络架构设计的时候不能被忽略。另一个因素是并行度。在相同的FLOPs下，高并行度的网络比低并行度的网络运行更快。<br>&emsp;&emsp;<font color="#ff000" size="3">另一个因素是相同的FLOPs需要的运行时间不同</font>,这取决于平台。比如，张量分解被广泛地用于早期的加速矩阵乘法运算。但是最近的研究发现分解在减少了75%FLOPs的情况下在GPU上的速度更慢。我们调查发现最新的CUDNN对3x3的卷积会进行特殊优化，并不能确定3x3的卷积一定比9个1x1的卷积速度慢。<br>&emsp;&emsp;根据这些观察结果，我们提出了<font color="#ff000" size="3">两个应该被并用于有效网络架构设计的原则</font>。第一，使用直接度量代替间接度量；第二，在目标平台上计算相同的度量。<br>&emsp;&emsp;在我们的工作中，我们遵循这两个原则并提出了一个更有效的网络架构。在第二部分，我们首先分析了两个具有代表性的先进网络的运行时间。之后，我们获得了四个有效网络设计的指导方针，这些方针超出了FLOPs的考虑范围，而且与平台无关。我们使用专门优化的代码在两个平台（GPU和ARM）上做了一系列控制实验去证实他们，确信我们的结果是最先进的。<br>&emsp;&emsp;在第三部分，根据指导方针，我们设计了一个新的网络结构。它是ShuffleNet网络的衍生版本，名为ShuffleNet V2。经过第四部分全面的实验后证实ShuffleNet V2在所有的平台上比之前的网络更快更准确。  </p>
<h2 id="有效网络设计的实际指导方针"><a href="#有效网络设计的实际指导方针" class="headerlink" title="有效网络设计的实际指导方针"></a>有效网络设计的实际指导方针</h2><p>&emsp;&emsp;我们的研究是在两个广泛采用的硬件上对CNN库进行工业级优化。我们注意到我们的CNN库比大部分开源的CNN库更有效，因此，我们确信我们的观察结果和结论是有力的并且在工业中实践是有意义的。  </p>
<p><img src="/2019/01/23/ShuffleNetV2/ShuffleNetV2_Figure2.png" alt="Figure2"><br>&emsp;&emsp;其它的设置包括：打开所有的优化项（比如：用于减少小运算带来的计算开支的张量融合）。图片的输入尺寸是$224\times 224$。每个网络进行随机初始并计算100次，采用平均运行时间。<br>&emsp;&emsp;在开始我们的工作前，我们先分析了目前两个最先进的网络ShuffleNet V1和MobiileNet V2的运行时间。它们在ImageNet分类任务中都十分有效和准确。并且它们都被低端设备比如手机广泛应用。虽然我们仅分析这两个网络，但这两个网络代表了现在的趋势。它们的核心是分组卷积和深度卷积，这些操作是目前先进网络的重要组成部分，比如ResNeXt,Xception,MobileNet和CondenseNet。<br>&emsp;&emsp;综合的运行时间被不同的运算分解，如图2，我们注意到FLOPs度量仅仅计算卷积部分的花费。尽管卷积占所有运算的大部分，但是其它的运算包括数据输入输出，数据混洗以及逐元素运算也占据了大量的时间。<font color="#ff000" size="3">FLOPs不能够精准地评估运算时间。</font><br>&emsp;&emsp;基于这个观察结果，我们从不同的方面对运行时间提出了细节的分析，并且获得了几个有效网络架构设计的指导指南。  </p>
<h3 id="G1-相同的通道可以最小化内存存取消耗"><a href="#G1-相同的通道可以最小化内存存取消耗" class="headerlink" title="G1)相同的通道可以最小化内存存取消耗"></a>G1)相同的通道可以最小化内存存取消耗</h3><p>&emsp;&emsp;现在的网络通常采用深度分离卷积，在深度分离卷积中，1x1的卷积占据了绝大部分复杂度。我们开始研究1x1卷积。1x1卷积由两个参数来表示，输入通道数$c<em>{1}$,输出通道数为$c</em>{2}$。h和w是特征图的长和宽，1x1卷积的FLOPs是</p>
<script type="math/tex; mode=display">B=hwc_{1}c_{2}</script><p>&emsp;&emsp;为了简化计算，我们假定计算设备足够存储全部的特征图和参数，这样的话，内存存储消耗</p>
<script type="math/tex; mode=display">MAC=hw(c_{1}+c_{2})+c_{1}c_{2}</script><p>&emsp;&emsp;从均值不等的情况，我们可以得出:</p>
<script type="math/tex; mode=display">MAC\geq 2\sqrt{hwB}+\frac{B}{hw}(1)</script><p>&emsp;&emsp;从公式（1）可以看出，<font color="#ff000" size="3">MAC的下限被FLOPs捆绑，输入通道数等于输出通道数的时候MAC达到最小。</font><br>&emsp;&emsp;这个结论只是理论上，实际中很多设备的缓存没有假设的那么大，而且现代计算库通常采用复杂的阻塞策略来充分利用缓存机制。因此，真实的MAC值肯能会偏离理论上的值。为了证实我们的结论，我们随后进行了实验，通过重复堆叠10个构建块来构建基准网络，每一个块包括两个卷积层，第一层输入通道为$c<em>{1}$，输出通道为$c</em>{2}$，下一层网络与之相反。<br>&emsp;&emsp;表1展示了实验结果，当输入输出通道数比值为1：1时，可以看出MAC值会变得更小并且网络计算速度会更快。<br><img src="/2019/01/23/ShuffleNetV2/ShuffleNetV2_table1.png" alt="Table1">  </p>
<h3 id="G2-过大的分组卷积会提高MAC"><a href="#G2-过大的分组卷积会提高MAC" class="headerlink" title="G2)过大的分组卷积会提高MAC"></a>G2)过大的分组卷积会提高MAC</h3><p>&emsp;&emsp;目前分组卷积是很多先进网络的核心部分，它通过将密集卷积的通道分组进行卷积来减少计算复杂度（FLOPs），因此它可以在与传统结构在FLOPs相同的情况下使用更多的通道，进而提升模型的性能。但是，提升的通道数导致了更大的MAC。<br>&emsp;&emsp;从（1）的公式进行推导，FLOPs的值</p>
<script type="math/tex; mode=display">B=hwc_{1}c_{2}/g</script><p>&emsp;&emsp;1x1的分组卷积中MAC和FLOPs的关系为：</p>
<script type="math/tex; mode=display">MAC=hw(c_{1}+c_{2})+\frac{c_{1}c_{2}}{g}</script><script type="math/tex; mode=display">=hwc_{1}+\frac{Bg}{c_{1}}+\frac{B}{hw}(2)</script><p>&emsp;&emsp;g是分组数。从公式中可以看出，在给定输入尺寸$c_{1}\times h\times w$和计算量B，MAC的值与g的值正相关。<br>&emsp;&emsp;为了研究在实践过程中的有效性，我们堆积了10个逐点组卷积来构建基准网络。表2展示了在相同的FLOPs情况下运行速度的差异。从表中可以清晰地看出分组数对运行速度的影响。对比分组数为1和分组数为8的实验结果可以看出，分组数为8的模型运行速度是分组数为1的一倍，在ARM上的数独也慢了30%。<br><img src="/2019/01/23/ShuffleNetV2/ShuffleNetV2_table2.png" alt="Table2"><br>&emsp;&emsp;因此，我们建议分组数应该基于目标平台和任务认真选择。简单地增加分组数愚蠢的，因为这在增加准确率的同时也会增加计算量，很可能得不偿失。</p>
<h3 id="G3-分裂网络会减少并行度"><a href="#G3-分裂网络会减少并行度" class="headerlink" title="G3)分裂网络会减少并行度"></a>G3)分裂网络会减少并行度</h3><p>&emsp;&emsp;在GoogleNet的一系列网络和自动生成网络中，大量采用的了“多径”网络来提高准确率。使用小的操作（分裂网络）来代替一些大网络会带来准确率的提升，但是由于这种操作对大型计算设备如GPU的并行性不是很友好，而且会在内核启动和同步的时候带来额外消耗，因此它会增加计算量。<br>&emsp;&emsp;为了量化分裂网络是如何影响效率的，我们使用不同数量的分类网络制作了一系列网络模块进行实验。每个网络模块包含1-4个1x1的卷积，如何将10个这样的模块堆积在一起组成一个网络，然后它们进行顺序运算或者并行运算。进行的实验效果如表3所示。<br><img src="/2019/01/23/ShuffleNetV2/ShuffleNetV2_table3.png" alt="Table3"><br>&emsp;&emsp;表3展示了分裂网络显著地降低了GPU的速度，比如4个分裂网络结构的速度只有1个分类网络结构的1/3。在ARM上的减少相对来说很小。  </p>
<h3 id="G4-逐像素操作不可忽视"><a href="#G4-逐像素操作不可忽视" class="headerlink" title="G4)逐像素操作不可忽视"></a>G4)逐像素操作不可忽视</h3><p>&emsp;&emsp;如图2所示，在轻量级网络中逐像素操作在时间上占据了很大一部分，特别是在GPU上。在我们文章中，逐像素操作包括ReLU，AddTensor，AddBias等等。它们有很小的FLOPs但是在有着很大的MAC。我们将深度卷积也作为逐像素的一员，因为它的MAC与FLOPs的比值很高。<br>&emsp;&emsp;为了验证我们的猜想，我们使用“bottlenecks”单元进行了实验，分别去除ReLU和短路连接，在表4中可以看到实验结果。当两个操作都被去除时，在GPU和ARM上都会得到20%的加速。<br><img src="/2019/01/23/ShuffleNetV2/ShuffleNetV2_table4.png" alt="Table4">  </p>
<h3 id="结论和讨论"><a href="#结论和讨论" class="headerlink" title="结论和讨论"></a>结论和讨论</h3><p>&emsp;&emsp;根据上面的指南和研究经验，我们推断一个有效的网络架构需要1）使用平衡的卷积操作（通道相等）；2）关注分组卷积的损失；3）减少分裂的程度；4）减少逐像素操作，这些理想的属性取决于超出理论FLOPs的平台特性（例如内存操作和代码优化）。  </p>
<h2 id="ShuffleNet-V2：一个有效的架构"><a href="#ShuffleNet-V2：一个有效的架构" class="headerlink" title="ShuffleNet V2：一个有效的架构"></a>ShuffleNet V2：一个有效的架构</h2><h3 id="评价ShuffleNet-V1"><a href="#评价ShuffleNet-V1" class="headerlink" title="评价ShuffleNet V1"></a>评价ShuffleNet V1</h3><p>&emsp;&emsp;ShuffleNet是目前先进的网络结构，它被广泛地用于计算能力较低的终端设备比如手机。根据ShuffleNet论文所描述的，目前轻量级网络的主要挑战是在给定计算量的前提下特征通道数量的限制。为了在不提高FLOPs的情况下提高通道数，他们采用了逐点群卷积和bottleneck型的结构。为了提高不同组之间的信息交流，他们使用了通道混洗操作，同时准确率得到提升。根据第二部分的讨论，逐点群卷积和bottleneck结构都会提高MAC(G1和G2)，这个损失是不能忽略的，并且，使用太多的分组也违背了G3，在捷径连接中的逐像素“Add”操作也违背了G4。<font color="#ff000" size="3">因此，为了建立一个高效的模型，关键问题是保持与密集卷积相同的通道数，并且不能有太多的分组。</font>  </p>
<h3 id="通道分离和ShuffleNet-V2"><a href="#通道分离和ShuffleNet-V2" class="headerlink" title="通道分离和ShuffleNet V2"></a>通道分离和ShuffleNet V2</h3><p><img src="/2019/01/23/ShuffleNetV2/ShuffleNetV2_Figure3.png" alt="Figure3"></p>
<p>&emsp;&emsp;根据上面的目的，我们介绍了一种简单的操作名为通道分离（channel split）。在图三(c)中可以看到。在每个单元的开始出，输入通道数c被分成了两个独立的分支c和c’。遵循G3的指导，一个分支独自保留。另一个分支由三个卷积组成并且输入输出通道数遵循G1的原则保持一致。两个1x1卷积部分遵循G2没有进行分组卷积（因为channel split操作分成了两个组）。<br>&emsp;&emsp;卷积之后两个分支被串联（concatnated)，因此通道数保持一致。与ShuffleNet相同的通道混洗操作放到了两个分支串联之后，被用来进行信息交流。<br>&emsp;&emsp;在通道混洗之后，就会开始下个单元。可以注意到ShuffleNet V1中的“Add”操作被取消了。逐像素操作如ReLU和设定卷积只存在一个分支上，并且三个连续的逐像素操作cancat,channel shuffle和channel split被合并成一个逐像素操作。根据G4这种改变是有利的。对于空间下采样，如图3（d），移除了通道分离操作，之后的通道会翻倍。<br>&emsp;&emsp;遵循上面提出的4个指导方针，我们提出了图3（c）（d）这种模块，将其命名为ShuffleNet V2。使用上面的模块进行堆积就会建好网络。为了便利，我们将c’设置为c的一半。整体的网络结构与ShuffleNet v1类似，见表5。唯一的不同之处是：ShuffleNet v1缺少了global averaged pooling层。与ShuffleNet v1相似，我们设置了不同的网络通道数比例来产生不同的网络来适应不同的复杂度。<br><img src="/2019/01/23/ShuffleNetV2/ShuffleNetV2_table5.png" alt="Table5">  </p>
<h3 id="网络准确性性分析"><a href="#网络准确性性分析" class="headerlink" title="网络准确性性分析"></a>网络准确性性分析</h3><p><img src="/2019/01/23/ShuffleNetV2/ShuffleNetV2_Figure4.png" alt="Figure4"><br>&emsp;&emsp;ShuffleNet V2网络不仅高效，而且准确，主要两个原因，每个构建模块组成的高效率能够使用更多的特征通道和更大的网络容量。第二个原因是每个模块都会有三分之一的特征通道被直接通过模块进入下一个模块。这可以理解为一种特征重用，在DenseNet和CondenseNet中有相似的部分。在DenseNet中，为了分析特征重用模式，绘制了层间权重的l1范数，如图4（a）所示。很明显，相邻层之间的连接比其他层更强。这意味着所有层之间的密集连接可能引入冗余。最近的CondenseNet也支持这一观点。在ShuffleNet V2中，很容易证明第i和第（i + j）个构建块之间的“直接连接”通道的数量是$r^{j}c$，其中r =（1-c’）/ c。换句话说，特征重用量随着两个块之间的距离呈指数衰减。在远程块之间，特征重用变得更弱。图4（b）绘制了与（a）中类似的可视化，其中r = 0.5。注意，（b）中的模式类似于（a）。因此，ShuffleNet V2通过设计实现了这种特征重用模式，它与DenseNet有着高精度特征重用的相似性，但是它的效率更高，在表8中将证实。  </p>
<h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>&emsp;&emsp;我们的消融实验在ImageNet2012的分类数据集上进行，和之前轻量级网络的实验设置相同，所有的网络在四个复杂度上进行比较，分别为40、140、300和500MFLOPs。这些复杂度在移动场景中具有典型性，其它的超参数和协议与ShuffleNet v1相同。我们比较了4种网络：  </p>
<ul>
<li><p>ShuffleNet v1：分组设置为3  </p>
</li>
<li><p>MobileNet v2：我们将论文中的准确率与我们复现的准确率都列出来，有一些结果论文中并没有  </p>
</li>
<li><p>Xception：原始的Xception非常大，我们采用最近的一个对它进行修改后的衍生版本  </p>
</li>
<li><p>DenseNet：原始的网络不适合进行对比实验，我们将表5中的2-4步替换为DenseNet网络的模块进行对比实验，通过调整通道数来控制网络复杂度。  </p>
</li>
</ul>
<p>&emsp;&emsp;表8显示了所有结果。我们对结果从不同方面进行分析。<br>&emsp;&emsp;<font color="#00fff" size="3">同FLOPs比较速度</font></p>
<p>&emsp;&emsp;<font color="#00fff" size="3">推理速度/(FLOPs/Accuracy)</font>IGV2、IGV3使用通道多，速度慢。</p>
<p>&emsp;&emsp;<font color="#00fff" size="3">与其它网络的兼容性</font></p>
<p>&emsp;&emsp;<font color="#00fff" size="3">构成大网络后效果</font></p>
<p>&emsp;&emsp;<font color="#00fff" size="3">目标检测</font>  大的感受野可以增加目标检测的效果（Xception），我们在增加了一个3x3卷积在每个模块的1x1卷积之前，构成ShuffleNet v2*。<br><img src="/2019/01/23/ShuffleNetV2/ShuffleNetV2_table6.png" alt="Table6">  </p>
<p><img src="/2019/01/23/ShuffleNetV2/ShuffleNetV2_table7.png" alt="Table7">  </p>
<p><img src="/2019/01/23/ShuffleNetV2/ShuffleNetV2_table8.png" alt="Table8">  </p>
]]></content>
      <categories>
        <category>论文阅读</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>轻量级网络</tag>
      </tags>
  </entry>
  <entry>
    <title>c++学习记录</title>
    <url>/2020/08/05/c-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h2 id="c-11"><a href="#c-11" class="headerlink" title="c++11"></a>c++11</h2><p><a href="https://blog.csdn.net/hailong0715/article/details/54172848">使用:进行迭代</a></p>
<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p><a href="https://blog.csdn.net/weixin_36888577/article/details/79937886">c++优先队列<code>priority_queue</code></a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//升序队列</span></span><br><span class="line">priority_queue &lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt; &gt; q;</span><br><span class="line"><span class="comment">//降序队列</span></span><br><span class="line">priority_queue &lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,less&lt;<span class="type">int</span>&gt; &gt;q;</span><br></pre></td></tr></table></figure>
<h2 id="指针常量和常量指针"><a href="#指针常量和常量指针" class="headerlink" title="指针常量和常量指针"></a>指针常量和常量指针</h2><p>常量指针指向的内容不可以修改，指针的指向可以修改；指针常量的指向不可以修改，指针指向的值可以修改。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">const_pointer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    常量指针：</span></span><br><span class="line"><span class="comment">    指针指向的内容不可以修改，指针的指向可以修改</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>* p = &amp;a;</span><br><span class="line">    <span class="comment">// *p = 20 error</span></span><br><span class="line">    p = &amp;b;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p is &quot;</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    指针常量</span></span><br><span class="line"><span class="comment">    指针的指向不可以修改，指针指向的值可以修改</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">int</span>* <span class="type">const</span> p2 = &amp;a;</span><br><span class="line">    *p2 = <span class="number">20</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p2 is &quot;</span> &lt;&lt; *p2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="二维数组定义和分配内存"><a href="#二维数组定义和分配内存" class="headerlink" title="二维数组定义和分配内存"></a>二维数组定义和分配内存</h3><p>c++中有三种方法来动态申请多维数组</p>
<p>1)  c中的malloc/free<br>2)  c++中的new/delete<br>3)  STL容器中的vector</p>
<h4 id="第一种：-malloc-free"><a href="#第一种：-malloc-free" class="headerlink" title="第一种： malloc/free"></a>第一种： malloc/free</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * c++动态申请多维数组</span></span><br><span class="line"><span class="comment"> * 第一种 malloc/free</span></span><br><span class="line"><span class="comment"> * @param len 一维数组大小</span></span><br><span class="line"><span class="comment"> * @param m 二维数组行数</span></span><br><span class="line"><span class="comment"> * @param n 二维数组列数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dynamicCreate1Array</span><span class="params">(<span class="type">int</span> len, <span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 一维数组</span></span><br><span class="line">    <span class="type">int</span> *p;</span><br><span class="line">    p = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>)*len);    <span class="comment">// 动态开辟m大小的数组</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;malloc/free&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">PrintArray</span>(p, len);</span><br><span class="line">    <span class="comment">// 释放空间</span></span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二维数组</span></span><br><span class="line">    <span class="type">int</span> **p2;</span><br><span class="line">    p2 = (<span class="type">int</span>**)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>*)*m);         <span class="comment">//开辟行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        p2[i] = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>*)*n);   <span class="comment">//开辟列</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">PrintArray</span>(p2, m, n);</span><br><span class="line">    <span class="comment">// 释放空间</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        <span class="built_in">free</span>(*(p2+i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="第二种：new-delete"><a href="#第二种：new-delete" class="headerlink" title="第二种：new/delete"></a>第二种：new/delete</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * c++动态申请多维数组</span></span><br><span class="line"><span class="comment"> * 第二种 new/delete</span></span><br><span class="line"><span class="comment"> * @param len 一维数组大小</span></span><br><span class="line"><span class="comment"> * @param m 二维数组行数</span></span><br><span class="line"><span class="comment"> * @param n 二维数组列数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dynamicCreate2Array</span><span class="params">(<span class="type">int</span> len, <span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 开辟空间</span></span><br><span class="line">    <span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">int</span>[len];      <span class="comment">// 只分配空间未进行初始话</span></span><br><span class="line">    <span class="type">int</span> *p1 = <span class="keyword">new</span> <span class="type">int</span>[len]();    <span class="comment">// 分配空间并进行初始化</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;new/delete&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">PrintArray</span>(p, len);</span><br><span class="line">    <span class="built_in">PrintArray</span>(p1, len);</span><br><span class="line">    <span class="comment">// 释放空间</span></span><br><span class="line">    <span class="keyword">delete</span>[] p;</span><br><span class="line">    <span class="keyword">delete</span>[] p1;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> **p2 = <span class="keyword">new</span> <span class="type">int</span>*[m];     <span class="comment">// 开辟行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        p2[i] = <span class="keyword">new</span> <span class="type">int</span>[n]();     <span class="comment">// 开辟列</span></span><br><span class="line">    <span class="built_in">PrintArray</span>(p2, m, n);</span><br><span class="line">    <span class="comment">// 释放空间</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        <span class="keyword">delete</span>[] p2[i];</span><br><span class="line">    <span class="keyword">delete</span>[] p2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="第三种：STL容器中的vector"><a href="#第三种：STL容器中的vector" class="headerlink" title="第三种：STL容器中的vector"></a>第三种：STL容器中的vector</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * c++动态申请多维数组</span></span><br><span class="line"><span class="comment"> * 第三种 </span></span><br><span class="line"><span class="comment"> * @param len 一维数组大小</span></span><br><span class="line"><span class="comment"> * @param m 二维数组行数</span></span><br><span class="line"><span class="comment"> * @param n 二维数组列数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dynamicCreate3Array</span><span class="params">(<span class="type">int</span> len, <span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(len)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;vector&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;输出一维数组&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; p.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        cout &lt;&lt; p[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">p2</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;输出二维数组&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">            cout &lt;&lt; p2[i][j] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>引用的本质是指针常量</p>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h3 id="类的权限"><a href="#类的权限" class="headerlink" title="类的权限"></a>类的权限</h3><p>类的权限有3种</p>
<ol>
<li>public 类内类外都可以访问</li>
<li>protected 类内可以访问，类外不可以访问，可以继承</li>
<li>private 类内可以访问，类外不可以访问，不可以继承</li>
</ol>
<h3 id="struct和class的区别"><a href="#struct和class的区别" class="headerlink" title="struct和class的区别"></a>struct和class的区别</h3><p>struct默认权限为公共，class默认权限为私有。</p>
<h3 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h3><ul>
<li>构造函数<ul>
<li>函数名与类名相同</li>
<li>构造函数可以有参数，可以发生重载</li>
<li>创建对象时，构造函数会自动调用，而且只调用一次</li>
</ul>
</li>
<li>析构函数<ul>
<li>没有返回值，不写void</li>
<li>函数名与类名相同，在名称前加~</li>
<li>析构函数不可以有参数，不可以发生重载</li>
<li>对象在销毁前会自动调用析构函数，而且只会调用一次</li>
</ul>
</li>
</ul>
<h3 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h3><ul>
<li>浅拷贝：简单的赋值拷贝操作（系统默认拷贝构造方式为浅拷贝）</li>
<li>深拷贝：在堆区重新申请空间，进行拷贝操作</li>
</ul>
<h2 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h2><h3 id="c-文件操作有三类"><a href="#c-文件操作有三类" class="headerlink" title="c++文件操作有三类"></a>c++文件操作有三类</h3><ol>
<li>ofstream:写操作</li>
<li>ifstream:读操作</li>
<li>fstream: 读写操作</li>
</ol>
<h3 id="读-写文件的步骤"><a href="#读-写文件的步骤" class="headerlink" title="读/写文件的步骤"></a>读/写文件的步骤</h3><p>打开头文件-&gt;创建流对象-&gt;打开文件-&gt;写/读数据-&gt;关闭文件</p>
<h3 id="打开文件的方式"><a href="#打开文件的方式" class="headerlink" title="打开文件的方式"></a>打开文件的方式</h3><div class="table-container">
<table>
<thead>
<tr>
<th>模式</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>in</td>
<td>打开文件用于读取</td>
</tr>
<tr>
<td>out</td>
<td>打开文件用于写入</td>
</tr>
<tr>
<td>ate</td>
<td>打开文件并移到末尾</td>
</tr>
<tr>
<td>app</td>
<td>打开文件用于追加</td>
</tr>
<tr>
<td>trunc</td>
<td>若文件已存在，打开文件并截  取流（清除原有数据)</td>
</tr>
<tr>
<td>binary</td>
<td>以二进制流方式打开文件</td>
</tr>
</tbody>
</table>
</div>
<h3 id="读取文本文件的四种方法"><a href="#读取文本文件的四种方法" class="headerlink" title="读取文本文件的四种方法"></a>读取文本文件的四种方法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ifstream ifs;</span><br><span class="line"></span><br><span class="line">    ifs.<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, ios::in);</span><br><span class="line">    <span class="keyword">if</span> (!ifs.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;文件打开失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读数据</span></span><br><span class="line">    <span class="comment">// 第一种</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span> (ifs &gt;&gt; buf) &#123;</span><br><span class="line">        cout &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二种</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span> (ifs.<span class="built_in">getline</span>(buf, <span class="built_in">sizeof</span>(buf))) &#123;</span><br><span class="line">        cout &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第三种</span></span><br><span class="line">    string buf;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getline</span>(ifs, buf)) &#123;</span><br><span class="line">        cout &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第四种</span></span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="keyword">while</span> ((c = ifs.<span class="built_in">get</span>()) != EOF) &#123; <span class="comment">// EOF end of file</span></span><br><span class="line">        cout &lt;&lt; c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ifs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二进制文件的读写"><a href="#二进制文件的读写" class="headerlink" title="二进制文件的读写"></a>二进制文件的读写</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">char</span> m_name[<span class="number">64</span>];</span><br><span class="line">    <span class="type">int</span> m_age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写文件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ofstream ofs;</span><br><span class="line"></span><br><span class="line">    ofs.<span class="built_in">open</span>(<span class="string">&quot;person.txt&quot;</span>, ios::out | ios::binary);</span><br><span class="line">    Person p = &#123;<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>&#125;;</span><br><span class="line">    ofs.<span class="built_in">write</span>((<span class="type">const</span> <span class="type">char</span> *)&amp;p, <span class="built_in">sizeof</span>(Person));</span><br><span class="line"></span><br><span class="line">    ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读文件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test04</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ifstream ifs;</span><br><span class="line"></span><br><span class="line">    ifs.<span class="built_in">open</span>(<span class="string">&quot;person.txt&quot;</span>, ios::in | ios::binary);</span><br><span class="line">    <span class="keyword">if</span> (!ifs.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;文件打开失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Person p;</span><br><span class="line">    ifs.<span class="built_in">read</span>((<span class="type">char</span> *)&amp;p, <span class="built_in">sizeof</span>(Person));</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; p.m_name &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;年龄：&quot;</span> &lt;&lt; p.m_age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    ifs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>git命令大全</title>
    <url>/2021/07/29/git%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/</url>
    <content><![CDATA[<p><a href="https://gist.github.com/guweigang/9848271">摘自https://gist.github.com/guweigang/9848271</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git init                                                  # 初始化本地git仓库（创建新仓库）</span><br><span class="line">git config --global user.name &quot;xxx&quot;                       # 配置用户名</span><br><span class="line">git config --global user.email &quot;xxx@xxx.com&quot;              # 配置邮件</span><br><span class="line">git config --global color.ui true                         # git status等命令自动着色</span><br><span class="line">git config --global color.status auto</span><br><span class="line">git config --global color.diff auto</span><br><span class="line">git config --global color.branch auto</span><br><span class="line">git config --global color.interactive auto</span><br><span class="line">git config --global --unset http.proxy                    # remove  proxy configuration on git</span><br><span class="line">git clone git+ssh://git@192.168.53.168/VT.git             # clone远程仓库</span><br><span class="line">git status                                                # 查看当前版本状态（是否修改）</span><br><span class="line">git add xyz                                               # 添加xyz文件至index</span><br><span class="line">git add .                                                 # 增加当前子目录下所有更改过的文件至index</span><br><span class="line">git commit -m &#x27;xxx&#x27;                                       # 提交</span><br><span class="line">git commit --amend -m &#x27;xxx&#x27;                               # 合并上一次提交（用于反复修改）</span><br><span class="line">git commit -am &#x27;xxx&#x27;                                      # 将add和commit合为一步</span><br><span class="line">git rm xxx                                                # 删除index中的文件</span><br><span class="line">git rm -r *                                               # 递归删除</span><br><span class="line">git log                                                   # 显示提交日志</span><br><span class="line">git log -1                                                # 显示1行日志 -n为n行</span><br><span class="line">git log -5</span><br><span class="line">git log --stat                                            # 显示提交日志及相关变动文件</span><br><span class="line">git log -p -m</span><br><span class="line">git show dfb02e6e4f2f7b573337763e5c0013802e392818         # 显示某个提交的详细内容</span><br><span class="line">git show dfb02                                            # 可只用commitid的前几位</span><br><span class="line">git show HEAD                                             # 显示HEAD提交日志</span><br><span class="line">git show HEAD^                                            # 显示HEAD的父（上一个版本）的提交日志 ^^为上两个版本 ^5为上5个版本</span><br><span class="line">git tag                                                   # 显示已存在的tag</span><br><span class="line">git tag -a v2.0 -m &#x27;xxx&#x27;                                  # 增加v2.0的tag</span><br><span class="line">git show v2.0                                             # 显示v2.0的日志及详细内容</span><br><span class="line">git log v2.0                                              # 显示v2.0的日志</span><br><span class="line">git diff                                                  # 显示所有未添加至index的变更</span><br><span class="line">git diff --cached                                         # 显示所有已添加index但还未commit的变更</span><br><span class="line">git diff HEAD^                                            # 比较与上一个版本的差异</span><br><span class="line">git diff HEAD -- ./lib                                    # 比较与HEAD版本lib目录的差异</span><br><span class="line">git diff origin/master..master                            # 比较远程分支master上有本地分支master上没有的</span><br><span class="line">git diff origin/master..master --stat                     # 只显示差异的文件，不显示具体内容</span><br><span class="line">git remote add origin git+ssh://git@192.168.53.168/VT.git # 增加远程定义（用于push/pull/fetch）</span><br><span class="line">git branch                                                # 显示本地分支</span><br><span class="line">git branch --contains 50089                               # 显示包含提交50089的分支</span><br><span class="line">git branch -a                                             # 显示所有分支</span><br><span class="line">git branch -r                                             # 显示所有原创分支</span><br><span class="line">git branch --merged                                       # 显示所有已合并到当前分支的分支</span><br><span class="line">git branch --no-merged                                    # 显示所有未合并到当前分支的分支</span><br><span class="line">git branch -m master master_copy                          # 本地分支改名</span><br><span class="line">git checkout -b master_copy                               # 从当前分支创建新分支master_copy并检出</span><br><span class="line">git checkout -b master master_copy                        # 上面的完整版</span><br><span class="line">git checkout features/performance                         # 检出已存在的features/performance分支</span><br><span class="line">git checkout --track hotfixes/BJVEP933                    # 检出远程分支hotfixes/BJVEP933并创建本地跟踪分支</span><br><span class="line">git checkout v2.0                                         # 检出版本v2.0</span><br><span class="line">git checkout -b devel origin/develop                      # 从远程分支develop创建新本地分支devel并检出</span><br><span class="line">git checkout -- README                                    # 检出head版本的README文件（可用于修改错误回退）</span><br><span class="line">git merge origin/master                                   # 合并远程master分支至当前分支</span><br><span class="line">git cherry-pick ff44785404a8e                             # 合并提交ff44785404a8e的修改</span><br><span class="line">git push origin master                                    # 将当前分支push到远程master分支</span><br><span class="line">git push origin :hotfixes/BJVEP933                        # 删除远程仓库的hotfixes/BJVEP933分支</span><br><span class="line">git push --tags                                           # 把所有tag推送到远程仓库</span><br><span class="line">git fetch                                                 # 获取所有远程分支（不更新本地分支，另需merge）</span><br><span class="line">git fetch --prune                                         # 获取所有原创分支并清除服务器上已删掉的分支</span><br><span class="line">git pull origin master                                    # 获取远程分支master并merge到当前分支</span><br><span class="line">git mv README README2                                     # 重命名文件README为README2</span><br><span class="line">git reset --hard HEAD                                     # 将当前版本重置为HEAD（通常用于merge失败回退）</span><br><span class="line">git rebase</span><br><span class="line">git branch -d hotfixes/BJVEP933                           # 删除分支hotfixes/BJVEP933（本分支修改已合并到其他分支）</span><br><span class="line">git branch -D hotfixes/BJVEP933                           # 强制删除分支hotfixes/BJVEP933</span><br><span class="line">git ls-files                                              # 列出git index包含的文件</span><br><span class="line">git show-branch                                           # 图示当前分支历史</span><br><span class="line">git show-branch --all                                     # 图示所有分支历史</span><br><span class="line">git whatchanged                                           # 显示提交历史对应的文件修改</span><br><span class="line">git revert dfb02e6e4f2f7b573337763e5c0013802e392818       # 撤销提交dfb02e6e4f2f7b573337763e5c0013802e392818</span><br><span class="line">git ls-tree HEAD                                          # 内部命令：显示某个git对象</span><br><span class="line">git rev-parse v2.0                                        # 内部命令：显示某个ref对于的SHA1 HASH</span><br><span class="line">git reflog                                                # 显示所有提交，包括孤立节点</span><br><span class="line">git show HEAD@&#123;5&#125;</span><br><span class="line">git show master@&#123;yesterday&#125;                               # 显示master分支昨天的状态</span><br><span class="line">git log --pretty=format:&#x27;%h %s&#x27; --graph                   # 图示提交日志</span><br><span class="line">git show HEAD~3</span><br><span class="line">git show -s --pretty=raw 2be7fcb476</span><br><span class="line">git stash                                                 # 暂存当前修改，将所有至为HEAD状态</span><br><span class="line">git stash list                                            # 查看所有暂存</span><br><span class="line">git stash show -p stash@&#123;0&#125;                               # 参考第一次暂存</span><br><span class="line">git stash apply stash@&#123;0&#125;                                 # 应用第一次暂存</span><br><span class="line">git grep &quot;delete from&quot;                                    # 文件中搜索文本“delete from”</span><br><span class="line">git grep -e &#x27;#define&#x27; --and -e SORT_DIRENT</span><br><span class="line">git gc</span><br><span class="line">git fsck</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git操作</tag>
      </tags>
  </entry>
  <entry>
    <title>deepin使用记录</title>
    <url>/2020/08/04/deepin%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h2 id="安装deepin与win10双系统"><a href="#安装deepin与win10双系统" class="headerlink" title="安装deepin与win10双系统"></a>安装deepin与win10双系统</h2><p>deepin安装需要在硬盘上分出500M的efi分区和一个根目录分区，制作安装u盘，安装完成后直接进入win10，这种情况是因为引导系统启动的是win10的efi分区文件，需要在bios界面修改引导启动的分区设置，将引导修改为deepin分区。</p>
<h2 id="deepin美化"><a href="#deepin美化" class="headerlink" title="deepin美化"></a>deepin美化</h2><h2 id="deepin显示器分辨率设置"><a href="#deepin显示器分辨率设置" class="headerlink" title="deepin显示器分辨率设置"></a>deepin显示器分辨率设置</h2><p>使用xrandr查看显示器参数</p>
<p><img src="/2020/08/04/deepin%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/picture1.png" alt="命令行截图"></p>
<p>可以看到，我使用的是DP-0接口，其中*标注的位置就是目前的分辨率和帧率，目前使用的显示参数为3440x1440分辨率，60的刷新率，我的显示器支持144刷新率，所以想使用144的刷新率。</p>
<p>我们可以使用xrandr来设置显示器的分辨率帧率及使用的接口：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo xrandr --output DP-0 --mode 3440x1440 --rate 144</span><br></pre></td></tr></table></figure>
<p>其中 —output 后面的参数为选择输出的接口，—mode 后面的参数为显示的分辨率，—rate 后面的参数为显示的刷新率。<br>但是在设置完144刷新率后发现屏幕有些发灰，于是又退回到了60</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>deepin</tag>
      </tags>
  </entry>
  <entry>
    <title>git将本地文件上传到github</title>
    <url>/2019/05/27/git%E5%B0%86%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%88%B0github/</url>
    <content><![CDATA[<h2 id="新建远程仓库"><a href="#新建远程仓库" class="headerlink" title="新建远程仓库"></a>新建远程仓库</h2><p><img src="/2019/05/27/git%E5%B0%86%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%88%B0github/Figure1.png" alt="Figure1"></p>
<h2 id="在本地创建文件夹"><a href="#在本地创建文件夹" class="headerlink" title="在本地创建文件夹"></a>在本地创建文件夹</h2><p>初始化本地的文件夹为一个Git可以管理的仓库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>
<h2 id="将本地的仓库和远程仓库关联"><a href="#将本地的仓库和远程仓库关联" class="headerlink" title="将本地的仓库和远程仓库关联"></a>将本地的仓库和远程仓库关联</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote add origin &lt;git仓库地址&gt;</span><br></pre></td></tr></table></figure>
<h2 id="将文件夹下文件添加到仓库"><a href="#将文件夹下文件添加到仓库" class="headerlink" title="将文件夹下文件添加到仓库"></a>将文件夹下文件添加到仓库</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure>
<p>可以在.gitignore中设置不上传的文件</p>
<h2 id="将文件提交到仓库"><a href="#将文件提交到仓库" class="headerlink" title="将文件提交到仓库"></a>将文件提交到仓库</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit -m &quot;2019/5/27&quot;</span><br></pre></td></tr></table></figure>
<h2 id="将本地库的内容推送到远程"><a href="#将本地库的内容推送到远程" class="headerlink" title="将本地库的内容推送到远程"></a>将本地库的内容推送到远程</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>
<ul>
<li><font face="微软雅黑">origin</font>:远程仓库名；<font face="微软雅黑">master</font>:分支</li>
<li>注意:我们第一次<font face="微软雅黑">push</font>的时候,加上<font face="微软雅黑">-u</font>参数,Git就会把本地的master分支和远程的master分支进行关联起来,我们以后的<font face="微软雅黑">push</font>操作就不再需要加上<font face="微软雅黑">-u</font>参数了</li>
</ul>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git操作</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/01/23/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.<br><a href="https://zhuanlan.zhihu.com/p/25729240">博客搭建参考</a><br><a href="http://theme-next.iissnan.com/getting-started.html#avatar-setting">next主题使用教程</a><br><a href="https://blog.csdn.net/Monkey_LZL/article/details/60870891">多终端同步教程</a><br><a href="https://www.jianshu.com/p/344cf061598d">主题美化</a><br><a href="https://monkey0105.github.io/2017/09/21/hexo-mathjax/">hexo中使用Mathjax</a><br><strong><a href="http://chogenfran.github.io/JamesHe.github.io/2016/05/01/%E5%82%BB%E7%93%9C%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B%EF%BC%88XX-NET%EF%BC%89/">科学上网</a></strong></p>
<h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><h3 id="创建一个新的文章"><a href="#创建一个新的文章" class="headerlink" title="创建一个新的文章"></a>创建一个新的文章</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="运行服务"><a href="#运行服务" class="headerlink" title="运行服务"></a>运行服务</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="部署到远程站点"><a href="#部署到远程站点" class="headerlink" title="部署到远程站点"></a>部署到远程站点</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>
<h3 id="发布文章"><a href="#发布文章" class="headerlink" title="发布文章"></a>发布文章</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo d --g</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p>
<h3 id="添加图片"><a href="#添加图片" class="headerlink" title="添加图片"></a>添加图片</h3><p>在目标的.comfig.yml文件的38行修改数据，可以在新建博客的同时新建一个资源文件夹来放置图片，博客引用时直接使用![picture](picture_name)  </p>
<h3 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h3><p>行内效果为<script type="math/tex">(a+b+c)^2</script><br>独自一行公式需要使公式独占一行<br>效果为</p>
<script type="math/tex; mode=display">(a+b+c)^2</script>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo博客记录</title>
    <url>/2019/07/15/hexo%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h2 id="hexo-next博客搭建攻略"><a href="#hexo-next博客搭建攻略" class="headerlink" title="hexo+next博客搭建攻略"></a><a href="https://io-oi.me/tech/hexo-next-optimization/#%E5%8A%A0%E9%80%9F-hexo-%E5%8D%9A%E5%AE%A2">hexo+next博客搭建攻略</a></h2><p><a href="http://lyxf.live/posts/2063/">博客优化</a></p>
<h2 id="多端更新hexo博客"><a href="#多端更新hexo博客" class="headerlink" title="多端更新hexo博客"></a><a href="https://blog.csdn.net/Monkey_LZL/article/details/60870891">多端更新hexo博客</a></h2><h2 id="更新next版本到7-7后"><a href="#更新next版本到7-7后" class="headerlink" title="更新next版本到7.7后"></a>更新next版本到7.7后</h2><p><a href="https://blog.csdn.net/Louis_li51/article/details/105227430">7.2版本后添加背景</a></p>
<p><a href="https://tding.top/docs/getting-started/data-files.html">借鉴博客</a></p>
<p>&emsp;&emsp;将原来的source/css/_custom/custom.styl文件的内容复制到themes/next/source/css/_common/components/pages/pages.styl文件中</p>
<p><a href="https://www.zhihu.com/question/21193762">换电脑更新博客</a></p>
<ul>
<li><p>从<a href="https://github.com/JiangChenrui/JiangChenrui.github.io/tree/hexo">github仓库</a>clone项目</p>
</li>
<li><p>本地安装nodejs</p>
</li>
<li><p>然后在项目地址下输入</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo  # 安装hexo</span><br><span class="line">npm install</span><br><span class="line">npm install hexo-deployer-git</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="vscode编写markdown"><a href="#vscode编写markdown" class="headerlink" title="vscode编写markdown"></a>vscode编写markdown</h2><ol>
<li><a href="https://juejin.im/post/5c45b92751882525487c5c66">插件推荐</a></li>
<li>Markdown All in One插件快捷键<br><img src="/2019/07/15/hexo%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95/快捷键.png" alt="快捷键"></li>
</ol>
<h2 id="hexo版本升级"><a href="#hexo版本升级" class="headerlink" title="hexo版本升级"></a>hexo版本升级</h2><ul>
<li><p>全局升级hexo-cli，先使用<code>hexo version</code>查看当前版本，然后<code>npm i hexo-cli -g</code>更新，再次使用<code>hexo version</code>查看更新是否成功。</p>
</li>
<li><p>使用<code>npm install -g npm-check</code>和<code>npm-check</code>，检查系统中的插件是否有升级的，可以看到自己前面都安装了那些插件。</p>
</li>
<li><p>使用<code>npm install -g npm-upgrade</code>和<code>npm-upgrade</code>，升级系统中的插件</p>
</li>
<li><p>使用npm update -g和npm update —save</p>
</li>
</ul>
<h2 id="npm更换国内源"><a href="#npm更换国内源" class="headerlink" title="npm更换国内源"></a>npm更换国内源</h2><p>在使用npm安装过程中发现下载很慢，网上查找问题后，可以使用更换国内源的方法解决。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm config set registry http://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>linux配置多cuda</title>
    <url>/2019/07/29/linux%E9%85%8D%E7%BD%AE%E5%A4%9Acuda/</url>
    <content><![CDATA[<p>&emsp;&emsp;最近实习工作需要多个环境的pytorch与cuda，目前所需为pytorch-0.4.1(cuda9.0/cudnn7.5.1/python3.6)与pytorch-0.4.1(cuda8.0/cudnn5.1/python2.7)，pytorch和python版本可以使用virtualenv控制，cuda版本需要安装多个版本cuda，然后生成要使用cuda版本的软链接，将软链接地址加入到环境变量中。</p>
<ul>
<li>删除原软链接</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo rm -rf /usr/local/cuda</span><br></pre></td></tr></table></figure>
<ul>
<li>建立新的软链接</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo ln -s /usr/local/cuda-8.0 /usr/lcoal/cuda</span><br></pre></td></tr></table></figure>
<p>可以在/usr/local目录下使用<code>stat cuda</code>查看cuda对应的软链接，也可以使用<code>nvcc -V</code>查看当前cuda版本</p>
<ul>
<li>修改环境变量</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo gedit ~/.bashrc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export PATH=/usr/local/cuda/bin:$PATH</span><br><span class="line">export LD_LIBRARY_PATH=/usr/local/cuda/lib64$LD_LIBRARY_PATH</span><br><span class="line">export CUDA_HOME=/usr/local/cuda</span><br></pre></td></tr></table></figure>
<p><code>/etc/profile</code>文件也需要修改</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo gedit /etc/profile</span><br><span class="line"></span><br><span class="line">export PATH=/usr/local/cuda/bin:$PATH</span><br><span class="line">export LD_LIBRARY_PATH=/usr/local/cuda/lib64$LD_LIBRARY_PATH</span><br><span class="line">export CUDA_HOME=/usr/local/cuda</span><br></pre></td></tr></table></figure>
<ul>
<li>使用命令查看当前cuda软链接地址</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls -l cuda</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux问题集锦</title>
    <url>/2019/07/16/linux%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A6/</url>
    <content><![CDATA[<h2 id="命令行更新vscode"><a href="#命令行更新vscode" class="headerlink" title="命令行更新vscode"></a>命令行更新vscode</h2><p>下载<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://vscode-update.azurewebsites.net/latest/linux-deb-x64/stable -O /tmp/code_latest_amd64.deb</span><br></pre></td></tr></table></figure><br>安装<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo dpkg -i /tmp/code_latest_amd64.deb</span><br></pre></td></tr></table></figure></p>
<h2 id="nohup使用"><a href="#nohup使用" class="headerlink" title="nohup使用"></a><a href="https://wsgzao.github.io/post/nohup/">nohup使用</a></h2><h3 id="nohup和-amp-的区别"><a href="#nohup和-amp-的区别" class="headerlink" title="nohup和&amp;的区别"></a>nohup和&amp;的区别</h3><ul>
<li>&amp;：是指在后台运行，当用户退出（挂起）的时候，命令会自动跟着结束</li>
<li>nohup：不挂断的运行，没有后台运行的功能，用nohup运行命令可以是命令永久执行下去</li>
</ul>
<h3 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a>输出重定向</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nohup command &gt; out.txt 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>
<p>将程序command的输出重定向到out.txt文件，即输出内容不打印到屏幕上，而是输出到out.txt文件中。<br>2&gt;&amp;1是将标准错误（2）重定向到标准输出（&amp;1），标准输出（&amp;1）再被重定向输入到out.file文件中。</p>
<h3 id="关闭nohup启动的程序"><a href="#关闭nohup启动的程序" class="headerlink" title="关闭nohup启动的程序"></a>关闭nohup启动的程序</h3><p>使用<code>jobs -l</code>查看当前nohup启动的程序，使用<code>kill</code>指令关闭</p>
<h2 id="linux资源查看工具top"><a href="#linux资源查看工具top" class="headerlink" title="linux资源查看工具top"></a>linux资源查看工具top</h2><p>在自动输入top后显示的信息如下<br><img src="/2019/07/16/linux%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A6/top.png" alt="Top"></p>
<p>同样可以使用htop来查看<br><img src="/2019/07/16/linux%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A6/htop.png" alt="htop"></p>
<h2 id="linux杀死僵尸进程"><a href="#linux杀死僵尸进程" class="headerlink" title="linux杀死僵尸进程"></a>linux杀死僵尸进程</h2><p>在终端输入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps -ef | grep defunct | more</span><br></pre></td></tr></table></figure>
<p>查看僵尸进程的详细信息，如图：<br><img src="/2019/07/16/linux%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A6/僵尸进程.png" alt="僵尸进程"><br>其中第二列为进程PID，第三列为父进程PID，对所有进程的父进程执行kill -9 进程号的操作来杀死僵尸进程</p>
<h2 id="将图片地址提取到txt"><a href="#将图片地址提取到txt" class="headerlink" title="将图片地址提取到txt"></a>将图片地址提取到txt</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls -R /data/*.jpg &gt; file.txt</span><br><span class="line">cat *.txt &gt; all.txt  // 将所有txt拼接</span><br></pre></td></tr></table></figure>
<h2 id="批量删除"><a href="#批量删除" class="headerlink" title="批量删除"></a>批量删除</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find . -name &quot;*.pyc&quot; | xargs rm -f</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>jupyter添加虚拟环境</title>
    <url>/2019/05/15/jupyter%E6%B7%BB%E5%8A%A0%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<p><a href="https://www.jianshu.com/p/0432155d1bef">参考地址</a><br><a href="https://blog.csdn.net/simple_the_best/article/details/77005400">服务器端jupyter开启远程访问</a>  </p>
<h2 id="virtualenv-jupyter-notebook"><a href="#virtualenv-jupyter-notebook" class="headerlink" title="virtualenv + jupyter notebook"></a>virtualenv + jupyter notebook</h2><p>&emsp;&emsp;为了方便远程使用服务器，在服务器端打开了远程访问，之后需要将服务器中创建的虚拟环境添加到jupyter中。</p>
<ul>
<li><p>1.进入虚拟环境  </p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source pytorch3/bin/activate</span><br></pre></td></tr></table></figure>
</li>
<li><p>2.安装IPykernel</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt; python2 &gt;</span><br><span class="line">pip install ipykernel</span><br><span class="line">&lt; python3 &gt;</span><br><span class="line">pip3 install ipykernel</span><br></pre></td></tr></table></figure>
</li>
<li><p>3.将 Virtualenv 加入IPykernel</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt; python2 &gt;</span><br><span class="line">python2 -m ipykernel install --user --name=myproject</span><br><span class="line">&lt; python3 &gt;</span><br><span class="line">python3 -m ipykernel install --user --name=myproject</span><br></pre></td></tr></table></figure>
</li>
<li><p>4.启动jupyter notebook并更改kernel</p>
</li>
</ul>
]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>远程桌面</tag>
        <tag>jupyter</tag>
      </tags>
  </entry>
  <entry>
    <title>numpy.random函数的一些用法</title>
    <url>/2019/01/23/numpy-random%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/u012149181/article/details/78913167">参考博客</a></p>
<h2 id="numpy-random-rand"><a href="#numpy-random-rand" class="headerlink" title="numpy.random.rand()"></a>numpy.random.rand()</h2><p>numpy.random.rand(d0, d1, …, dn)  </p>
<ul>
<li><p>rand函数根据给定维度生成[0,1)之间的数据，包含0，不包含1  </p>
</li>
<li><p>dn表示每个维度  </p>
</li>
<li><p>返回值为指定维度的array</p>
</li>
</ul>
<p>输入  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.random.rand(<span class="number">4</span>, <span class="number">2</span>) <span class="comment"># 生成4行两列0-1之间的随机数</span></span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">array([[ <span class="number">0.2639652</span> ,  <span class="number">0.67762924</span>],</span><br><span class="line">       [ <span class="number">0.50164586</span>,  <span class="number">0.73739781</span>],</span><br><span class="line">       [ <span class="number">0.18457953</span>,  <span class="number">0.85558988</span>],</span><br><span class="line">       [ <span class="number">0.16193526</span>,  <span class="number">0.83935579</span>]])</span><br></pre></td></tr></table></figure>
<p>输入</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.random.rand(<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>) <span class="comment"># shape为[4, 3, 2]</span></span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">array([[[ <span class="number">0.49636822</span>,  <span class="number">0.89954378</span>],</span><br><span class="line">        [ <span class="number">0.5711387</span> ,  <span class="number">0.41691163</span>],</span><br><span class="line">        [ <span class="number">0.05681485</span>,  <span class="number">0.88512829</span>]],</span><br><span class="line"></span><br><span class="line">       [[ <span class="number">0.88798283</span>,  <span class="number">0.96294557</span>],</span><br><span class="line">        [ <span class="number">0.91100035</span>,  <span class="number">0.28982022</span>],</span><br><span class="line">        [ <span class="number">0.90098484</span>,  <span class="number">0.85539872</span>]],</span><br><span class="line"></span><br><span class="line">       [[ <span class="number">0.99124126</span>,  <span class="number">0.87069271</span>],</span><br><span class="line">        [ <span class="number">0.82365864</span>,  <span class="number">0.33025856</span>],</span><br><span class="line">        [ <span class="number">0.8874623</span> ,  <span class="number">0.22067393</span>]],</span><br><span class="line"></span><br><span class="line">       [[ <span class="number">0.62666929</span>,  <span class="number">0.71956291</span>],</span><br><span class="line">        [ <span class="number">0.81974729</span>,  <span class="number">0.46510244</span>],</span><br><span class="line">        [ <span class="number">0.03494486</span>,  <span class="number">0.11045034</span>]]])</span><br></pre></td></tr></table></figure>
<h3 id="numpy-random-randn"><a href="#numpy-random-randn" class="headerlink" title="numpy.random.randn()"></a>numpy.random.randn()</h3><p>numpy.random.randn(d0,d1,…,dn)  </p>
<ul>
<li><p>randn函数返回一个或一组样本，具有标准正态分布.  </p>
</li>
<li><p>dn表示每个维度  </p>
</li>
<li><p>返回值为指定维度的array  </p>
</li>
</ul>
<p>标准正态分布是以0为均值，1为标准差的正态分布，记为N(0, 1)。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.random.randn(<span class="number">4</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">-<span class="number">0.599153380810341</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.random.randn(<span class="number">4</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">array([[-<span class="number">0.83173279</span>, -<span class="number">0.06084999</span>],</span><br><span class="line">       [ <span class="number">0.30143042</span>, -<span class="number">0.63863605</span>],</span><br><span class="line">       [-<span class="number">0.45491282</span>,  <span class="number">0.72084355</span>],</span><br><span class="line">       [-<span class="number">0.86603523</span>,  <span class="number">1.14210338</span>]])</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.random.randn(<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">array([[[ <span class="number">0.62674807</span>, -<span class="number">0.40911062</span>],</span><br><span class="line">        [-<span class="number">0.65785551</span>,  <span class="number">0.85653665</span>],</span><br><span class="line">        [-<span class="number">0.55250578</span>,  <span class="number">1.15478597</span>]],</span><br><span class="line"></span><br><span class="line">       [[-<span class="number">1.39797824</span>,  <span class="number">1.36343765</span>],</span><br><span class="line">        [-<span class="number">0.35807181</span>,  <span class="number">2.08002524</span>],</span><br><span class="line">        [-<span class="number">0.16746821</span>,  <span class="number">1.89978231</span>]],</span><br><span class="line"></span><br><span class="line">       [[-<span class="number">0.89490747</span>, -<span class="number">0.49563846</span>],</span><br><span class="line">        [ <span class="number">0.36720155</span>, -<span class="number">0.30631295</span>],</span><br><span class="line">        [ <span class="number">0.43208381</span>,  <span class="number">1.04328295</span>]],</span><br><span class="line"></span><br><span class="line">       [[-<span class="number">0.65629808</span>,  <span class="number">0.501748</span>  ],</span><br><span class="line">        [ <span class="number">0.30889304</span>, -<span class="number">0.52872014</span>],</span><br><span class="line">        [ <span class="number">0.04584062</span>, -<span class="number">0.05242994</span>]]])</span><br></pre></td></tr></table></figure>
<h2 id="numpy-random-randint"><a href="#numpy-random-randint" class="headerlink" title="numpy.random.randint()"></a>numpy.random.randint()</h2><p>numpy.random.randint(low, high=None, size=None, dtype=’l’)</p>
<ul>
<li><p>返回随机整数，范围区间为[low,high），包含low，不包含high  </p>
</li>
<li><p>参数：low为最小值，high为最大值，size为数组维度大小，dtype为数据类型，默认的数据类型是np.int  </p>
</li>
<li><p>high没有填写时，默认生成随机数的范围是[0，low)  </p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.random.randint(<span class="number">1</span>, size=<span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">array([<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.random.randint(<span class="number">1</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.random.randint(-<span class="number">5</span>, <span class="number">5</span>, size=[<span class="number">2</span>,<span class="number">2</span>])</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">array([[ <span class="number">1</span>,  <span class="number">0</span>],</span><br><span class="line">       [-<span class="number">3</span>,  <span class="number">2</span>]])</span><br></pre></td></tr></table></figure>
<h3 id="numpy-random-random-integers"><a href="#numpy-random-random-integers" class="headerlink" title="numpy.random.random_integers"></a>numpy.random.random_integers</h3><p>numpy.random.random_integers(low, high=None, size=None)</p>
<ul>
<li><p>返回随机整数，范围区间为[low,high]，包含low和high  </p>
</li>
<li><p>参数：low为最小值，high为最大值，size为数组维度大小  </p>
</li>
<li><p>high没有填写时，默认生成随机数的范围是[1，low]  </p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.random.random_integers(<span class="number">5</span>, size=<span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">array([<span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<h2 id="生成-0-1-之间的浮点数"><a href="#生成-0-1-之间的浮点数" class="headerlink" title="生成[0,1)之间的浮点数"></a>生成[0,1)之间的浮点数</h2><ul>
<li><p>numpy.random.random_sample(size=None)  </p>
</li>
<li><p>numpy.random.random(size=None)  </p>
</li>
<li><p>numpy.random.ranf(size=None)  </p>
</li>
<li><p>numpy.random.sample(size=None)  </p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;-----------random_sample--------------&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.random.random_sample(size=(<span class="number">2</span>,<span class="number">2</span>)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;-----------random--------------&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.random.random(size=(<span class="number">2</span>,<span class="number">2</span>)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;-----------ranf--------------&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.random.ranf(size=(<span class="number">2</span>,<span class="number">2</span>)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;-----------sample--------------&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.random.sample(size=(<span class="number">2</span>,<span class="number">2</span>)))</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">-----------random_sample--------------</span><br><span class="line">[[ <span class="number">0.19678647</span>  <span class="number">0.64750281</span>]</span><br><span class="line"> [ <span class="number">0.70380805</span>  <span class="number">0.18626702</span>]]</span><br><span class="line">-----------random--------------</span><br><span class="line">[[ <span class="number">0.05688147</span>  <span class="number">0.57224742</span>]</span><br><span class="line"> [ <span class="number">0.5821726</span>   <span class="number">0.8344959</span> ]]</span><br><span class="line">-----------ranf--------------</span><br><span class="line">[[ <span class="number">0.57307708</span>  <span class="number">0.08199258</span>]</span><br><span class="line"> [ <span class="number">0.50676558</span>  <span class="number">0.79959829</span>]]</span><br><span class="line">-----------sample--------------</span><br><span class="line">[[  <span class="number">2.25676224e-04</span>   <span class="number">8.76885950e-01</span>]</span><br><span class="line"> [  <span class="number">7.52204914e-01</span>   <span class="number">6.43694560e-01</span>]]</span><br></pre></td></tr></table></figure>
<h2 id="numpy-random-choice"><a href="#numpy-random-choice" class="headerlink" title="numpy.random.choice()"></a>numpy.random.choice()</h2><p>numpy.random.choice(a, size=None, replace=True, p=None)  </p>
<ul>
<li><p>从给定的一维数组中生成随机数  </p>
</li>
<li><p>参数： a为一维数组类似数据或整数；size为数组维度；p为数组中的数据出现的概率  </p>
</li>
<li><p>a为整数时，对应的一维数组为np.arange(a)  </p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.random.choice(<span class="number">5</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">array([<span class="number">4</span>, <span class="number">4</span>, <span class="number">2</span>])</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">np.random.choice(<span class="number">5</span>, <span class="number">3</span>, replace=<span class="literal">False</span>)</span><br><span class="line"><span class="comment"># replace为False时，生成的数不能有重复的</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">array([<span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.random.choice(<span class="number">4</span>, <span class="number">4</span>, replace=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">array([<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.random.choice(<span class="number">4</span>, size=(<span class="number">3</span>, <span class="number">2</span>))</span><br><span class="line">array([[<span class="number">2</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">1</span>]])</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">demo_list = [<span class="string">&#x27;lenovo&#x27;</span>, <span class="string">&#x27;sansumg&#x27;</span>,<span class="string">&#x27;moto&#x27;</span>,<span class="string">&#x27;xiaomi&#x27;</span>, <span class="string">&#x27;iphone&#x27;</span>]</span><br><span class="line">np.random.choice(demo_list,size=(<span class="number">3</span>,<span class="number">3</span>))</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">array([[<span class="string">&#x27;lenovo&#x27;</span>, <span class="string">&#x27;sansumg&#x27;</span>, <span class="string">&#x27;lenovo&#x27;</span>],</span><br><span class="line">       [<span class="string">&#x27;moto&#x27;</span>, <span class="string">&#x27;sansumg&#x27;</span>, <span class="string">&#x27;sansumg&#x27;</span>],</span><br><span class="line">       [<span class="string">&#x27;sansumg&#x27;</span>, <span class="string">&#x27;iphone&#x27;</span>, <span class="string">&#x27;moto&#x27;</span>]],</span><br><span class="line">      dtype=<span class="string">&#x27;&lt;U7&#x27;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># p是指定每个元素的概率，概率和应为1，且数据个数与a应该相同</span></span><br><span class="line">demo_list = [<span class="string">&#x27;lenovo&#x27;</span>, <span class="string">&#x27;sansumg&#x27;</span>,<span class="string">&#x27;moto&#x27;</span>,<span class="string">&#x27;xiaomi&#x27;</span>, <span class="string">&#x27;iphone&#x27;</span>]</span><br><span class="line">np.random.choice(demo_list,size=(<span class="number">3</span>,<span class="number">3</span>), p=[<span class="number">0.1</span>,<span class="number">0.6</span>,<span class="number">0.1</span>,<span class="number">0.1</span>,<span class="number">0.1</span>])</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">array([[<span class="string">&#x27;sansumg&#x27;</span>, <span class="string">&#x27;sansumg&#x27;</span>, <span class="string">&#x27;iphone&#x27;</span>],</span><br><span class="line">       [<span class="string">&#x27;sansumg&#x27;</span>, <span class="string">&#x27;sansumg&#x27;</span>, <span class="string">&#x27;xiaomi&#x27;</span>],</span><br><span class="line">       [<span class="string">&#x27;sansumg&#x27;</span>, <span class="string">&#x27;sansumg&#x27;</span>, <span class="string">&#x27;sansumg&#x27;</span>]],</span><br><span class="line">      dtype=<span class="string">&#x27;&lt;U7&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="numpy-random-seed"><a href="#numpy-random-seed" class="headerlink" title="numpy.random.seed()"></a>numpy.random.seed()</h2><ul>
<li><p>np.random.seed()的作用：使得随机数据可预测。  </p>
</li>
<li><p>当我们设置相同的seed，每次生成的随机数相同。如果不设置seed，则每次会生成不同的随机数  </p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    np.random.seed(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(np.random.rand(<span class="number">5</span>))</span><br><span class="line">    <span class="built_in">print</span>(np.random.rand(<span class="number">5</span>))</span><br><span class="line">    <span class="built_in">print</span>(np.random.rand(<span class="number">5</span>))</span><br><span class="line">    <span class="built_in">print</span>(np.random.rand(<span class="number">5</span>))</span><br><span class="line">    <span class="built_in">print</span>()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[ <span class="number">0.4359949</span>   <span class="number">0.02592623</span>  <span class="number">0.54966248</span>  <span class="number">0.43532239</span>  <span class="number">0.4203678</span> ]</span><br><span class="line">[ <span class="number">0.33033482</span>  <span class="number">0.20464863</span>  <span class="number">0.61927097</span>  <span class="number">0.29965467</span>  <span class="number">0.26682728</span>]</span><br><span class="line">[ <span class="number">0.62113383</span>  <span class="number">0.52914209</span>  <span class="number">0.13457995</span>  <span class="number">0.51357812</span>  <span class="number">0.18443987</span>]</span><br><span class="line">[ <span class="number">0.78533515</span>  <span class="number">0.85397529</span>  <span class="number">0.49423684</span>  <span class="number">0.84656149</span>  <span class="number">0.07964548</span>]</span><br><span class="line"></span><br><span class="line">[ <span class="number">0.4359949</span>   <span class="number">0.02592623</span>  <span class="number">0.54966248</span>  <span class="number">0.43532239</span>  <span class="number">0.4203678</span> ]</span><br><span class="line">[ <span class="number">0.33033482</span>  <span class="number">0.20464863</span>  <span class="number">0.61927097</span>  <span class="number">0.29965467</span>  <span class="number">0.26682728</span>]</span><br><span class="line">[ <span class="number">0.62113383</span>  <span class="number">0.52914209</span>  <span class="number">0.13457995</span>  <span class="number">0.51357812</span>  <span class="number">0.18443987</span>]</span><br><span class="line">[ <span class="number">0.78533515</span>  <span class="number">0.85397529</span>  <span class="number">0.49423684</span>  <span class="number">0.84656149</span>  <span class="number">0.07964548</span>]</span><br><span class="line"></span><br><span class="line">[ <span class="number">0.4359949</span>   <span class="number">0.02592623</span>  <span class="number">0.54966248</span>  <span class="number">0.43532239</span>  <span class="number">0.4203678</span> ]</span><br><span class="line">[ <span class="number">0.33033482</span>  <span class="number">0.20464863</span>  <span class="number">0.61927097</span>  <span class="number">0.29965467</span>  <span class="number">0.26682728</span>]</span><br><span class="line">[ <span class="number">0.62113383</span>  <span class="number">0.52914209</span>  <span class="number">0.13457995</span>  <span class="number">0.51357812</span>  <span class="number">0.18443987</span>]</span><br><span class="line">[ <span class="number">0.78533515</span>  <span class="number">0.85397529</span>  <span class="number">0.49423684</span>  <span class="number">0.84656149</span>  <span class="number">0.07964548</span>]</span><br><span class="line"></span><br><span class="line">[ <span class="number">0.4359949</span>   <span class="number">0.02592623</span>  <span class="number">0.54966248</span>  <span class="number">0.43532239</span>  <span class="number">0.4203678</span> ]</span><br><span class="line">[ <span class="number">0.33033482</span>  <span class="number">0.20464863</span>  <span class="number">0.61927097</span>  <span class="number">0.29965467</span>  <span class="number">0.26682728</span>]</span><br><span class="line">[ <span class="number">0.62113383</span>  <span class="number">0.52914209</span>  <span class="number">0.13457995</span>  <span class="number">0.51357812</span>  <span class="number">0.18443987</span>]</span><br><span class="line">[ <span class="number">0.78533515</span>  <span class="number">0.85397529</span>  <span class="number">0.49423684</span>  <span class="number">0.84656149</span>  <span class="number">0.07964548</span>]</span><br><span class="line"></span><br><span class="line">[ <span class="number">0.4359949</span>   <span class="number">0.02592623</span>  <span class="number">0.54966248</span>  <span class="number">0.43532239</span>  <span class="number">0.4203678</span> ]</span><br><span class="line">[ <span class="number">0.33033482</span>  <span class="number">0.20464863</span>  <span class="number">0.61927097</span>  <span class="number">0.29965467</span>  <span class="number">0.26682728</span>]</span><br><span class="line">[ <span class="number">0.62113383</span>  <span class="number">0.52914209</span>  <span class="number">0.13457995</span>  <span class="number">0.51357812</span>  <span class="number">0.18443987</span>]</span><br><span class="line">[ <span class="number">0.78533515</span>  <span class="number">0.85397529</span>  <span class="number">0.49423684</span>  <span class="number">0.84656149</span>  <span class="number">0.07964548</span>]</span><br><span class="line"></span><br><span class="line">[ <span class="number">0.4359949</span>   <span class="number">0.02592623</span>  <span class="number">0.54966248</span>  <span class="number">0.43532239</span>  <span class="number">0.4203678</span> ]</span><br><span class="line">[ <span class="number">0.33033482</span>  <span class="number">0.20464863</span>  <span class="number">0.61927097</span>  <span class="number">0.29965467</span>  <span class="number">0.26682728</span>]</span><br><span class="line">[ <span class="number">0.62113383</span>  <span class="number">0.52914209</span>  <span class="number">0.13457995</span>  <span class="number">0.51357812</span>  <span class="number">0.18443987</span>]</span><br><span class="line">[ <span class="number">0.78533515</span>  <span class="number">0.85397529</span>  <span class="number">0.49423684</span>  <span class="number">0.84656149</span>  <span class="number">0.07964548</span>]</span><br><span class="line"></span><br><span class="line">[ <span class="number">0.4359949</span>   <span class="number">0.02592623</span>  <span class="number">0.54966248</span>  <span class="number">0.43532239</span>  <span class="number">0.4203678</span> ]</span><br><span class="line">[ <span class="number">0.33033482</span>  <span class="number">0.20464863</span>  <span class="number">0.61927097</span>  <span class="number">0.29965467</span>  <span class="number">0.26682728</span>]</span><br><span class="line">[ <span class="number">0.62113383</span>  <span class="number">0.52914209</span>  <span class="number">0.13457995</span>  <span class="number">0.51357812</span>  <span class="number">0.18443987</span>]</span><br><span class="line">[ <span class="number">0.78533515</span>  <span class="number">0.85397529</span>  <span class="number">0.49423684</span>  <span class="number">0.84656149</span>  <span class="number">0.07964548</span>]</span><br><span class="line"></span><br><span class="line">[ <span class="number">0.4359949</span>   <span class="number">0.02592623</span>  <span class="number">0.54966248</span>  <span class="number">0.43532239</span>  <span class="number">0.4203678</span> ]</span><br><span class="line">[ <span class="number">0.33033482</span>  <span class="number">0.20464863</span>  <span class="number">0.61927097</span>  <span class="number">0.29965467</span>  <span class="number">0.26682728</span>]</span><br><span class="line">[ <span class="number">0.62113383</span>  <span class="number">0.52914209</span>  <span class="number">0.13457995</span>  <span class="number">0.51357812</span>  <span class="number">0.18443987</span>]</span><br><span class="line">[ <span class="number">0.78533515</span>  <span class="number">0.85397529</span>  <span class="number">0.49423684</span>  <span class="number">0.84656149</span>  <span class="number">0.07964548</span>]</span><br><span class="line"></span><br><span class="line">[ <span class="number">0.4359949</span>   <span class="number">0.02592623</span>  <span class="number">0.54966248</span>  <span class="number">0.43532239</span>  <span class="number">0.4203678</span> ]</span><br><span class="line">[ <span class="number">0.33033482</span>  <span class="number">0.20464863</span>  <span class="number">0.61927097</span>  <span class="number">0.29965467</span>  <span class="number">0.26682728</span>]</span><br><span class="line">[ <span class="number">0.62113383</span>  <span class="number">0.52914209</span>  <span class="number">0.13457995</span>  <span class="number">0.51357812</span>  <span class="number">0.18443987</span>]</span><br><span class="line">[ <span class="number">0.78533515</span>  <span class="number">0.85397529</span>  <span class="number">0.49423684</span>  <span class="number">0.84656149</span>  <span class="number">0.07964548</span>]</span><br><span class="line"></span><br><span class="line">[ <span class="number">0.4359949</span>   <span class="number">0.02592623</span>  <span class="number">0.54966248</span>  <span class="number">0.43532239</span>  <span class="number">0.4203678</span> ]</span><br><span class="line">[ <span class="number">0.33033482</span>  <span class="number">0.20464863</span>  <span class="number">0.61927097</span>  <span class="number">0.29965467</span>  <span class="number">0.26682728</span>]</span><br><span class="line">[ <span class="number">0.62113383</span>  <span class="number">0.52914209</span>  <span class="number">0.13457995</span>  <span class="number">0.51357812</span>  <span class="number">0.18443987</span>]</span><br><span class="line">[ <span class="number">0.78533515</span>  <span class="number">0.85397529</span>  <span class="number">0.49423684</span>  <span class="number">0.84656149</span>  <span class="number">0.07964548</span>]</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>numpy</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>pip安装包以后jupyter不能导入的解决办法</title>
    <url>/2019/08/03/pip%E5%AE%89%E8%A3%85%E5%8C%85%E4%BB%A5%E5%90%8Ejupyter%E4%B8%8D%E8%83%BD%E5%AF%BC%E5%85%A5%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    <content><![CDATA[<p>&emsp;&emsp;最近使用jupyter发现在虚拟环境下安装了包，但是在该环境下启动的jupyter却不能正确导入包，问题应该出在jupyter调用的python包和环境下的包不一样导致的，以下是解决方法，<a href="https://blog.csdn.net/qq_34650787/article/details/83304080">参考博客</a></p>
<ul>
<li><p><strong>首先激活要用的虚拟环境，查看python路径</strong></p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.executable</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;/home/boyunvision/pytorch3.6/bin/python&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>然后在jupyter下进行同样操作</strong></p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.executable</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;/usr/bin/python&#x27;</span></span><br></pre></td></tr></table></figure>
<p>  可以看到两者的路径不一样  </p>
</li>
<li><p><strong>然后找到jupyter定义python路径的文件</strong></p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ipython kernelspec list</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="/2019/08/03/pip%E5%AE%89%E8%A3%85%E5%8C%85%E4%BB%A5%E5%90%8Ejupyter%E4%B8%8D%E8%83%BD%E5%AF%BC%E5%85%A5%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/picture1.png" alt="picture1"></p>
<ul>
<li><p><strong>在该目录下打开kernel.json文件，将python修改为虚拟环境路径</strong></p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;argv&quot;</span>: [</span><br><span class="line"><span class="string">&quot;/usr/bin/python&quot;</span>, % 修改为<span class="string">&quot;/home/boyunvision/pytorch/bin/python3&quot;</span></span><br><span class="line"><span class="string">&quot;-m&quot;</span>,</span><br><span class="line"><span class="string">&quot;ipykernel_launcher&quot;</span>,</span><br><span class="line"><span class="string">&quot;-f&quot;</span>,</span><br><span class="line"><span class="string">&quot;&#123;connection_file&#125;&quot;</span></span><br><span class="line">],</span><br><span class="line"><span class="string">&quot;display_name&quot;</span>: <span class="string">&quot;Python 3&quot;</span>,</span><br><span class="line"><span class="string">&quot;language&quot;</span>: <span class="string">&quot;python&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>jupyter</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>pytorch数据增广</title>
    <url>/2019/09/06/pytorch%E6%95%B0%E6%8D%AE%E5%A2%9E%E5%B9%BF/</url>
    <content><![CDATA[<p><strong>常用的数据增广方法</strong></p>
<pre><code>1. 对图片进行按比例缩放
2. 对图片进行随机位置的截取
3. 对图片进行随机的水平和竖直翻转
4. 对图片进行随机角度的旋转
5. 对图片进行亮度、对比度和颜色的随机变化
</code></pre><p>下面使用torchvision演示一下这些数据增强方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 载入图片</span></span><br><span class="line">img = Image.<span class="built_in">open</span>(<span class="string">&#x27;img.jpg&#x27;</span>)</span><br><span class="line">img</span><br></pre></td></tr></table></figure>
<p><img src="/2019/09/06/pytorch%E6%95%B0%E6%8D%AE%E5%A2%9E%E5%B9%BF/output_2_0.png" alt="png"></p>
<h2 id="随机比例缩放"><a href="#随机比例缩放" class="headerlink" title="随机比例缩放"></a>随机比例缩放</h2><p>&emsp;&emsp;随机比例缩放使用的是<code>torchvision.transforms.Resize()</code>函数，函数有两个参数，第一个参数为缩放大小，如果为一个值则会按比例缩放，否则按传入的值缩放；第二个参数表示缩放图片使用的方法，默认的是双线性差值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 比例缩放</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;缩放前尺寸为:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(img.size))</span><br><span class="line">new_img = transforms.Resize(<span class="number">224</span>)(img)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;缩放后尺寸为:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(new_img.size))</span><br><span class="line">new_img</span><br><span class="line"></span><br><span class="line">    缩放前尺寸为:(<span class="number">134</span>, <span class="number">43</span>)</span><br><span class="line">    缩放后尺寸为:(<span class="number">698</span>, <span class="number">224</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/2019/09/06/pytorch%E6%95%B0%E6%8D%AE%E5%A2%9E%E5%B9%BF/output_4_1.png" alt="png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">new_img = transforms.RandomCrop(<span class="number">224</span>, padding=<span class="number">8</span>)(new_img)</span><br><span class="line">new_img</span><br></pre></td></tr></table></figure>
<p><img src="/2019/09/06/pytorch%E6%95%B0%E6%8D%AE%E5%A2%9E%E5%B9%BF/output_5_0.png" alt="png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">new_img = transforms.Resize((<span class="number">224</span>, <span class="number">224</span>))(img)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;缩放后尺寸为:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(new_img.size))</span><br><span class="line">new_img</span><br><span class="line"></span><br><span class="line">    缩放后尺寸为:(<span class="number">224</span>, <span class="number">224</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/2019/09/06/pytorch%E6%95%B0%E6%8D%AE%E5%A2%9E%E5%B9%BF/output_6_1.png" alt="png"></p>
<h2 id="随机位置截取"><a href="#随机位置截取" class="headerlink" title="随机位置截取"></a>随机位置截取</h2><p>&emsp;&emsp;随机位置截取能够提取图片中的局部信息，使得网络接受的输入具有多尺度的特征，所以能够有较好的效果，在torchvision中主要有以下两种方式，一个是<code>torchvision.transforms.RandomCrop()</code>，传入的参数是截取出图片的长和宽，在图片的随机位置进行截取；第二个是<code>torchvision.transforms.CenterCrop()</code>，同样传入图片的长和宽，会在图片的中心进行截取。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 随机位置截取 100x100 的区域</span></span><br><span class="line">random_img = transforms.RandomCrop(<span class="number">100</span>)(new_img)</span><br><span class="line">random_img</span><br></pre></td></tr></table></figure>
<p><img src="/2019/09/06/pytorch%E6%95%B0%E6%8D%AE%E5%A2%9E%E5%B9%BF/output_8_0.png" alt="png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 中心裁剪出 100x100 的区域</span></span><br><span class="line">center_img = transforms.CenterCrop(<span class="number">100</span>)(new_img)</span><br><span class="line">center_img</span><br></pre></td></tr></table></figure>
<p><img src="/2019/09/06/pytorch%E6%95%B0%E6%8D%AE%E5%A2%9E%E5%B9%BF/output_9_0.png" alt="png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进行填充后随机裁剪</span></span><br><span class="line">random_img2 = transforms.RandomCrop(<span class="number">224</span>, padding=<span class="number">8</span>)(new_img)</span><br><span class="line">random_img2</span><br></pre></td></tr></table></figure>
<p><img src="/2019/09/06/pytorch%E6%95%B0%E6%8D%AE%E5%A2%9E%E5%B9%BF/output_10_0.png" alt="png"></p>
<h2 id="随机水平翻转和竖直翻转"><a href="#随机水平翻转和竖直翻转" class="headerlink" title="随机水平翻转和竖直翻转"></a>随机水平翻转和竖直翻转</h2><p><code>torchvision.transforms.RandomHorizontalFlip()</code>和<code>torchvision.transforms.RandomVerticalFlip()</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 随机水平翻转</span></span><br><span class="line">h_flip = transforms.RandomHorizontalFlip()(new_img)</span><br><span class="line">h_flip</span><br></pre></td></tr></table></figure>
<p><img src="/2019/09/06/pytorch%E6%95%B0%E6%8D%AE%E5%A2%9E%E5%B9%BF/output_12_0.png" alt="png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 随机竖直翻转</span></span><br><span class="line">v_flip = transforms.RandomVerticalFlip()(new_img)</span><br><span class="line">v_flip</span><br></pre></td></tr></table></figure>
<p><img src="/2019/09/06/pytorch%E6%95%B0%E6%8D%AE%E5%A2%9E%E5%B9%BF/output_13_0.png" alt="png"></p>
<h2 id="随机角度旋转"><a href="#随机角度旋转" class="headerlink" title="随机角度旋转"></a>随机角度旋转</h2><p><code>torchvision.transforms.RandomRotation()</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rot_im = transforms.RandomRotation(<span class="number">30</span>)(new_img)</span><br><span class="line">rot_im</span><br></pre></td></tr></table></figure>
<p><img src="/2019/09/06/pytorch%E6%95%B0%E6%8D%AE%E5%A2%9E%E5%B9%BF/output_15_0.png" alt="png"></p>
<h2 id="亮度、对比度和颜色变化"><a href="#亮度、对比度和颜色变化" class="headerlink" title="亮度、对比度和颜色变化"></a>亮度、对比度和颜色变化</h2><p><code>torchvision.transforms.ColorJitter()</code>函数有四个参数，第一个参数为亮度，第二个参数为对比度，第三个参数为饱和度，第四个参数为颜色</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 亮度</span></span><br><span class="line">bright_img = transforms.ColorJitter(brightness=<span class="number">1</span>)(new_img)</span><br><span class="line">bright_img</span><br></pre></td></tr></table></figure>
<p><img src="/2019/09/06/pytorch%E6%95%B0%E6%8D%AE%E5%A2%9E%E5%B9%BF/output_17_0.png" alt="png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 对比度</span></span><br><span class="line">contrast_img = transforms.ColorJitter(contrast=<span class="number">1</span>)(new_img)</span><br><span class="line">contrast_img</span><br></pre></td></tr></table></figure>
<p><img src="/2019/09/06/pytorch%E6%95%B0%E6%8D%AE%E5%A2%9E%E5%B9%BF/output_18_0.png" alt="png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 饱和度</span></span><br><span class="line">saturation_img = transforms.ColorJitter(saturation=<span class="number">1</span>)(new_img)</span><br><span class="line">saturation_img</span><br></pre></td></tr></table></figure>
<p><img src="/2019/09/06/pytorch%E6%95%B0%E6%8D%AE%E5%A2%9E%E5%B9%BF/output_19_0.png" alt="png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 颜色 随机变换颜色</span></span><br><span class="line">color_img = transforms.ColorJitter(hue=<span class="number">0.5</span>)(new_img)</span><br><span class="line">color_img</span><br></pre></td></tr></table></figure>
<p><img src="/2019/09/06/pytorch%E6%95%B0%E6%8D%AE%E5%A2%9E%E5%B9%BF/output_20_0.png" alt="png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">compose_img = transforms.ColorJitter(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>)(new_img)</span><br><span class="line">compose_img</span><br><span class="line">new_img</span><br></pre></td></tr></table></figure>
<p><img src="/2019/09/06/pytorch%E6%95%B0%E6%8D%AE%E5%A2%9E%E5%B9%BF/output_21_0.png" alt="png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line">img_transform = transforms.Compose([</span><br><span class="line">    transforms.Resize(<span class="number">232</span>),</span><br><span class="line">    transforms.RandomCrop(<span class="number">224</span>),</span><br><span class="line">    transforms.ColorJitter(<span class="number">0.15</span>, <span class="number">0.15</span>, <span class="number">0.15</span>)</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">nrows = <span class="number">5</span></span><br><span class="line">ncols = <span class="number">5</span></span><br><span class="line">figsize = (<span class="number">10</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">_, figs = plt.subplots(nrows, ncols, figsize = figsize)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(nrows):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(ncols):</span><br><span class="line">        figs[i][j].imshow(img_transform(new_img))</span><br><span class="line">        figs[i][j].axes.get_xaxis().set_visible(<span class="literal">False</span>)</span><br><span class="line">        figs[i][j].axes.get_yaxis().set_visible(<span class="literal">False</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2019/09/06/pytorch%E6%95%B0%E6%8D%AE%E5%A2%9E%E5%B9%BF/output_22_0.png" alt="png"></p>
]]></content>
      <categories>
        <category>pytorch</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>pytorch模型保存与加载</title>
    <url>/2019/07/23/pytorch%E6%A8%A1%E5%9E%8B%E4%BF%9D%E5%AD%98%E4%B8%8E%E5%8A%A0%E8%BD%BD/</url>
    <content><![CDATA[<p><a href="https://pytorch.apachecn.org/docs/1.0/saving_loading_models.html">官方文档</a></p>
<h2 id="模型保存相关的三个核心功能"><a href="#模型保存相关的三个核心功能" class="headerlink" title="模型保存相关的三个核心功能"></a>模型保存相关的三个核心功能</h2><p><strong>torch.save:</strong> 将序列化对象保存到磁盘。此函数使用Python的pickle模块进行序列化，使用此模型可以保存如模型、tensor、字典等各种对象。<br><strong>torch.load:</strong> 使用pickle的unpicking功能将pickle对象文件反序列化到内存。此功能还可以有助于设备加载数据。<br><strong>torch.nn.Moudle.load_state_dict:</strong> 使用反序列化函数<em>state_dict</em>来加载模型的参数字典。  </p>
<h2 id="状态字典"><a href="#状态字典" class="headerlink" title="状态字典"></a>状态字典</h2><p>&emsp;&emsp;在pytorch中，<code>torch.nn.Module</code>模型的可学习参数（即权重和偏差）包含在模型的<em>parameters</em>中，（使用<code>model.parameters()</code>可以进行访问）。<em>state_dict</em>仅仅是python字典对象，它将每一层映射到其参数张量。注意，只有具有可学习参数的层（如卷积层、线性层等）的模型才具有<em>state_dict</em>这一项。优化目标<code>torch.optim</code>也有<em>state_dict</em>属性，它包含有关优化器的状态信息，以及使用的超参数。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Define model</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TheModelClass</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(TheModelClass, <span class="variable language_">self</span>).__init__()</span><br><span class="line">        <span class="variable language_">self</span>.conv1 = nn.Conv2d(<span class="number">3</span>, <span class="number">6</span>, <span class="number">5</span>)</span><br><span class="line">        <span class="variable language_">self</span>.pool = nn.MaxPool2d(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">        <span class="variable language_">self</span>.conv2 = nn.Conv2d(<span class="number">6</span>, <span class="number">16</span>, <span class="number">5</span>)</span><br><span class="line">        <span class="variable language_">self</span>.fc1 = nn.Linear(<span class="number">16</span> * <span class="number">5</span> * <span class="number">5</span>, <span class="number">120</span>)</span><br><span class="line">        <span class="variable language_">self</span>.fc2 = nn.Linear(<span class="number">120</span>, <span class="number">84</span>)</span><br><span class="line">        <span class="variable language_">self</span>.fc3 = nn.Linear(<span class="number">84</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        x = <span class="variable language_">self</span>.pool(F.relu(<span class="variable language_">self</span>.conv1(x)))</span><br><span class="line">        x = <span class="variable language_">self</span>.pool(F.relu(<span class="variable language_">self</span>.conv2(x)))</span><br><span class="line">        x = x.view(-<span class="number">1</span>, <span class="number">16</span> * <span class="number">5</span> * <span class="number">5</span>)</span><br><span class="line">        x = F.relu(<span class="variable language_">self</span>.fc1(x))</span><br><span class="line">        x = F.relu(<span class="variable language_">self</span>.fc2(x))</span><br><span class="line">        x = <span class="variable language_">self</span>.fc3(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"><span class="comment"># Initialize model</span></span><br><span class="line">model = TheModelClass()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Initialize optimizer</span></span><br><span class="line">optimizer = optim.SGD(model.parameters(), lr=<span class="number">0.001</span>, momentum=<span class="number">0.9</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Print model&#x27;s state_dict</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Model&#x27;s state_dict:&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> param_tensor <span class="keyword">in</span> model.state_dict():</span><br><span class="line">    <span class="built_in">print</span>(param_tensor, <span class="string">&quot;\t&quot;</span>, model.state_dict()[param_tensor].size())</span><br><span class="line"></span><br><span class="line"><span class="comment"># Print optimizer&#x27;s state_dict</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Optimizer&#x27;s state_dict:&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> var_name <span class="keyword">in</span> optimizer.state_dict():</span><br><span class="line">    <span class="built_in">print</span>(var_name, <span class="string">&quot;\t&quot;</span>, optimizer.state_dict()[var_name])</span><br></pre></td></tr></table></figure>
<p><strong>输出：</strong></p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Model</span><span class="string">&#x27;s state_dict:</span></span><br><span class="line"><span class="string">conv1.weight     torch.Size([6, 3, 5, 5])</span></span><br><span class="line"><span class="string">conv1.bias   torch.Size([6])</span></span><br><span class="line"><span class="string">conv2.weight     torch.Size([16, 6, 5, 5])</span></span><br><span class="line"><span class="string">conv2.bias   torch.Size([16])</span></span><br><span class="line"><span class="string">fc1.weight   torch.Size([120, 400])</span></span><br><span class="line"><span class="string">fc1.bias     torch.Size([120])</span></span><br><span class="line"><span class="string">fc2.weight   torch.Size([84, 120])</span></span><br><span class="line"><span class="string">fc2.bias     torch.Size([84])</span></span><br><span class="line"><span class="string">fc3.weight   torch.Size([10, 84])</span></span><br><span class="line"><span class="string">fc3.bias     torch.Size([10])</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Optimizer&#x27;</span>s <span class="symbol">state_dict:</span></span><br><span class="line">state    &#123;&#125;</span><br><span class="line">param_groups     [&#123;<span class="string">&#x27;lr&#x27;</span>: <span class="number">0.001</span>, <span class="string">&#x27;momentum&#x27;</span>: <span class="number">0.9</span>, <span class="string">&#x27;dampening&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;weight_decay&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;nesterov&#x27;</span>: <span class="title class_">False</span>, <span class="string">&#x27;params&#x27;</span>: [<span class="number">4675713712</span>, <span class="number">4675713784</span>, <span class="number">4675714000</span>, <span class="number">4675714072</span>, <span class="number">4675714216</span>, <span class="number">4675714288</span>, <span class="number">4675714432</span>, <span class="number">4675714504</span>, <span class="number">4675714648</span>, <span class="number">4675714720</span>]&#125;]</span><br></pre></td></tr></table></figure>
<h2 id="保存和加载推断模型"><a href="#保存和加载推断模型" class="headerlink" title="保存和加载推断模型"></a>保存和加载推断模型</h2><h3 id="保存-加载state-dict-推荐使用"><a href="#保存-加载state-dict-推荐使用" class="headerlink" title="保存/加载state_dict(推荐使用)"></a>保存/加载<code>state_dict</code>(推荐使用)</h3><p><strong>保存：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.save(model.state_dict(), PATH)</span><br></pre></td></tr></table></figure>
<p><strong>加载:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model = TheModelClass(*args, **kwargs)</span><br><span class="line">model.load_state_dict(torch.load(PATH))</span><br><span class="line">model.<span class="built_in">eval</span>()</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;用保存的模型进行推断的时候，只需要保存模型学习到的参数，使用<code>torch.save()</code>函数来保存模型<em>state_dict</em>，所用的资源要少于保存完整模型。在进行推断之前，要调用<code>model.eval()</code>去设置dropout和batch normalization层为评估模式。在传入<code>load_state_dict()</code>函数之前，需要使用<code>torch.load()</code>对<em>state_dict</em>进行反序列化。</p>
<h3 id="保存-加载完整模型"><a href="#保存-加载完整模型" class="headerlink" title="保存/加载完整模型"></a>保存/加载完整模型</h3><p><strong>保存：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.save(model, PATH)</span><br></pre></td></tr></table></figure>
<p><strong>加载：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model = torch.load(PATH)</span><br><span class="line">model.<span class="built_in">eval</span>()</span><br></pre></td></tr></table></figure>
<h3 id="保存torch-nn-DataParallel模型"><a href="#保存torch-nn-DataParallel模型" class="headerlink" title="保存torch.nn.DataParallel模型"></a>保存<code>torch.nn.DataParallel</code>模型</h3><p><strong>保存：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model = TheModelClass(*args, **kwargs)</span><br><span class="line">model = torch.nn.DataParallel(model)</span><br><span class="line">torch.save(model.state_dict(), PATH)</span><br></pre></td></tr></table></figure>
<p><strong>加载：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model = TheModelClass(*args, **kwargs)</span><br><span class="line">model = torch.nn.DataParallel(model)</span><br><span class="line">model.load_state_dict(torch.load(PATH))</span><br><span class="line">model.<span class="built_in">eval</span>()</span><br></pre></td></tr></table></figure>
<p><strong>在加载模型继续训练的时候，加载了两次<code>torch.nn.DataParallel</code>，保存的模型进行推断也需要加载两次才能进行推断。可以通过以下方法将保存的模型转化为非DataParallel模式的模型（所有key的名字前去掉modules）</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line"><span class="keyword">from</span> efficientnet <span class="keyword">import</span> efficientnet_b0b</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">model_path = <span class="string">&#x27;Result/efficientnet/07-22_13-15-51/1net_params.pkl&#x27;</span></span><br><span class="line">state_dict = torch.load(model_path)</span><br><span class="line">new_state_dict = OrderedDict()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> state_dict.items():</span><br><span class="line">    name = k[<span class="number">7</span>:]</span><br><span class="line">    new_state_dict[name] = v</span><br><span class="line"></span><br><span class="line">two_state_dict = OrderedDict()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> new_state_dict.items():</span><br><span class="line">    name = k[<span class="number">7</span>:]</span><br><span class="line">    two_state_dict[name] = v</span><br><span class="line"></span><br><span class="line">net = efficientnet_b0b((<span class="number">224</span>, <span class="number">224</span>), num_classes=<span class="number">1852</span>)</span><br><span class="line">net = nn.DataParallel(net)</span><br><span class="line">net.load_state_dict(new_state_dict)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>pytorch</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>string学习</title>
    <url>/2020/08/11/string%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="string和char-的区别"><a href="#string和char-的区别" class="headerlink" title="string和char*的区别"></a>string和char*的区别</h2><ul>
<li>char*是一个指针</li>
<li>string是一个类，类内部封装了char<em>，管理这个字符串，是一个char</em>型容器。</li>
</ul>
<p>特点：<br>&emsp;&emsp;string类内部封装了很多成员方法，如查找find，拷贝copy，删除delete，替换replace，插入insert。<br>&emsp;&emsp;string管理char*所分配的内存，不用担心复制越界和取值越界等，由类内部进行负责。</p>
<h2 id="字符串赋值"><a href="#字符串赋值" class="headerlink" title="字符串赋值"></a>字符串赋值</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string str1;</span><br><span class="line">str1 = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">string str2;</span><br><span class="line">str2 = str1;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;str2 = &quot;</span> &lt;&lt; str2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">string str3;</span><br><span class="line">str3 = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;str3 = &quot;</span> &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">string str4;</span><br><span class="line">str<span class="number">4.</span><span class="built_in">assign</span>(<span class="string">&quot;hello C++&quot;</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;str4 = &quot;</span> &lt;&lt; str4 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">string str5;</span><br><span class="line">str<span class="number">5.</span><span class="built_in">assign</span>(<span class="string">&quot;hello C++&quot;</span>, <span class="number">5</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;str5 = &quot;</span> &lt;&lt; str5 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">string str6;</span><br><span class="line">str<span class="number">6.</span><span class="built_in">assign</span>(<span class="number">10</span>, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;str6 = &quot;</span> &lt;&lt; str6 &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<h2 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string str1 = <span class="string">&quot;我&quot;</span>;</span><br><span class="line">str1 += <span class="string">&quot;爱玩游戏&quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">str1 += <span class="string">&#x27;:&#x27;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">string str2 = <span class="string">&quot; LOL&quot;</span>;</span><br><span class="line">str1 += str2;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">string str3 = <span class="string">&quot;I&quot;</span>;</span><br><span class="line">str<span class="number">3.</span><span class="built_in">append</span>(<span class="string">&quot; love &quot;</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;str3 = &quot;</span> &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">str<span class="number">3.</span><span class="built_in">append</span>(<span class="string">&quot;game abcde&quot;</span>, <span class="number">4</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;str3 = &quot;</span> &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">str<span class="number">3.</span><span class="built_in">append</span>(str2);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;str3 = &quot;</span> &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">str<span class="number">3.</span><span class="built_in">append</span>(<span class="string">&quot;LOL DNF&quot;</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;str3 = &quot;</span> &lt;&lt; str3 &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<h2 id="字符串查找和替换"><a href="#字符串查找和替换" class="headerlink" title="字符串查找和替换"></a>字符串查找和替换</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查找</span></span><br><span class="line">string str1 = <span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line"><span class="type">int</span> pos = str<span class="number">1.f</span>ind(<span class="string">&quot;de&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (pos != <span class="number">-1</span>)</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;pos = &quot;</span> &lt;&lt; pos &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;未找到&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// rfind</span></span><br><span class="line">pos = str<span class="number">1.</span><span class="built_in">rfind</span>(<span class="string">&quot;de&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (pos != <span class="number">-1</span>)</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;pos = &quot;</span> &lt;&lt; pos &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;未找到&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// rfind和find的区别</span></span><br><span class="line"><span class="comment">// rfind是从右向左找，find是从左向右</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 替换</span></span><br><span class="line"><span class="comment">// 从1号位置器3个字符替换位&quot;1111&quot;</span></span><br><span class="line">str<span class="number">1.</span><span class="built_in">replace</span>(<span class="number">1</span>, <span class="number">3</span>, <span class="string">&quot;test1211&quot;</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<h2 id="字符串存取"><a href="#字符串存取" class="headerlink" title="字符串存取"></a>字符串存取</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;str = &quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    cout &lt;&lt; str[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    cout &lt;&lt; str.<span class="built_in">at</span>(i) &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改</span></span><br><span class="line">str[<span class="number">0</span>] = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;str = &quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">str.<span class="built_in">at</span>(<span class="number">1</span>) = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;str = &quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<h2 id="字符串插入和删除"><a href="#字符串插入和删除" class="headerlink" title="字符串插入和删除"></a>字符串插入和删除</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;str = &quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入</span></span><br><span class="line">str.<span class="built_in">insert</span>(<span class="number">1</span>, <span class="string">&quot;111&quot;</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;str = &quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除</span></span><br><span class="line">str.<span class="built_in">erase</span>(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;str = &quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<h2 id="字符串获取子串"><a href="#字符串获取子串" class="headerlink" title="字符串获取子串"></a>字符串获取子串</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string str = <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line">string subStr = str.<span class="built_in">substr</span>(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;subStr = &quot;</span> &lt;&lt; subStr &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">string email = <span class="string">&quot;zhangsan@sina.com&quot;</span>;</span><br><span class="line"><span class="comment">// 从邮件地址中 获取 用户信息</span></span><br><span class="line"><span class="type">int</span> pos = email.<span class="built_in">find</span>(<span class="string">&quot;@&quot;</span>);</span><br><span class="line">string usrName = email.<span class="built_in">substr</span>(<span class="number">0</span>, pos);</span><br><span class="line">cout &lt;&lt; usrName &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<h2 id="字符串分割"><a href="#字符串分割" class="headerlink" title="字符串分割"></a>字符串分割</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 字符串分割</span></span><br><span class="line"><span class="comment"> * @param str 原字符串</span></span><br><span class="line"><span class="comment"> * @param splitChar 分割字符</span></span><br><span class="line"><span class="comment"> * @return 分割后的字符串数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">split</span><span class="params">(<span class="type">const</span> string &amp;str, <span class="type">const</span> string &amp;splitChar)</span> </span>&#123;</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="string">&quot;&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    string strs = str + splitChar;</span><br><span class="line">    <span class="type">size_t</span> pos = strs.<span class="built_in">find</span>(splitChar);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (pos != strs.npos) &#123;</span><br><span class="line">        string temp = strs.<span class="built_in">substr</span>(<span class="number">0</span>, pos);</span><br><span class="line">        res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">        strs = strs.<span class="built_in">substr</span>(pos<span class="number">+1</span>, strs.<span class="built_in">size</span>());</span><br><span class="line">        pos = strs.<span class="built_in">find</span>(splitChar);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title>vnc操作</title>
    <url>/2019/03/21/vnc%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/yingyujianmo/article/details/45201097">参考博客</a>  </p>
<h2 id="查看vnc进程"><a href="#查看vnc进程" class="headerlink" title="查看vnc进程"></a>查看vnc进程</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps -ef | grep vnc</span><br></pre></td></tr></table></figure>
<h2 id="杀掉vnc进程"><a href="#杀掉vnc进程" class="headerlink" title="杀掉vnc进程"></a>杀掉vnc进程</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vncserver -kill :9</span><br></pre></td></tr></table></figure>
<h2 id="使用指定分辨率启动vnc"><a href="#使用指定分辨率启动vnc" class="headerlink" title="使用指定分辨率启动vnc"></a>使用指定分辨率启动vnc</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vncserver -geometry 1920x1080 :43</span><br></pre></td></tr></table></figure>
<h2 id="查看vnc帮助"><a href="#查看vnc帮助" class="headerlink" title="查看vnc帮助"></a>查看vnc帮助</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vnc -help</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>远程桌面</tag>
      </tags>
  </entry>
  <entry>
    <title>将博客搬至CSDN</title>
    <url>/2020/08/26/%E5%B0%86%E5%8D%9A%E5%AE%A2%E6%90%AC%E8%87%B3CSDN/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>服务器使用指南</title>
    <url>/2019/05/29/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h2 id="查看cpu状况"><a href="#查看cpu状况" class="headerlink" title="查看cpu状况"></a>查看cpu状况</h2><p>使用命令：top</p>
<p><img src="/2019/05/29/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/image1.jpg" alt="图片1"></p>
<h2 id="查看gpu"><a href="#查看gpu" class="headerlink" title="查看gpu"></a>查看gpu</h2><p>使用命令：gpustat<br><img src="/2019/05/29/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/image2.jpg" alt="图片2"></p>
<h2 id="查看内存"><a href="#查看内存" class="headerlink" title="查看内存"></a>查看内存</h2><p>使用命令：free -m<br><img src="/2019/05/29/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/image3.jpg" alt="图片3"></p>
<h2 id="使用top-htop查看机器状况"><a href="#使用top-htop查看机器状况" class="headerlink" title="使用top/htop查看机器状况"></a>使用top/htop查看机器状况</h2><p><img src="/2019/05/29/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/image4.png" alt="picture4"></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习目标检测方法汇总</title>
    <url>/2019/06/26/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h2 id="目标检测简介"><a href="#目标检测简介" class="headerlink" title="目标检测简介"></a>目标检测简介</h2><p>&emsp;&emsp;目标检测是计算机视觉的一个重要研究方向，是指从一个场景（或图片）中找到感兴趣的目标。任务大致分为三个流程：</p>
<ul>
<li>从场景中提取候选区</li>
<li>从候选区提取特征</li>
<li>识别候选区的类别并对有效的候选框进行位置精修</li>
</ul>
<p>&emsp;&emsp;目标检测在生活的各个领域都有了广泛的应用，它是将图像或视频中的目标与不感兴趣的部分区分开，判断是否存在目标，若存在目标则确定目标的位置。近年来，随着互联网技术、人工智能计算和智能硬件的迅猛发展，人类生活中存在着大量的图像和视频数据，这使得计算机视觉的研究也越来越火热。目标检测技术作为计算机视觉领域的一个重要组成部分，也受到了很大程度上的关注。目前在实际生活中的应用也十分广泛，包括目标跟踪，视频监控，信息安全，自动驾驶，图像检索，医学图像分析，网络数据挖掘，无人机导航，遥感信息分析，国防系统，以及机器人环境感知等。<br>&emsp;&emsp;目标检测方法主要分为两大类：</p>
<ul>
<li>基于传统图像处理和机器学习算法的目标检测方法</li>
<li>基于深度学习的目标检测方法</li>
</ul>
<p>&emsp;&emsp;传统目标检测方法主要分为六个步骤，包括图像预处理，窗口滑动，特征提取，选择以及分类，和后处理这六个步骤。每个步骤所做的工作分别是：a)图像预处理是对检测图像进行图像的去噪声和增强，以及色彩转换等操作；b)窗口滑动是指在待测图像中滑动一个大小相同的窗口，将窗口中的子图像提取出来做候选区域；c)特征提取就是对候选区域使用特定的算法进行处理；d)特征选择即从上一步提取的特征向量中挑选出具有代表性的特征，降低特征的维数；e)特征分类就是利用特定的分类器对特征进行分类，判定候选区是否包含了目标及其类别；f)后处理是指合并判断为同一类别的相交候选区，计算出每个目标的边界框。<br>&emsp;&emsp;传统目标检测方法的检测重点是在特征提取（如何提高特征的表达能力和抗形变能力）和特征分类（如何提高分类器的准确度和速度上）。由此，研究人员提出了多种形式的特征和分类器，其中，代表性的特征有代表性的特征有SIFT(scale-invariant feature transform)、Hear、HOG(histogram of oriented gradient)、Strip等；代表性的分类器有AdaBoost、SVM(support vector machine)、DPM(deformable parts model)、RF(random forest)等。<br>&emsp;&emsp;但是，传统的目标检测方法的准确度并不能达到实际需求，其根本原因有两个，<font color="#ff000">一个是使用滑动窗口的策略进行区域选择时针对性不强，提高了时间复杂度和窗口冗余，另一个是使用设计的特征。</font>设计的特征存在以下三个缺点：a)设计的特征为低层特征，对目标的表达能力不足；b)设计的特征可分性差，导致分类的错误率较高；c)设计的特征具有针对性，很难选择单一特征应用于多目标检测，例如：Hear特征用于人脸检测，HOG特征用于行人检测，Stip特征用于车辆检测。<br>&emsp;&emsp;随着计算机性能的不断提高，曾经难以实现的深度学习算法变得切实可行，目标检测开始进入深度学习时代。深度学习提取的特征为高层特征，相比于传统的目标检测方法的设计特征，学习的特征更加丰富，表达能力更强。而且深度学习将特征提取，特征选择以及特征分类融合到一个模型中，通过端对端的训练，从整体上进行功能优化，增加了特征的可分性。基于深度学习的目标检测算法大致可以分为三类：a)基于区域建议的目标检测算法：如R-CNN，Fast-RCNN，Faster-RCNN；b)基于回归的目标检测算法：如YOLO，SSD；c)基于搜索的目标检测算法，如基于视觉注意的AttentionNet，基于强化学习的算法。  </p>
<h3 id="基于区域提名的深度学习目标检测算法"><a href="#基于区域提名的深度学习目标检测算法" class="headerlink" title="基于区域提名的深度学习目标检测算法"></a>基于区域提名的深度学习目标检测算法</h3><p>&emsp;&emsp;卷积神经网络（CNN）是区域提议（Region Propoal）算法的核心组成部分，卷积神经网络最早是有Yann LeCun教授提出来的，早期的卷积神经网络是用作分类器使用的，主要用于图像识别。卷积神经网络有三个结构上的特性：局部连接、权重共享以及空间和时间上的采样。这些特性使得卷积神经网络具有一定程度上的平移、缩放和扭曲不变性。在2006年Hinton提出使用深度神经网络从大量的数据中自动学习高层特征。区域建议在此基础上解决了传统目标检测方法存在的两个问题。比较常用的区域建议方法有Selective search和Edge boxes。此后，CNN网络迅速发展，微软最新的ResNet和谷歌的Inception V4模型的Top-5 error降到了4%以内，所以目标检测得到候选区域后使用CNN对其进行图像分类的准确率和检测速度上都有提高。这类算法的主要步骤是：</p>
<ul>
<li>首先使用选择性搜索算法（Selective Serch）、Bing、EdgeBoxes这些目标候选区域生成算法生成一系列候选目标区域；</li>
<li>然后通过深度神经网络提取目标候选区域的特征；</li>
<li>最后用这些特征进行分类，以及目标真实边界的回归。</li>
</ul>
<h4 id="R-CNN"><a href="#R-CNN" class="headerlink" title="R-CNN"></a>R-CNN</h4><p>&emsp;&emsp;R-CNN算法可以说是利用深度学习进行目标检测的开山之作，将深度学习引入了目标检测领域，一举将PASCAL VOC上的检测率从35.1%提升到53.7%。针对传统目标检测方法存在的两个问题，R-CNN都有了很好的解决方法：<font color="#ff000">预先提前一系列可能是物体的候选区域，之后仅在这些候选区域上提取特征，进行判断，</font>从而解决了传统目标检测方法利用滑动窗口依次判断所有可能的区域造成时间复杂度太高和窗口冗余的问题；<font color="#ff000">训练深度网络来进行特征提取替代人工设定特征，</font>解决了人工设定特征的三个缺点。<br>&emsp;&emsp;R-CNN的实现步骤主要有4个：</p>
<ul>
<li>a)首先用选择性搜索算法（selective Search）提取1k-2k个候选区域；</li>
<li>b)使用深度卷积神经网络提取每一个候选区的深度特征；</li>
<li>c)训练SVM分类器来对这些特征进行分类；</li>
<li>d)最后通过边界回归算法程序定位目标边界框。</li>
</ul>
<p><img src="/2019/06/26/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB/Figuer1.png" alt="Figure1"></p>
<p>&emsp;&emsp;但是，由于在特征提取后进行分类的过程中有一个全连接层的操作，这一个操作要求提取特征的图片需要相同尺度的大小，提取的不合适的特征图片需要进行裁切（Crop）或者变形缩放（Warp），这在一定程度上造成图像畸形，影响最终结果。随后He等人提出SPP-NET缩放很好的解决了这一问题。</p>
<h4 id="SPP-NET"><a href="#SPP-NET" class="headerlink" title="SPP-NET"></a>SPP-NET</h4><p>&emsp;&emsp;R-CNN存在的问题在SPP-NET解决主要在于SPP网络的提出，这一网络解决了R-CNN这一网络要求提取特征要求相同尺度的大小这一问题。下面是R-CNN和SPP-NET网络结构的对比。</p>
<p><img src="/2019/06/26/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB/Figuer2.png" alt="Figure2"></p>
<p>&emsp;&emsp;R-CNN现在提取图片特征后先进行卷积后再进行全连接层的训练，而SPP-NET的网络在进行卷积之后再进行SPP操作，这一操作可以让网络输入任何大小的图片，都会生成固定大小的输出，整体的结构除了这一点以外和之前的R-CNN没有什么不同，因此在其它方面，SPP-NET存在和R-CNN一样的问题。</p>
<h4 id="Fast-RCNN"><a href="#Fast-RCNN" class="headerlink" title="Fast RCNN"></a>Fast RCNN</h4><p>&emsp;&emsp;在2015年，继提出R-CNN算法后，Ross Girshick提出了Faster RCNN，流程更为紧凑，大幅提升了目标检测的速度，同样使用最大规模的网络，Fast R-CNN和R-CNN相比，训练时间从84小时减少为9.5小时，测试时间从47秒减少为0.32秒。在PASCAL VOC 2007上的准确率相差无几，约在66%~67%之间。<br>&emsp;&emsp;Fast RCNN主要解决了R-CNN的三个问题：</p>
<ul>
<li><p><strong>测试速度慢</strong><br>RCNN一张图片内候选框之间大量重叠，提取特征操作冗余。<br>Fast RCNN将整张图像归一化后直接送入深度网络，在邻接时，才加入候选框信息，在末尾的少数几层处理每个候选框。</p>
</li>
<li><p><strong>训练速度慢</strong><br>原因同上<br>在训练时，Fast RCNN先将一张图像送入网络，紧接着送入从这幅图像上提取出的候选区域。这些候选区域的前几层特征不需要再重复计算。</p>
</li>
<li><p><strong>训练所需空间大</strong><br>RCNN中独立的分类器和回归器需要大量特征作为训练样本。</p>
<font color="#ff000">Fast RCNN把类别判断和位置精确统一用深度网络实现，不再需要额外存储。</font>

</li>
</ul>
<p>&emsp;&emsp;其中，Fast RCNN最大的贡献是全连接层的提速。<br>&emsp;&emsp;分类和位置调整都是通过全连接层（fc）实现的，设前一级数据为x后一级数据为y，全连接层参数为w，尺寸为$u<em>v$。一次前向传播（forward）即为：<script type="math/tex">y = Wx</script><br>    计算复杂度为$u</em>v$。<br>    将W进行SVD分解，并用前t个特征值近似<script type="math/tex">W=U\Sigma   V^T\approx U(:,1:t)\cdot \Sigma  (1:t,1:t)\cdot V(:,1:t)^T</script><br>    原来的前向传播分解为两步：<script type="math/tex">y = Wx = U\cdot (\Sigma   \cdot V^T)\cdot x = U\cdot z</script><br>    计算复杂度变为$u\times t+v\times t$。<br>    在实现时，相当于把一个全连接层拆分为两个，中间以一个低维数据相连。<br><img src="/2019/06/26/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB/Figuer3.png" alt="Figure3"><br>    其实验结果为：</p>
<pre><code>* 网络末端同步训练的分类和位置调整，提升准确度；
* 使用多尺度的图像金字塔，性能几乎没有提高；
* 倍增训练数据，能够有2%~3%的准确度提升；
* 网络直接输出各类概率（softmax），比SVM分类器性能略好；
* 更多候选窗不能提升性能。
</code></pre><h4 id="Faster-R-CNN"><a href="#Faster-R-CNN" class="headerlink" title="Faster R-CNN"></a>Faster R-CNN</h4><p>&emsp;&emsp;同在2015年，Ross Girshick团队提出了Faster R-CNN，简单网络的目标检测速度达到17fps，在PASCAL VOC上准确率为59.9%；复杂网络达到5fps，准确率78.8%。<br>&emsp;&emsp;从RCNN到Fast RCNN，再到Faster R-CNN，目标检测的四个基本步骤（候选区域生成，特征提取，分类，位置精修）终于被统一到一个深度网络框架之内。所有计算没有重复，完全在GPU中完成，大大提高了运行速度。<br><img src="/2019/06/26/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB/Figuer4.png" alt="Figure4"><br>&emsp;&emsp;Faster RCNN可以简单地看做”区域生成网络+Fast R-CNN“的系统，用区域生成网络代替Fast R-CNN中的Selective Search方法。Faster R-CNN着重解决了这个系统中的三个问题：</p>
<pre><code>1.如何设计区域生成网络
2.如何训练区域生成网络
3.如何让区域生成网络和Fast RCNN网络共享特征提取网络
</code></pre><p>&emsp;&emsp;Faster R-CNN提出了区域生成网络RPN，快速生成候选区域；通过交替训练，使RPN和Fast RCNN网络共享参数。<br><img src="/2019/06/26/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB/Figuer5.png" alt="Figure5"></p>
<h3 id="基于回归的目标检测算法"><a href="#基于回归的目标检测算法" class="headerlink" title="基于回归的目标检测算法"></a>基于回归的目标检测算法</h3><p>&emsp;&emsp;虽然Faster R-CNN是目前主流的目标检测算法之一，但是速度上并不能满足实时的要求，随后出现YOLO，SSD这一类的算法逐渐凸显出其优略性，这类方法充分地利用了回归的思想，直接在原始图像的多个位置回归，判别出目标边框以及目标类别。</p>
<h4 id="YOLO"><a href="#YOLO" class="headerlink" title="YOLO"></a>YOLO</h4><p>&emsp;&emsp;2016年Redmon等人提出的YOLO算法是一个可以一次性预测多个Box位置和类别的卷积神经网络，YOLO算法的网络设计延续了GoogleNet的核心思想，真正意思上实现了端到端的目标检测，并且发挥了速度快的优势，但其精度有所下滑。但在同年Redmon等人在YOLO的基础上提出了YOLO9000算法，保持了YOLO的速度，提高了准确度。主要有两方面的改进：1)在原先的YOLO检测框架上进行一系列的改进，弥补了检测精度的不足；2)提出了目标检测和目标训练和二为一的方法。YOLOv2算法的训练网络采用降采样的方法在特定的情况下可以进行动态调整，这种机制可以使网络预测不同大小的图片，让检测速度和精度之间达到平衡。</p>
<h4 id="SSD"><a href="#SSD" class="headerlink" title="SSD"></a>SSD</h4><p>&emsp;&emsp;2016年Liu等人提出SSD算法，该算法结合YOLO的回归思想以及Faster R-CNN的anchor机制做到了速度和准确率并存。最初的YOLO算法是在7x77x7的框架下识别物体，用这种框架检测小物体时，准确率会下降。在SSD算法中去掉了YOLO算法的全连接层，所以对任意大小的物体都可以检测，性能基本不变。对SSD的测试集进行训练和训练使用候选区域及用来池化的标准测试器之间最大的不同之处在于，ground truth 需要被赋予一组固定集合检测输出中某一个特定输出。当这个赋值确定之后，损失函数和后向传播就能够实现端到端的应用。总之，SSD结合了YOLO中的回归思想和Faster R-CNN中的anchor机制，使用全图各个位置的多尺度区域特征进行回归，既保持了YOLO速度快的特性，也保证了窗口预测跟Faster R-CNN一样精准。</p>
]]></content>
      <categories>
        <category>目标检测</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>目标检测</tag>
        <tag>计算机视觉</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习笔记</title>
    <url>/2019/01/23/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>培养专注的习惯，学会独立思考</p>
<h2 id="学习AI需要哪些技能"><a href="#学习AI需要哪些技能" class="headerlink" title="学习AI需要哪些技能"></a><a href="https://zhuanlan.zhihu.com/p/52814848">学习AI需要哪些技能</a></h2><ul>
<li><p>1.编程基础  </p>
<ul>
<li>熟练使用linux，git，vim等环境和工具。  </li>
<li>熟练掌握 C/C++、Python等编程语言。  </li>
<li>熟练掌握cmake，g++等编译工具。  </li>
</ul>
</li>
<li><p>2.算法基础  </p>
<ul>
<li>熟悉传统图像算法，机器学习算法。  </li>
<li>熟练跟踪并阅读行业前沿研究，复现结果。</li>
<li>系统性熟悉深度学习理论。</li>
</ul>
</li>
<li><p>3.框架基础  </p>
<ul>
<li>熟练掌握 Caffe、TensorFlow、pytorch等以及不断新出的开源平台。  </li>
</ul>
</li>
<li><p>4.其它基础</p>
<ul>
<li>掌握爬虫等前后端的基础知识。  </li>
<li>了解并熟悉Cuda等GPU编程技术，了解一些移动端的硬件知识。  </li>
<li>了解并熟悉 Android、iOS 等移动端的基础知识，在项目中可能会需要使用。  </li>
</ul>
</li>
</ul>
<h2 id="吴恩达深度学习课后作业"><a href="#吴恩达深度学习课后作业" class="headerlink" title="吴恩达深度学习课后作业"></a>吴恩达深度学习课后作业</h2><p><a href="https://mooc.study.163.com/learn/2001281002?tid=2001392029#/learn/content">吴恩达深度学习视频</a><br><a href="https://blog.csdn.net/u013733326/article/details/79827273">作业参考</a></p>
<h3 id="神经网络和深度学习"><a href="#神经网络和深度学习" class="headerlink" title="神经网络和深度学习"></a>神经网络和深度学习</h3><h4 id="logistic回归"><a href="#logistic回归" class="headerlink" title="logistic回归"></a>logistic回归</h4><p><a href="https://github.com/JiangChenrui/DeeplingAI/tree/master/DeeplingAI_course1/week2_Logistic">作业代码</a>  </p>
<h4 id="浅层神经网络"><a href="#浅层神经网络" class="headerlink" title="浅层神经网络"></a>浅层神经网络</h4><p><a href="https://github.com/JiangChenrui/DeeplingAI/tree/master/DeeplingAI_course1/week3_simple_net">作业代码</a>  </p>
<h4 id="深层神经网络"><a href="#深层神经网络" class="headerlink" title="深层神经网络"></a>深层神经网络</h4><p><a href="https://github.com/JiangChenrui/DeeplingAI/tree/master/DeeplingAI_course1/week4_complex_net">作业代码</a></p>
<h3 id="改善深层神经网络"><a href="#改善深层神经网络" class="headerlink" title="改善深层神经网络"></a>改善深层神经网络</h3><h4 id="深度学习的实用层面"><a href="#深度学习的实用层面" class="headerlink" title="深度学习的实用层面"></a>深度学习的实用层面</h4><h2 id="cs231n课程笔记"><a href="#cs231n课程笔记" class="headerlink" title="cs231n课程笔记"></a>cs231n课程笔记</h2><h3 id="图像处理的一些简单方法"><a href="#图像处理的一些简单方法" class="headerlink" title="图像处理的一些简单方法"></a><a href="https://github.com/JiangChenrui/matching_learning_note/blob/master/image_enhance.py">图像处理的一些简单方法</a></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> ImageEnhance</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 原始图像</span></span><br><span class="line">image = Image.<span class="built_in">open</span>(<span class="string">&#x27;match_learning/picture/1.jpg&#x27;</span>)  <span class="comment"># 打开图片</span></span><br><span class="line"><span class="comment"># image.show()</span></span><br><span class="line">plt.figure(<span class="string">&quot;origan_image&quot;</span>)</span><br><span class="line">plt.imshow(image)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2019/01/23/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.jpg" alt="picture1">  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 亮度增强</span></span><br><span class="line">enh_bri = ImageEnhance.Brightness(image)</span><br><span class="line">brightness = <span class="number">1.5</span></span><br><span class="line">image_brightened = enh_bri.enhance(brightness)</span><br><span class="line"><span class="comment"># image_brightened.show()</span></span><br><span class="line">plt.figure(<span class="string">&quot;brightened&quot;</span>)</span><br><span class="line">plt.imshow(image_brightened)</span><br><span class="line">plt.show()</span><br><span class="line">image_brightened.save(<span class="string">&#x27;match_learning/picture/image_brightened.jpg&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/2019/01/23/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image_brightened.jpg" alt="picture2">  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 色度增强</span></span><br><span class="line">enh_col = ImageEnhance.Color(image)</span><br><span class="line">color = <span class="number">1.5</span></span><br><span class="line">image_colored = enh_col.enhance(color)</span><br><span class="line"><span class="comment"># image_colored.show()</span></span><br><span class="line">plt.figure(<span class="string">&quot;colored&quot;</span>)</span><br><span class="line">plt.imshow(image_colored)</span><br><span class="line">plt.show()</span><br><span class="line">image_colored.save(<span class="string">&#x27;match_learning/picture/image_colored.jpg&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/2019/01/23/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image_colored.jpg" alt="picture3">  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 对比度增强</span></span><br><span class="line">enh_con = ImageEnhance.Contrast(image)</span><br><span class="line">contrast = <span class="number">1.5</span></span><br><span class="line">image_contrasted = enh_con.enhance(contrast)</span><br><span class="line"><span class="comment"># image_contrasted.show()</span></span><br><span class="line">plt.figure(<span class="string">&quot;contrast&quot;</span>)</span><br><span class="line">plt.imshow(image_contrasted)</span><br><span class="line">plt.show()</span><br><span class="line">image_contrasted.save(<span class="string">&#x27;match_learning/picture/image_contrasted.jpg&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/2019/01/23/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image_contrasted.jpg" alt="picture4"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 锐度增强</span></span><br><span class="line">enh_sha = ImageEnhance.Sharpness(image)</span><br><span class="line">sharpness = <span class="number">1.5</span></span><br><span class="line">image_sharped = enh_sha.enhance(sharpness)</span><br><span class="line"><span class="comment"># image_sharped.show()</span></span><br><span class="line">plt.figure(<span class="string">&quot;sharpness&quot;</span>)</span><br><span class="line">plt.imshow(image_sharped)</span><br><span class="line">plt.show()</span><br><span class="line">image_sharped.save(<span class="string">&#x27;match_learning/picture/image_sharped.jpg&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/2019/01/23/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image_sharped.jpg" alt="picture5">  </p>
<h3 id="python学习笔记"><a href="#python学习笔记" class="headerlink" title="python学习笔记"></a><a href="https://github.com/JiangChenrui/DeeplingAI/blob/master/cs231n/python_study.py">python学习笔记</a></h3>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>笔记</tag>
        <tag>计算机视觉</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构和算法学习</title>
    <url>/2020/08/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>数据结构是计算机内部数据的组织形式和存储方法，常用的数据结构有线性结构、数结构、图结构。</p>
<p><img src="/2020/08/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/数据结构.png" alt="数据结构"></p>
<h3 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h3><p>线性结构主要包括：顺序表、链表、栈、队列等基本形式。其中顺序表和链表是从存储形式上（或物理结构上）区分的，而栈和队列是从逻辑功能上区分的。也就是说，顺序表和链表是线性数据结构的基础，队列和栈是基于顺序表和链表的，它们由顺序表或链表构成。</p>
<h4 id="栈的实现"><a href="#栈的实现" class="headerlink" title="栈的实现"></a>栈的实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> STACK_HPP</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACK_HPP</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Stack</span>();</span><br><span class="line">    <span class="built_in">Stack</span>(<span class="type">int</span> capacity);</span><br><span class="line">    ~<span class="built_in">Stack</span>();</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsEmpty</span><span class="params">()</span></span>;                 <span class="comment">// 判断是否为空</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsFull</span><span class="params">()</span></span>;                  <span class="comment">// 判断栈是否已满</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ClearStack</span><span class="params">()</span></span>;              <span class="comment">// 清空栈</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Length</span><span class="params">()</span></span>;                   <span class="comment">// 获取栈的长度</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Push</span><span class="params">(<span class="type">const</span> T &amp;element)</span></span>;    <span class="comment">// 获取元素</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Pop</span><span class="params">(T &amp;ele)</span></span>;               <span class="comment">// 弹出栈顶元素</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">StackTraverse</span><span class="params">()</span></span>;           <span class="comment">// 遍历栈</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *m_stack;     <span class="comment">// 容器</span></span><br><span class="line">    <span class="type">int</span> m_top;      <span class="comment">// 栈顶</span></span><br><span class="line">    <span class="type">int</span> m_capacity; <span class="comment">// 容器容量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Stack&lt;T&gt;::<span class="built_in">Stack</span>() &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Stack&lt;T&gt;::<span class="built_in">Stack</span>(<span class="type">int</span> capacity) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_capacity = capacity;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_stack = <span class="keyword">new</span> T[<span class="keyword">this</span>-&gt;m_capacity];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Stack&lt;T&gt;::~<span class="built_in">Stack</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_stack != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;m_stack;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_stack = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> Stack&lt;T&gt;::<span class="built_in">IsEmpty</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_top == <span class="number">0</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> Stack&lt;T&gt;::<span class="built_in">IsFull</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_top == <span class="keyword">this</span>-&gt;m_capacity ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> Stack&lt;T&gt;::<span class="built_in">ClearStack</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_top = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">int</span> Stack&lt;T&gt;::<span class="built_in">Length</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_top;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> Stack&lt;T&gt;::<span class="built_in">Push</span>(<span class="type">const</span> T &amp;element) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsFull</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_stack[<span class="keyword">this</span>-&gt;m_top++] = element;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> Stack&lt;T&gt;::<span class="built_in">Pop</span>(T &amp;ele) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">IsEmpty</span>()) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_top--;</span><br><span class="line">        ele = <span class="keyword">this</span>-&gt;m_stack[<span class="keyword">this</span>-&gt;m_top];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> Stack&lt;T&gt;::<span class="built_in">StackTraverse</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">IsEmpty</span>()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = m_top - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="keyword">this</span>-&gt;m_stack[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;栈为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h4 id="队列的实现"><a href="#队列的实现" class="headerlink" title="队列的实现"></a>队列的实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MYQUEUE_HPP</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MYQUEUE_HPP</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">QueueNode</span> &#123;</span><br><span class="line">    T data;</span><br><span class="line">    QueueNode *next;</span><br><span class="line">    <span class="built_in">QueueNode</span> () &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyQueue</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;head = <span class="keyword">new</span> QueueNode &lt;T&gt;();</span><br><span class="line">        <span class="keyword">this</span>-&gt;tail = <span class="keyword">new</span> QueueNode &lt;T&gt;();</span><br><span class="line">        <span class="keyword">this</span>-&gt;tail = <span class="keyword">this</span>-&gt;head;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">MyQueue</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;head != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;释放head&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;head;</span><br><span class="line">            <span class="keyword">this</span>-&gt;head = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;tail != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;释放tail&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;tail;</span><br><span class="line">            <span class="keyword">this</span>-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">InQueue</span><span class="params">(T val)</span> </span>&#123;</span><br><span class="line">        QueueNode &lt;T&gt; *temp = <span class="keyword">new</span> <span class="built_in">QueueNode</span>&lt;T&gt;();</span><br><span class="line">        temp-&gt;data = val;</span><br><span class="line">        <span class="keyword">this</span>-&gt;tail-&gt;next = temp;</span><br><span class="line">        <span class="keyword">this</span>-&gt;tail = temp;</span><br><span class="line">        <span class="keyword">this</span>-&gt;count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">QueueNode&lt;T&gt;* <span class="title">OutQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;count == <span class="number">0</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;队列为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        QueueNode &lt;T&gt; *temp = <span class="keyword">this</span>-&gt;head-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (temp) &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;head-&gt;next = temp-&gt;next;</span><br><span class="line">            temp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">this</span>-&gt;count--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">QueueTraverse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;count == <span class="number">0</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;队列为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        QueueNode &lt;T&gt; *temp = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (temp) &#123;</span><br><span class="line">            cout &lt;&lt; temp-&gt;data &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;tail = <span class="keyword">this</span>-&gt;head;</span><br><span class="line">        <span class="keyword">this</span>-&gt;count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    QueueNode &lt;T&gt; *head;</span><br><span class="line">    QueueNode &lt;T&gt; *tail;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h4 id="链表反转"><a href="#链表反转" class="headerlink" title="链表反转"></a>链表反转</h4><p>使用两个节点pre和next，先用next保存当前节点的next指针，然后将当前节点next指针指向上一个节点pre，接下来将当前节点赋值给pre，next赋值给当前节点进行下一循环，直到当前节点为NULL。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">ListNode</span> *next;</span><br><span class="line">	<span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 链表反转</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">ListNode* <span class="title">ReverseList</span><span class="params">(ListNode *pHead)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pHead == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    ListNode *pre = <span class="literal">NULL</span>;</span><br><span class="line">    ListNode *next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (pHead != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        next = pHead-&gt;next;</span><br><span class="line">        pHead-&gt;next = pre;</span><br><span class="line">        pre = pHead;</span><br><span class="line">        pHead = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="寻找第k大"><a href="#寻找第k大" class="headerlink" title="寻找第k大"></a>寻找第k大</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 降序排列</span></span><br><span class="line">    <span class="keyword">if</span> (start == end)</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    <span class="type">int</span> left = start, right = end, key = arr[start];</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; arr[right] &lt;= key)</span><br><span class="line">            right--;</span><br><span class="line">        arr[left] = arr[right];</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; arr[left] &gt;= key)</span><br><span class="line">            left++;</span><br><span class="line">        arr[right] = arr[left];</span><br><span class="line">    &#125;</span><br><span class="line">    arr[left] = key;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 寻找第k大</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findKth</span><span class="params">(vector&lt;<span class="type">int</span>&gt; a, <span class="type">int</span> n, <span class="type">int</span> K)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> high = n - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        mid = <span class="built_in">Partition</span>(a, low, high);</span><br><span class="line">        <span class="keyword">if</span> (K &lt; mid + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 在左半段</span></span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span>  <span class="keyword">if</span> (K &gt; mid + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 在右半段</span></span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> a[mid];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="括号序列"><a href="#括号序列" class="headerlink" title="括号序列"></a>括号序列</h4><p>给出一个仅包含字符’(‘,’)’,’{‘,’}’,’[‘和’]’,的字符串，判断给出的字符串是否是合法的括号序列，括号必须以正确的顺序关闭，”()”和”()[]{}”都是合法的括号序列，但”(]”和”([)]”不合法。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果字符串长度不是偶数，则不合法</span></span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">size</span>() &amp; <span class="number">1</span> != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    stack&lt;<span class="type">char</span>&gt; temp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span> || s[i] == <span class="string">&#x27;&#123;&#x27;</span> || s[i] == <span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">            temp.<span class="built_in">push</span>(s[i]);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.<span class="built_in">empty</span>())</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">switch</span> (s[i]) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;&#125;&#x27;</span>:</span><br><span class="line">                    <span class="keyword">if</span> (temp.<span class="built_in">top</span>() == <span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">                        temp.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;]&#x27;</span>:</span><br><span class="line">                    <span class="keyword">if</span> (temp.<span class="built_in">top</span>() == <span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">                        temp.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">                    <span class="keyword">if</span> (temp.<span class="built_in">top</span>() == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                        temp.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!temp.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="链表中的节点每k有一组翻转"><a href="#链表中的节点每k有一组翻转" class="headerlink" title="链表中的节点每k有一组翻转"></a>链表中的节点每k有一组翻转</h4><p><strong>题目描述</strong></p>
<p>将给出的链表中的节点每$k$个一组翻转，返回翻转后的链表<br>如果链表中的节点数不是$k$的倍数，将最后剩下的节点保持原样<br>你不能更改节点中的值，只能更改节点本身。<br>要求空间复杂度$O(1)$。<br>例如：<br>给定的链表是$1→2→3→4→5$</p>
<ul>
<li>对于 $k = 2$, 你应该返回 $2→1→4→3→5$</li>
<li>对于 $k = 3$, 你应该返回 $3→2→1→4→5$</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 链表中的节点每k有一组翻转</span></span><br><span class="line"><span class="comment"> * @param head</span></span><br><span class="line"><span class="comment"> * @param k</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    ListNode *temp = head;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (temp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">        ++len;</span><br><span class="line">    &#125;</span><br><span class="line">    temp = head;</span><br><span class="line">    <span class="keyword">if</span> (len &lt; k)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    ListNode *pre = <span class="literal">NULL</span>;</span><br><span class="line">    ListNode *next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">        next = head-&gt;next;</span><br><span class="line">        head-&gt;next = pre;</span><br><span class="line">        pre = head;</span><br><span class="line">        head = next;</span><br><span class="line">    &#125;</span><br><span class="line">    temp-&gt;next = <span class="built_in">reverseKGroup</span>(head, k);</span><br><span class="line">    <span class="keyword">return</span> pre;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="将字符串转换为整数"><a href="#将字符串转换为整数" class="headerlink" title="将字符串转换为整数"></a>将字符串转换为整数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">StrToInt</span><span class="params">(string str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> mark = (str[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>) ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> i = (str[<span class="number">0</span>] == <span class="string">&#x27;+&#x27;</span> || str[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; str.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str[i] &lt; <span class="string">&#x27;0&#x27;</span> || str[i] &gt; <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        res = res*<span class="number">10</span> + str[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res*mark;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="数组中重复的数字"><a href="#数组中重复的数字" class="headerlink" title="数组中重复的数字"></a>数组中重复的数字</h4><p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">duplicate</span><span class="params">(<span class="type">int</span> numbers[], <span class="type">int</span> length, <span class="type">int</span>* duplication)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (length == <span class="number">0</span> || length == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> *tempArr = <span class="keyword">new</span> <span class="type">int</span>[length]();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tempArr[numbers[i]] == <span class="number">0</span>)</span><br><span class="line">            tempArr[numbers[i]] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            *duplication = numbers[i];</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="构建乘积数组"><a href="#构建乘积数组" class="headerlink" title="构建乘积数组"></a>构建乘积数组</h4><p>给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]<em>A[1]</em>…<em>A[i-1]</em>A[i+1]<em>…</em>A[n-1]。不能使用除法。（注意：规定B[0] = A[1] <em> A[2] </em> … <em> A[n-1]，B[n-1] = A[0] </em> A[1] <em> … </em> A[n-2];）<br>对于A长度为1的情况，B无意义，故而无法构建，因此该情况不会存在。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">multiply</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">B</span><span class="params">(A.size(), <span class="number">1</span>)</span></span>;</span><br><span class="line">    B[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; A.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        B[i] = B[i<span class="number">-1</span>] * A[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> temp = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = A.<span class="built_in">size</span>() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">        B[j] *= temp;</span><br><span class="line">        temp *= A[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> B;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="表示数值的字符串"><a href="#表示数值的字符串" class="headerlink" title="表示数值的字符串"></a>表示数值的字符串</h4><p><strong>题目描述</strong></p>
<p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isNumeric</span><span class="params">(<span class="type">char</span>* str)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 标记符号、小数点、e是否出现过</span></span><br><span class="line">    <span class="type">bool</span> sign = <span class="literal">false</span>, decimal = <span class="literal">false</span>, hasE = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(str); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str[i] == <span class="string">&#x27;e&#x27;</span> || str[i] == <span class="string">&#x27;E&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="built_in">strlen</span>(str)<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// e后面一定要接数字</span></span><br><span class="line">            <span class="keyword">if</span> (hasE) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 不能同时存在两个e</span></span><br><span class="line">            hasE = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (str[i] == <span class="string">&#x27;+&#x27;</span> || str[i] == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 第二次出现+-符号，则必须紧接在e之后</span></span><br><span class="line">            <span class="keyword">if</span> (sign &amp;&amp; str[i<span class="number">-1</span>] != <span class="string">&#x27;e&#x27;</span> &amp;&amp; str[i<span class="number">-1</span>] != <span class="string">&#x27;E&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 第一次出现+-符号，且不是在字符串开头，则也必须紧接在e之后</span></span><br><span class="line">            <span class="keyword">if</span> (!sign &amp;&amp; i &gt; <span class="number">0</span> &amp;&amp; str[i<span class="number">-1</span>] != <span class="string">&#x27;e&#x27;</span> &amp;&amp; str[i<span class="number">-1</span>] != <span class="string">&#x27;E&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            sign = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (str[i] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// e后面不能接小数点，小数点不能出现两次</span></span><br><span class="line">            <span class="keyword">if</span> (hasE || decimal) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            decimal = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (str[i] &lt; <span class="string">&#x27;0&#x27;</span> || str[i] &gt; <span class="string">&#x27;9&#x27;</span>) <span class="comment">// 不合法字符</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="字符流中第一个不重复的字符"><a href="#字符流中第一个不重复的字符" class="headerlink" title="字符流中第一个不重复的字符"></a>字符流中第一个不重复的字符</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Solution</span>() &#123;</span><br><span class="line">        cnt = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">128</span>]();</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Solution</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (cnt != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">delete</span>[] cnt;</span><br><span class="line">        cnt = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">char</span> ch)</span> </span>&#123;</span><br><span class="line">        ++cnt[ch - <span class="string">&#x27;\0&#x27;</span>];</span><br><span class="line">        <span class="keyword">if</span> (cnt[ch - <span class="string">&#x27;\0&#x27;</span>] == <span class="number">1</span>)</span><br><span class="line">            data.<span class="built_in">push</span>(ch);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">FirstAppearingOnce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!data.<span class="built_in">empty</span>() &amp;&amp; cnt[data.<span class="built_in">front</span>() - <span class="string">&#x27;\0&#x27;</span>] &gt; <span class="number">1</span>)</span><br><span class="line">            data.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (data.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> data.<span class="built_in">front</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    queue&lt;<span class="type">char</span>&gt; data;</span><br><span class="line">    <span class="type">int</span> *cnt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="删除链表中重复的结点"><a href="#删除链表中重复的结点" class="headerlink" title="删除链表中重复的结点"></a>删除链表中重复的结点</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除链表中重复的结点</span></span><br><span class="line"><span class="function">ListNode* <span class="title">deleteDuplication</span><span class="params">(ListNode* pHead)</span> </span>&#123;</span><br><span class="line">    ListNode *slow, *fast;</span><br><span class="line">    ListNode *Head = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    Head-&gt;next = pHead;</span><br><span class="line">    slow = Head;</span><br><span class="line">    fast = Head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fast-&gt;next != <span class="literal">NULL</span> &amp;&amp; fast-&gt;val == fast-&gt;next-&gt;val) &#123;</span><br><span class="line">            <span class="keyword">while</span> (fast-&gt;next != <span class="literal">NULL</span> &amp;&amp; fast-&gt;val == fast-&gt;next-&gt;val)</span><br><span class="line">                fast = fast-&gt;next;</span><br><span class="line">            slow-&gt;next = fast-&gt;next;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> Head-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="两两交换链表中的节点"><a href="#两两交换链表中的节点" class="headerlink" title="两两交换链表中的节点"></a>两两交换链表中的节点</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode* res = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    res-&gt;next = head;</span><br><span class="line">    ListNode* first = res;</span><br><span class="line">    <span class="keyword">while</span> (first-&gt;next != <span class="literal">NULL</span> &amp;&amp; first-&gt;next-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ListNode* second = first-&gt;next;</span><br><span class="line">        ListNode* third = first-&gt;next-&gt;next;</span><br><span class="line"></span><br><span class="line">        first-&gt;next = third;</span><br><span class="line">        second-&gt;next = third-&gt;next;</span><br><span class="line">        third-&gt;next = second;</span><br><span class="line"></span><br><span class="line">        first = second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="字符串的排列"><a href="#字符串的排列" class="headerlink" title="字符串的排列"></a>字符串的排列</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 后剪枝</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(string s, <span class="type">int</span> start, set&lt;string&gt;&amp; res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">size</span>() == start) &#123;</span><br><span class="line">        res.<span class="built_in">insert</span>(s);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(s[i], s[start]);</span><br><span class="line">        <span class="built_in">dfs</span>(s, start<span class="number">+1</span>, res);</span><br><span class="line">        <span class="built_in">swap</span>(s[i], s[start]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 过程中剪枝</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(string s, <span class="type">int</span> start, vector&lt;string&gt;&amp; res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">size</span>() == start) &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(s);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    set&lt;<span class="type">char</span>&gt; st;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (st.<span class="built_in">count</span>(s[i])) <span class="keyword">continue</span>;</span><br><span class="line">        st.<span class="built_in">insert</span>(s[i]);</span><br><span class="line">        <span class="built_in">swap</span>(s[i], s[start]);</span><br><span class="line">        <span class="built_in">dfs</span>(s, start<span class="number">+1</span>, res);</span><br><span class="line">        <span class="built_in">swap</span>(s[i], s[start]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">permutation</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    <span class="built_in">dfs</span>(s, <span class="number">0</span>, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="滑动窗口的最大值"><a href="#滑动窗口的最大值" class="headerlink" title="滑动窗口的最大值"></a>滑动窗口的最大值</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 滑动窗口的最大值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findMax</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; nums, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> maxval = nums[i];</span><br><span class="line">    <span class="keyword">for</span> (; i &lt;= j; ++i) &#123;</span><br><span class="line">        maxval = <span class="built_in">max</span>(maxval, nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxval;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    <span class="type">int</span> maxval = <span class="built_in">findMax</span>(nums, <span class="number">0</span>, k<span class="number">-1</span>);</span><br><span class="line">    ans.<span class="built_in">push_back</span>(maxval);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = k, i = <span class="number">1</span>; j &lt; nums.<span class="built_in">size</span>(); ++j, ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[j] &gt; maxval)</span><br><span class="line">            maxval = nums[j];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[i<span class="number">-1</span>] == maxval)</span><br><span class="line">            maxval = <span class="built_in">findMax</span>(nums, i, j);</span><br><span class="line">        ans.<span class="built_in">push_back</span>(maxval);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="字符串转换为整数"><a href="#字符串转换为整数" class="headerlink" title="字符串转换为整数"></a>字符串转换为整数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">strToInt</span><span class="params">(string str)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>, bndry = INT_MAX / <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, sign = <span class="number">1</span>, length = str.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (str[i] == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> (++i == length) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (str[i] == <span class="string">&#x27;-&#x27;</span>) sign = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (str[i] == <span class="string">&#x27;-&#x27;</span> || str[i] == <span class="string">&#x27;+&#x27;</span>) i++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; length; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str[j] &lt; <span class="string">&#x27;0&#x27;</span> || str[j] &gt; <span class="string">&#x27;9&#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (res &gt; bndry || res == bndry &amp;&amp; str[j] &gt; <span class="string">&#x27;7&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> sign == <span class="number">1</span> ? INT_MAX : INT_MIN;</span><br><span class="line">        res = res * <span class="number">10</span> + (str[j] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sign*res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><h4 id="调整数组顺序是奇数位于偶数前面"><a href="#调整数组顺序是奇数位于偶数前面" class="headerlink" title="调整数组顺序是奇数位于偶数前面"></a>调整数组顺序是奇数位于偶数前面</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">exchange</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> start = <span class="number">0</span>, end = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">        <span class="keyword">while</span> (nums[start] % <span class="number">2</span> != <span class="number">0</span>) start++;</span><br><span class="line">        <span class="keyword">while</span> (nums[end] %<span class="number">2</span> == <span class="number">0</span>) end--;</span><br><span class="line">        <span class="built_in">swap</span>(nums[start], nums[end]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="和为s的两个数字"><a href="#和为s的两个数字" class="headerlink" title="和为s的两个数字"></a>和为s的两个数字</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> start = <span class="number">0</span>, end = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[start] + nums[end] == target) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(nums[start]);</span><br><span class="line">            res.<span class="built_in">push_back</span>(nums[end]);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[start] + nums[end] &lt; target) start++;</span><br><span class="line">        <span class="keyword">else</span> end--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="判断链表中是否有环"><a href="#判断链表中是否有环" class="headerlink" title="判断链表中是否有环"></a>判断链表中是否有环</h4><p><a href="https://zhuanlan.zhihu.com/p/38521018">链表和快慢指针</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断给定的链表是否有环</span></span><br><span class="line"><span class="comment"> * @param head</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    ListNode *low, *quick;</span><br><span class="line">    low = quick = head;</span><br><span class="line">    <span class="keyword">while</span> (quick-&gt;next-&gt;next != <span class="literal">NULL</span> &amp;&amp; quick-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        low = low-&gt;next;</span><br><span class="line">        quick = quick-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (low == quick)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="链表中环的入口"><a href="#链表中环的入口" class="headerlink" title="链表中环的入口"></a>链表中环的入口</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ListNode *slow = head;</span><br><span class="line">    ListNode *fast = head;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (slow == fast)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fast == <span class="literal">NULL</span> || fast-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    fast = head;</span><br><span class="line">    <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="合并有序链表"><a href="#合并有序链表" class="headerlink" title="合并有序链表"></a>合并有序链表</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">    ListNode *head = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">    ListNode *temp = head;</span><br><span class="line">    <span class="keyword">while</span> (l1 != <span class="literal">NULL</span> || l2 != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            temp-&gt;next = l2;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l2 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            temp-&gt;next = l1;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">            temp-&gt;next = l1;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            temp-&gt;next = l2;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="删除链表的倒数第N个节点"><a href="#删除链表的倒数第N个节点" class="headerlink" title="删除链表的倒数第N个节点"></a>删除链表的倒数第N个节点</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除链表倒数第N个节点</span></span><br><span class="line"><span class="comment"> * @param head ListNode类 </span></span><br><span class="line"><span class="comment"> * @param n int整型 </span></span><br><span class="line"><span class="comment"> * @return ListNode类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    dummy-&gt;next = head;</span><br><span class="line">    head = dummy;</span><br><span class="line">    ListNode *slow = head;</span><br><span class="line">    ListNode *fast = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (fast-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode *temp = slow-&gt;next;</span><br><span class="line">    slow-&gt;next = slow-&gt;next-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> temp;</span><br><span class="line">    <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="两个链表相加生成相加链表"><a href="#两个链表相加生成相加链表" class="headerlink" title="两个链表相加生成相加链表"></a>两个链表相加生成相加链表</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 两个链表相加生成相加链表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">ListNode* <span class="title">addInList</span><span class="params">(ListNode* head1, ListNode* head2)</span> </span>&#123;</span><br><span class="line">    stack&lt;ListNode *&gt; s1;</span><br><span class="line">    stack&lt;ListNode *&gt; s2;</span><br><span class="line">    <span class="keyword">while</span> (head1) &#123;</span><br><span class="line">        s<span class="number">1.</span><span class="built_in">push</span>(head1);</span><br><span class="line">        head1 = head1-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (head2) &#123;</span><br><span class="line">        s<span class="number">2.</span><span class="built_in">push</span>(head2);</span><br><span class="line">        head2 = head2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!s<span class="number">1.</span><span class="built_in">empty</span>() || !s<span class="number">2.</span><span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> sum = flag;</span><br><span class="line">        <span class="keyword">if</span> (!s<span class="number">1.</span><span class="built_in">empty</span>()) &#123;</span><br><span class="line">            sum += s<span class="number">1.</span><span class="built_in">top</span>()-&gt;val;</span><br><span class="line">            head1 = s<span class="number">1.</span><span class="built_in">top</span>();</span><br><span class="line">            s<span class="number">1.</span><span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!s<span class="number">2.</span><span class="built_in">empty</span>()) &#123;</span><br><span class="line">            sum += s<span class="number">2.</span><span class="built_in">top</span>()-&gt;val;</span><br><span class="line">            <span class="keyword">if</span> (s<span class="number">2.</span><span class="built_in">size</span>() &gt; s<span class="number">1.</span><span class="built_in">size</span>())</span><br><span class="line">                head1 = s<span class="number">2.</span><span class="built_in">top</span>();</span><br><span class="line">            s<span class="number">2.</span><span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum &lt; <span class="number">10</span>) &#123;</span><br><span class="line">            head1-&gt;val = sum;</span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            head1-&gt;val = sum % <span class="number">10</span>;</span><br><span class="line">            flag = sum / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ListNode *head = <span class="keyword">new</span> <span class="built_in">ListNode</span>(flag);</span><br><span class="line">        head-&gt;next = head1;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="翻转单词顺序"><a href="#翻转单词顺序" class="headerlink" title="翻转单词顺序"></a>翻转单词顺序</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">split</span><span class="params">(<span class="type">const</span> string &amp;str, <span class="type">const</span> string &amp;splitChar)</span> </span>&#123;</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="string">&quot;&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    string strs = str + splitChar;</span><br><span class="line">    <span class="type">size_t</span> pos = strs.<span class="built_in">find</span>(splitChar);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (pos != strs.npos) &#123;</span><br><span class="line">        string temp = strs.<span class="built_in">substr</span>(<span class="number">0</span>, pos);</span><br><span class="line">        <span class="keyword">if</span> (temp != <span class="string">&quot; &quot;</span> &amp;&amp; temp != <span class="string">&quot;&quot;</span>)</span><br><span class="line">            res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">        strs = strs.<span class="built_in">substr</span>(pos<span class="number">+1</span>, strs.<span class="built_in">size</span>());</span><br><span class="line">        pos = strs.<span class="built_in">find</span>(splitChar);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    string res;</span><br><span class="line">    <span class="type">const</span> string splitChar = <span class="string">&quot; &quot;</span>;</span><br><span class="line">    vector&lt;string&gt; store = <span class="built_in">split</span>(s, splitChar);</span><br><span class="line">    <span class="keyword">if</span> (store.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">int</span> len = store.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    res = store[len--];</span><br><span class="line">    <span class="keyword">while</span>(len &gt;=<span class="number">0</span>) &#123;</span><br><span class="line">        res += <span class="string">&quot; &quot;</span> + store[len--];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="多数之和问题"><a href="#多数之和问题" class="headerlink" title="多数之和问题"></a>多数之和问题</h4><ul>
<li>三数之和</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreeSum</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">3</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; temp = <span class="built_in">twoSum</span>(nums, i<span class="number">+1</span>, <span class="number">0</span> - nums[i]);</span><br><span class="line">            <span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;&amp; a : temp) &#123;</span><br><span class="line">                a.<span class="built_in">insert</span>(a.<span class="built_in">begin</span>(), nums[i]);</span><br><span class="line">                res.<span class="built_in">push_back</span>(a);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; n - <span class="number">2</span> &amp;&amp; nums[i] == nums[i<span class="number">+1</span>]) i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">twoSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> start, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> low = start, high = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="type">int</span> sum = nums[low] + nums[high];</span><br><span class="line">            <span class="type">int</span> left = nums[low], right = nums[high];</span><br><span class="line">            <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">                <span class="keyword">while</span> (low &lt; high &amp;&amp; nums[low] == left) low++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">                <span class="keyword">while</span> (low &lt; high &amp;&amp; nums[high] == right) high--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(&#123;left, right&#125;);</span><br><span class="line">                <span class="keyword">while</span> (low &lt; high &amp;&amp; nums[low] == left) low++;</span><br><span class="line">                <span class="keyword">while</span> (low &lt; high &amp;&amp; nums[high] == right) high--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>四数之和</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">fourSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">nSumTarget</span>(nums, <span class="number">4</span>, <span class="number">0</span>, target);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">nSumTarget</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> n, <span class="type">int</span> start, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> size = nums.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span> || size &lt; n) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="type">int</span> low = start, high = size - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">                <span class="type">int</span> left = nums[low], right = nums[high];</span><br><span class="line">                <span class="type">int</span> sum = left + right;</span><br><span class="line">                <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (low &lt; high &amp;&amp; nums[low] == left) low++;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (low &lt; high &amp;&amp; nums[high] == right) high--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(&#123;left, right&#125;);</span><br><span class="line">                    <span class="keyword">while</span> (low &lt; high &amp;&amp; nums[low] == left) low++;</span><br><span class="line">                    <span class="keyword">while</span> (low &lt; high &amp;&amp; nums[high] == right) high--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt; size; ++i) &#123;</span><br><span class="line">                vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; sub = <span class="built_in">nSumTarget</span>(nums, n<span class="number">-1</span>, i<span class="number">+1</span>, target-nums[i]);</span><br><span class="line">                <span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;&amp; arr : sub) &#123;</span><br><span class="line">                    arr.<span class="built_in">insert</span>(arr.<span class="built_in">begin</span>(), nums[i]);</span><br><span class="line">                    res.<span class="built_in">push_back</span>(arr);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (i &lt; size<span class="number">-1</span> &amp;&amp; nums[i] == nums[i<span class="number">+1</span>]) i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="树结构"><a href="#树结构" class="headerlink" title="树结构"></a>树结构</h3><p>数据之间存在“一对多”的关系构成了树结构。</p>
<h4 id="二叉树中序遍历"><a href="#二叉树中序遍历" class="headerlink" title="二叉树中序遍历"></a>二叉树中序遍历</h4><p>递归方法<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">(TreeNode *node, vector&lt;<span class="type">int</span>&gt; &amp;res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">inorder</span>(node-&gt;left, res);</span><br><span class="line">    res.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">    <span class="built_in">inorder</span>(node-&gt;right, res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二叉树中序遍历</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="built_in">inorder</span>(root, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>非递归方法<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    stack&lt;TreeNode*&gt; node;</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">NULL</span> || !node.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (; root != <span class="literal">NULL</span>; root = root-&gt;left) &#123;</span><br><span class="line">            node.<span class="built_in">push</span>(root);</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">push_back</span>(node.<span class="built_in">top</span>()-&gt;val);</span><br><span class="line">        root = node.<span class="built_in">top</span>()-&gt;right;</span><br><span class="line">        node.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a>验证二叉搜索树</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 验证二叉搜索树</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    stack&lt;TreeNode*&gt; stack;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> inorder = INT32_MIN - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">NULL</span> || !stack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (; root != <span class="literal">NULL</span>; root = root-&gt;left)</span><br><span class="line">            stack.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">if</span> (stack.<span class="built_in">top</span>()-&gt;val &lt;= inorder)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        inorder = stack.<span class="built_in">top</span>()-&gt;val;</span><br><span class="line">        root = stack.<span class="built_in">top</span>()-&gt;right;</span><br><span class="line">        stack.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="二叉树的第k大节点"><a href="#二叉树的第k大节点" class="headerlink" title="二叉树的第k大节点"></a>二叉树的第k大节点</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">kthLargest</span><span class="params">(TreeNode* root, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    stack&lt;TreeNode*&gt; node;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">NULL</span> || !node.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (; root != <span class="literal">NULL</span>; root = root-&gt;right) &#123;</span><br><span class="line">            node.<span class="built_in">push</span>(root);</span><br><span class="line">        &#125;</span><br><span class="line">        root = node.<span class="built_in">top</span>()-&gt;left;</span><br><span class="line">        <span class="keyword">if</span> (num == k)</span><br><span class="line">            <span class="keyword">return</span> node.<span class="built_in">top</span>()-&gt;val;</span><br><span class="line">        node.<span class="built_in">pop</span>();</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="二叉树前序遍历"><a href="#二叉树前序遍历" class="headerlink" title="二叉树前序遍历"></a>二叉树前序遍历</h4><p>递归方法<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">preorder</span><span class="params">(TreeNode* node, vector&lt;<span class="type">int</span>&gt; &amp;res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!node)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    res.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">    <span class="built_in">preorder</span>(node-&gt;left, res);</span><br><span class="line">    <span class="built_in">preorder</span>(node-&gt;right, res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 二叉树前序遍历</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="built_in">preorder</span>(root, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>非递归方法<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    stack&lt;TreeNode*&gt; node;</span><br><span class="line">    <span class="keyword">while</span> (root!=<span class="literal">NULL</span> || !node.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (; root!=<span class="literal">NULL</span>; root = root-&gt;left) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">            node.<span class="built_in">push</span>(root);</span><br><span class="line">        &#125;</span><br><span class="line">        root = node.<span class="built_in">top</span>()-&gt;right;</span><br><span class="line">        node.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="二叉树后序遍历"><a href="#二叉树后序遍历" class="headerlink" title="二叉树后序遍历"></a>二叉树后序遍历</h4><p>递归方法<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">postorder</span><span class="params">(TreeNode* node, vector&lt;<span class="type">int</span>&gt; &amp;res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!node)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">postorder</span>(node-&gt;left, res);</span><br><span class="line">    <span class="built_in">postorder</span>(node-&gt;right, res);</span><br><span class="line">    res.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二叉树后序遍历</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="built_in">postorder</span>(root, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>非递归方法<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    stack&lt;TreeNode*&gt; node;</span><br><span class="line">    TreeNode *cur = root;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">NULL</span> || !node.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">            node.<span class="built_in">push</span>(cur);</span><br><span class="line">            cur = cur-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = node.<span class="built_in">top</span>()-&gt;left;</span><br><span class="line">        node.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="二叉树层序遍历"><a href="#二叉树层序遍历" class="headerlink" title="二叉树层序遍历"></a>二叉树层序遍历</h4><p>递归方法<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">levelOrder</span><span class="params">(TreeNode* root, <span class="type">int</span> level, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (v.<span class="built_in">size</span>() &lt; level + <span class="number">1</span>)</span><br><span class="line">        v.<span class="built_in">resize</span>(level + <span class="number">1</span>);</span><br><span class="line">    v[level].<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">    <span class="built_in">levelOrder</span>(root-&gt;left, level<span class="number">+1</span>, v);</span><br><span class="line">    <span class="built_in">levelOrder</span>(root-&gt;right, level<span class="number">+1</span>, v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 二叉树的层序遍历</span></span><br><span class="line">vector&lt;vector &lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">    vector&lt;vector &lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="built_in">levelOrder</span>(root, <span class="number">0</span>, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>非递归<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;vector &lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">    vector&lt;vector &lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    queue&lt;TreeNode*&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="type">int</span> level = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line">        res.<span class="built_in">push_back</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            TreeNode* temp = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            res[level].<span class="built_in">push_back</span>(temp-&gt;val);</span><br><span class="line">            <span class="keyword">if</span> (temp-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">                q.<span class="built_in">push</span>(temp-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (temp-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">                q.<span class="built_in">push</span>(temp-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        ++level;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="二叉树的锯齿形层次遍历"><a href="#二叉树的锯齿形层次遍历" class="headerlink" title="二叉树的锯齿形层次遍历"></a>二叉树的锯齿形层次遍历</h4><p>递归<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">zigzagLevel</span><span class="params">(TreeNode* node, <span class="type">int</span> level, vector&lt;vector &lt;<span class="type">int</span>&gt;&gt; &amp;res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (res.<span class="built_in">size</span>() &lt; level + <span class="number">1</span>)</span><br><span class="line">        res.<span class="built_in">push_back</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    <span class="keyword">if</span> (level % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        res[level].<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        res[level].<span class="built_in">insert</span>(res[level].<span class="built_in">begin</span>(), node-&gt;val);</span><br><span class="line">    <span class="built_in">zigzagLevel</span>(node-&gt;left, level<span class="number">+1</span>, res);</span><br><span class="line">    <span class="built_in">zigzagLevel</span>(node-&gt;right, level<span class="number">+1</span>, res);    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 二叉树的锯齿形层次遍历</span></span><br><span class="line">vector&lt;vector &lt;<span class="type">int</span>&gt;&gt; <span class="built_in">zigzagLevelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">    vector&lt;vector &lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="built_in">zigzagLevel</span>(root, <span class="number">0</span>, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>非递归<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;vector &lt;<span class="type">int</span>&gt;&gt; <span class="built_in">zigzagLevelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">    vector&lt;vector &lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    queue&lt;TreeNode*&gt; q;</span><br><span class="line">    <span class="type">int</span> level = <span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line">        res.<span class="built_in">push_back</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            TreeNode* temp = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (level % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">                res[level].<span class="built_in">push_back</span>(temp-&gt;val);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                res[level].<span class="built_in">insert</span>(res[level].<span class="built_in">begin</span>(), temp-&gt;val);</span><br><span class="line">            <span class="keyword">if</span> (temp-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">                q.<span class="built_in">push</span>(temp-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (temp-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">                q.<span class="built_in">push</span>(temp-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        ++level;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="二叉树的层次遍历2"><a href="#二叉树的层次遍历2" class="headerlink" title="二叉树的层次遍历2"></a>二叉树的层次遍历2</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrderBottom</span>(TreeNode* root) &#123;</span><br><span class="line">    vector&lt;vector &lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    queue&lt;TreeNode*&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; temp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            TreeNode* node = q.<span class="built_in">front</span>();</span><br><span class="line">            temp.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">                q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">                q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="二叉树的右视图"><a href="#二叉树的右视图" class="headerlink" title="二叉树的右视图"></a>二叉树的右视图</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 二叉树的右视图</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightSideView</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    queue&lt;TreeNode*&gt; node;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    node.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (!node.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> size = node.<span class="built_in">size</span>();</span><br><span class="line">        TreeNode* temp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            temp = node.<span class="built_in">front</span>();</span><br><span class="line">            node.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (temp-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">                node.<span class="built_in">push</span>(temp-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (temp-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">                node.<span class="built_in">push</span>(temp-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">push_back</span>(temp-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h4><p>递归<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>+<span class="built_in">max</span>(<span class="built_in">maxDepth</span>(root-&gt;left), <span class="built_in">maxDepth</span>(root-&gt;right));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>非递归<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    queue&lt;TreeNode*&gt; q;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="type">int</span> level = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (q.<span class="built_in">front</span>()-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">                q.<span class="built_in">push</span>(q.<span class="built_in">front</span>()-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (q.<span class="built_in">front</span>()-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">                q.<span class="built_in">push</span>(q.<span class="built_in">front</span>()-&gt;right);</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        ++level;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> level;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="二叉树的最近公共组先"><a href="#二叉树的最近公共组先" class="headerlink" title="二叉树的最近公共组先"></a>二叉树的最近公共组先</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span> || root == p || root == q)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    TreeNode* left = <span class="built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);</span><br><span class="line">    TreeNode* right = <span class="built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (left == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    <span class="keyword">if</span> (right == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    <span class="keyword">if</span> (left &amp;&amp; right)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h4><p>暴力破解<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetTreeDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">max</span>(<span class="built_in">GetTreeDepth</span>(root-&gt;left), <span class="built_in">GetTreeDepth</span>(root-&gt;right));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 平衡二叉树</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">abs</span>(<span class="built_in">GetTreeDepth</span>(root-&gt;left) - <span class="built_in">GetTreeDepth</span>(root-&gt;right)) &gt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">isBalanced</span>(root-&gt;left) &amp;&amp; <span class="built_in">isBalanced</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">recur</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> left = <span class="built_in">recur</span>(node-&gt;left);</span><br><span class="line">    <span class="keyword">if</span> (left == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> right = <span class="built_in">recur</span>(node-&gt;right);</span><br><span class="line">    <span class="keyword">if</span> (right == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(left-right) &lt; <span class="number">2</span> ? <span class="built_in">max</span>(left, right) + <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">recur</span>(root) != <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="二叉搜索树的插入操作"><a href="#二叉搜索树的插入操作" class="headerlink" title="二叉搜索树的插入操作"></a>二叉搜索树的插入操作</h4><p>递归<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">insertIntoBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val &gt; val)</span><br><span class="line">        root-&gt;left = <span class="built_in">insertIntoBST</span>(root-&gt;left, val);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        root-&gt;right = <span class="built_in">insertIntoBST</span>(root-&gt;right, val);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>迭代<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">insertIntoBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    TreeNode* node = root;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;val &gt; val) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">                node = node-&gt;left;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                node-&gt;left = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node-&gt;val &lt; val)&#123;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">                node = node-&gt;right;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                node-&gt;right = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="恢复二叉搜索树"><a href="#恢复二叉搜索树" class="headerlink" title="恢复二叉搜索树"></a><a href="https://leetcode-cn.com/problems/recover-binary-search-tree/submissions/">恢复二叉搜索树</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    stack&lt;TreeNode*&gt; node;</span><br><span class="line">    vector&lt;TreeNode*&gt; num;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; swap;</span><br><span class="line">    TreeNode* head = root;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="literal">NULL</span> || !node.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (; head != <span class="literal">NULL</span>; head = head-&gt;left)</span><br><span class="line">            node.<span class="built_in">push</span>(head);</span><br><span class="line">        num.<span class="built_in">push_back</span>(node.<span class="built_in">top</span>());</span><br><span class="line">        head = node.<span class="built_in">top</span>()-&gt;right;</span><br><span class="line">        node.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num.<span class="built_in">size</span>() - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num[i]-&gt;val &gt; num[i<span class="number">+1</span>]-&gt;val)</span><br><span class="line">            swap.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (swap.<span class="built_in">size</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> temp = num[swap[<span class="number">0</span>]]-&gt;val;</span><br><span class="line">        num[swap[<span class="number">0</span>]]-&gt;val = num[swap[<span class="number">0</span>]<span class="number">+1</span>]-&gt;val;</span><br><span class="line">        num[swap[<span class="number">0</span>]<span class="number">+1</span>]-&gt;val = temp;     </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> temp = num[swap[<span class="number">0</span>]]-&gt;val;</span><br><span class="line">        num[swap[<span class="number">0</span>]]-&gt;val = num[swap[<span class="number">1</span>]<span class="number">+1</span>]-&gt;val;</span><br><span class="line">        num[swap[<span class="number">1</span>]<span class="number">+1</span>]-&gt;val = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="不同的二叉搜索树2"><a href="#不同的二叉搜索树2" class="headerlink" title="不同的二叉搜索树2"></a>不同的二叉搜索树2</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;TreeNode*&gt; <span class="title">generateTrees</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    vector&lt;TreeNode*&gt; ans;</span><br><span class="line">    <span class="keyword">if</span> (start &gt; n) <span class="keyword">return</span> &#123;<span class="literal">NULL</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> left : <span class="built_in">generateTrees</span>(start, i - <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> right : <span class="built_in">generateTrees</span>(i<span class="number">+1</span>, n)) &#123;</span><br><span class="line">                TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(i, left, right);</span><br><span class="line">                ans.<span class="built_in">push_back</span>(root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;TreeNode*&gt; <span class="title">generateTrees</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">generateTrees</span>(<span class="number">1</span>, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="二叉树的最大路径和"><a href="#二叉树的最大路径和" class="headerlink" title="二叉树的最大路径和"></a>二叉树的最大路径和</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉树的最大路径和</span></span><br><span class="line"><span class="comment"> * @param root</span></span><br><span class="line"><span class="comment"> * @param sum</span></span><br><span class="line"><span class="comment"> * @return ret 当前结点最大路径和</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root, <span class="type">int</span> &amp;sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 左结点最大路径和</span></span><br><span class="line">    <span class="type">int</span> left = <span class="built_in">max</span>(<span class="built_in">maxPathSum</span>(root-&gt;left, sum), <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 右节点最大路径和</span></span><br><span class="line">    <span class="type">int</span> right = <span class="built_in">max</span>(<span class="built_in">maxPathSum</span>(root-&gt;right, sum), <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 左节点+右节点+当前节点的路径和</span></span><br><span class="line">    <span class="type">int</span> lmr = root-&gt;val + left + right;</span><br><span class="line">    sum = <span class="built_in">max</span>(sum, lmr);</span><br><span class="line">    <span class="comment">// 返回当前节点可以连接父节点的最大值</span></span><br><span class="line">    <span class="keyword">return</span> root-&gt;val + <span class="built_in">max</span>(left, right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> val = INT8_MIN;</span><br><span class="line">    <span class="built_in">maxPathSum</span>(root, val);</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="数的子结构"><a href="#数的子结构" class="headerlink" title="数的子结构"></a>数的子结构</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">recur</span><span class="params">(TreeNode* A, TreeNode* B)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (B == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (A == <span class="literal">NULL</span> || A-&gt;val != B-&gt;val)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">recur</span>(A-&gt;left, B-&gt;left) &amp;&amp; <span class="built_in">recur</span>(A-&gt;right, B-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isSubStructure</span><span class="params">(TreeNode* A, TreeNode* B)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A == <span class="literal">NULL</span> || B == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">bool</span> root = <span class="built_in">recur</span>(A, B);</span><br><span class="line">    <span class="type">bool</span> left = <span class="built_in">isSubStructure</span>(A-&gt;left, B);</span><br><span class="line">    <span class="type">bool</span> right = <span class="built_in">isSubStructure</span>(A-&gt;right, B);</span><br><span class="line">    <span class="keyword">return</span> root || left || right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* left, TreeNode* right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left == <span class="literal">NULL</span> &amp;&amp; right == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (left == <span class="literal">NULL</span> || right == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (left-&gt;val != right-&gt;val)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">isSymmetric</span>(left-&gt;left, right-&gt;right) &amp;&amp; <span class="built_in">isSymmetric</span>(left-&gt;right, right-&gt;left);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">isSymmetric</span>(root-&gt;left, root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="二叉树中和为某一值的路径"><a href="#二叉树中和为某一值的路径" class="headerlink" title="二叉树中和为某一值的路径"></a>二叉树中和为某一值的路径</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pathSum</span><span class="params">(TreeNode* root, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; res, vector&lt;<span class="type">int</span>&gt;&amp; temp, <span class="type">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    temp.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val == sum &amp;&amp; root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">        res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">    <span class="built_in">pathSum</span>(root-&gt;left, res, temp, sum-root-&gt;val);</span><br><span class="line">    <span class="built_in">pathSum</span>(root-&gt;right, res, temp, sum-root-&gt;val);</span><br><span class="line">    temp.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">pathSum</span>(TreeNode* root, <span class="type">int</span> sum) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; tmp;</span><br><span class="line">    <span class="built_in">pathSum</span>(root, res, tmp, sum);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="二叉树与双向链表"><a href="#二叉树与双向链表" class="headerlink" title="二叉树与双向链表"></a>二叉树与双向链表</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">treeToDoublyList</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(root);</span><br><span class="line">        head-&gt;left = pre;</span><br><span class="line">        pre-&gt;right = head;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Node *pre, *head;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(Node* cur)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(cur-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="literal">NULL</span>) pre-&gt;right = cur;</span><br><span class="line">        <span class="keyword">else</span> head = cur;</span><br><span class="line">        cur-&gt;left = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        <span class="built_in">dfs</span>(cur-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="图结构"><a href="#图结构" class="headerlink" title="图结构"></a>图结构</h3><p>图结构中数据元素之间存在着“多对多”的关系。</p>
<h4 id="广度优先"><a href="#广度优先" class="headerlink" title="广度优先"></a>广度优先</h4><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><h4 id="数据流中的中位数"><a href="#数据流中的中位数" class="headerlink" title="数据流中的中位数"></a>数据流中的中位数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MedianFinder</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MedianFinder</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addNum</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (A.<span class="built_in">size</span>() != B.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            A.<span class="built_in">push</span>(num);</span><br><span class="line">            B.<span class="built_in">push</span>(A.<span class="built_in">top</span>());</span><br><span class="line">            A.<span class="built_in">pop</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            B.<span class="built_in">push</span>(num);</span><br><span class="line">            A.<span class="built_in">push</span>(B.<span class="built_in">top</span>());</span><br><span class="line">            B.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> A.<span class="built_in">size</span>() != B.<span class="built_in">size</span>() ? A.<span class="built_in">top</span>() : (A.<span class="built_in">top</span>() + B.<span class="built_in">top</span>()) / <span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; A;</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, less&lt;<span class="type">int</span>&gt;&gt; B;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="查找和排序"><a href="#查找和排序" class="headerlink" title="查找和排序"></a>查找和排序</h3><p>二分查找框架</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">binarySearch</span><span class="params">(vector&lt;<span class="type">int</span>&gt; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = ...;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(...) &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="在排序数组中查找元素的第一个和最后一个位置"><a href="#在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="在排序数组中查找元素的第一个和最后一个位置"></a>在排序数组中查找元素的第一个和最后一个位置</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt;= target) right = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> left = mid + <span class="number">1</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= nums.<span class="built_in">size</span>() || nums[left] != target) res.<span class="built_in">push_back</span>(<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">else</span> res.<span class="built_in">push_back</span>(left);</span><br><span class="line"></span><br><span class="line">    right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt;= target) left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> right = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (right &lt; <span class="number">0</span> || nums[right] != target) res.<span class="built_in">push_back</span>(<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">else</span> res.<span class="built_in">push_back</span>(right);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(Student *stu, <span class="type">int</span> n, <span class="type">int</span>  key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (stu[i].id == key)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 折半查找</span></span><br><span class="line"><span class="comment"> * @param key 关键字顺序表</span></span><br><span class="line"><span class="comment"> * @param n 记录个数</span></span><br><span class="line"><span class="comment"> * @param k 要查找的关键字</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bin_search</span><span class="params">(<span class="type">int</span> *key, <span class="type">int</span> n, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> low = <span class="number">0</span>, high = n - <span class="number">1</span>, mid;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (key[mid] == k)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">if</span> (k &gt; key[mid])</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (k &lt; key[mid])</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请实现有重复数字的有序数组的二分查找。<br>输出在数组中第一个大于等于查找值的位置，如果数组中不存在这样的数，则输出数组长度加一。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">bin_search</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> v, vector&lt;<span class="type">int</span>&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> right = n - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[mid] &gt;= v) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mid == <span class="number">0</span> || a[mid<span class="number">-1</span>] &lt; v)</span><br><span class="line">                <span class="keyword">return</span> mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 直接插入排序</span></span><br><span class="line"><span class="comment"> * @param arr 数组</span></span><br><span class="line"><span class="comment"> * @param n 数组元素个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> temp = arr[i];</span><br><span class="line">        <span class="type">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// for (j; j &gt;= 0; --j) &#123;</span></span><br><span class="line">        <span class="comment">//     if (temp &lt; arr[j]) &#123;</span></span><br><span class="line">        <span class="comment">//         arr[j + 1] = arr[j];</span></span><br><span class="line">        <span class="comment">//     &#125; else &#123;</span></span><br><span class="line">        <span class="comment">//         break;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// arr[j + 1] = temp;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; temp &lt; arr[j]) &#123;</span><br><span class="line">            arr[j<span class="number">+1</span>] = arr[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j<span class="number">+1</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 选择排序</span></span><br><span class="line"><span class="comment"> * @param arr 数组</span></span><br><span class="line"><span class="comment"> * @param n 数组元素个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">selectSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> min = i, temp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[min])</span><br><span class="line">                min = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (min != i) &#123;</span><br><span class="line">            temp = arr[min];</span><br><span class="line">            arr[min] = arr[i];</span><br><span class="line">            arr[i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 冒泡排序</span></span><br><span class="line"><span class="comment"> * 添加标志变量flag，进行交换flag为真，可以进入下一循环，为进行交换flag为假（数据已有序，无须再进行交换）循环终止。</span></span><br><span class="line"><span class="comment"> * @param arr 数组</span></span><br><span class="line"><span class="comment"> * @param n 数组元素个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n &amp;&amp; flag; ++i) &#123;</span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="type">int</span> temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 希尔排序</span></span><br><span class="line"><span class="comment"> * 使用do-while是因为flag为2时已经有序，但是flag为1时不是有序的。</span></span><br><span class="line"><span class="comment"> * @param arr 数组</span></span><br><span class="line"><span class="comment"> * @param n 数组元素个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shellSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j, gap = n;</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    <span class="keyword">while</span>(gap &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        gap = gap / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n - gap; ++i) &#123;</span><br><span class="line">                j = i + gap;</span><br><span class="line">                <span class="keyword">if</span> (arr[i] &gt; arr[j]) &#123;</span><br><span class="line">                    temp = arr[i];</span><br><span class="line">                    arr[i] = arr[j];</span><br><span class="line">                    arr[j] = temp;</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span>(flag);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> &amp;a, <span class="type">int</span> &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt;= end)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> left = start, right = end, key = arr[start];</span><br><span class="line">    <span class="comment">// 进行循环，将小于基准元素的元素放到左边，大于基准元素的元素放到右边</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right &amp;&amp; arr[right] &gt;= key)</span><br><span class="line">            right--;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right &amp;&amp; arr[left] &lt;= key)</span><br><span class="line">            left++;</span><br><span class="line">        <span class="built_in">swap</span>(arr[left], arr[right]);</span><br><span class="line">        <span class="comment">// for (int i = 0; i &lt; 10; ++i) &#123;</span></span><br><span class="line">        <span class="comment">//     cout &lt;&lt; arr[i] &lt;&lt; &#x27; &#x27;;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// cout &lt;&lt; endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 交换基准元素与left的位置，循环中先从右开始，因此left和right相等的位置为小于基准元素的值</span></span><br><span class="line">    <span class="built_in">swap</span>(arr[start], arr[left]);</span><br><span class="line">    <span class="built_in">quick</span>(arr, start, left - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">quick</span>(arr, left + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 快速排序</span></span><br><span class="line"><span class="comment"> * @param arr 数组</span></span><br><span class="line"><span class="comment"> * @param n 数组元素个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">quick</span>(arr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>循环实现<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Partition</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start == end)</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    <span class="type">int</span> left = start, right = end, key = arr[start];</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; arr[right] &gt;= key)</span><br><span class="line">            right--;</span><br><span class="line">        arr[left] = arr[right];</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; arr[left] &lt;= key)</span><br><span class="line">            left++;</span><br><span class="line">        arr[right] = arr[left];</span><br><span class="line">    &#125;</span><br><span class="line">    arr[left] = key;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 非递归实现快排</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort2</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">    st.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">    st.<span class="built_in">push</span>(n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> right = st.<span class="built_in">top</span>();</span><br><span class="line">        st.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> left = st.<span class="built_in">top</span>();</span><br><span class="line">        st.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> mid = <span class="built_in">Partition</span>(arr, left, right);</span><br><span class="line">        <span class="keyword">if</span> (mid - <span class="number">1</span> &gt; left) &#123;</span><br><span class="line">            st.<span class="built_in">push</span>(left);</span><br><span class="line">            st.<span class="built_in">push</span>(mid - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mid + <span class="number">1</span> &lt; right) &#123;</span><br><span class="line">            st.<span class="built_in">push</span>(mid + <span class="number">1</span>);</span><br><span class="line">            st.<span class="built_in">push</span>(right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a><a href="https://www.cnblogs.com/chengxiao/p/6129630.html">堆排序</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 调整大顶堆</span></span><br><span class="line"><span class="comment"> * @param arr</span></span><br><span class="line"><span class="comment"> * @param i</span></span><br><span class="line"><span class="comment"> * @param len</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">adjust</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> i, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = arr[i];</span><br><span class="line">    <span class="comment">// 从i结点的左子结点开始，也就是2i+1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">2</span> * i + <span class="number">1</span>; k &lt; len; k = k * <span class="number">2</span> + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果左子结点小于右子结点，k指向右子结点</span></span><br><span class="line">        <span class="keyword">if</span> (k + <span class="number">1</span> &lt; len &amp;&amp; arr[k] &lt; arr[k + <span class="number">1</span>])</span><br><span class="line">            k++;</span><br><span class="line">        <span class="comment">// 如果子结点大于父节点，将子结点的值赋给父节点</span></span><br><span class="line">        <span class="keyword">if</span> (arr[k] &gt; temp) &#123;</span><br><span class="line">            arr[i] = arr[k];</span><br><span class="line">            i = k;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[i] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 堆排序</span></span><br><span class="line"><span class="comment"> * @param arr 数组</span></span><br><span class="line"><span class="comment"> * @param n 数组元素个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">headSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i, temp;</span><br><span class="line">    <span class="comment">// 1.构建大顶堆</span></span><br><span class="line">    <span class="keyword">for</span> (i = n / <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="comment">// 从第一个非叶子结点从下至上，从右至左调整结构</span></span><br><span class="line">        <span class="built_in">adjust</span>(arr, i, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.调整堆结构并交换堆顶元素与末尾元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = n - <span class="number">1</span>; j &gt; <span class="number">0</span>; --j) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(arr[<span class="number">0</span>], arr[j]);</span><br><span class="line">        <span class="built_in">adjust</span>(arr, <span class="number">0</span>, j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 归并排序</span></span><br><span class="line"><span class="comment"> * @param arr 数组</span></span><br><span class="line"><span class="comment"> * @param n 数组元素个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MergeSort</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MergeSort</span>(vector&lt;<span class="type">int</span>&gt;&amp; arr) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(arr, <span class="number">0</span>, arr.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">MergeSort</span>();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> start, <span class="type">int</span> mid, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">left</span><span class="params">(arr.begin()+start, arr.begin()+mid<span class="number">+1</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">right</span><span class="params">(arr.begin()+mid<span class="number">+1</span>, arr.begin()+end<span class="number">+1</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> cur = start;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; left.<span class="built_in">size</span>(), j &lt; right.<span class="built_in">size</span>();) &#123;</span><br><span class="line">            <span class="keyword">if</span> (left[i] &lt; right[j]) &#123;</span><br><span class="line">                arr[cur++] = left[i++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                arr[cur++] = right[j++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i == left.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">for</span> (j; j &lt; right.<span class="built_in">size</span>();++j) arr[cur++] = right[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == right.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">for</span> (i; i &lt; left.<span class="built_in">size</span>();++i) arr[cur++] = left[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt;= end) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">sort</span>(arr, start, mid);</span><br><span class="line">        <span class="built_in">sort</span>(arr, mid<span class="number">+1</span>, end);</span><br><span class="line">        <span class="built_in">merge</span>(arr, start, mid, end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="矩阵中的路径"><a href="#矩阵中的路径" class="headerlink" title="矩阵中的路径"></a>矩阵中的路径</h4><p>DFS用栈维护， BFS用队列维护<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, string&amp; word, <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= board.<span class="built_in">size</span>() || j &gt;= board[<span class="number">0</span>].<span class="built_in">size</span>() || i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || board[i][j] != word[k])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (k == word.<span class="built_in">size</span>() - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="type">char</span> temp = board[i][j];</span><br><span class="line">    board[i][j] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">dfs</span>(board, word, i<span class="number">+1</span>, j, k<span class="number">+1</span>) || <span class="built_in">dfs</span>(board, word, i<span class="number">-1</span>, j, k<span class="number">+1</span>) ||</span><br><span class="line">        <span class="built_in">dfs</span>(board, word, i, j<span class="number">+1</span>, k<span class="number">+1</span>) || <span class="built_in">dfs</span>(board, word, i, j<span class="number">-1</span>, k<span class="number">+1</span>) )</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    board[i][j] = temp;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">exist</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, string word)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; board.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].<span class="built_in">size</span>(); ++j)</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">dfs</span>(board, word, i, j, <span class="number">0</span>)) </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="把数组排成最小的数"><a href="#把数组排成最小的数" class="headerlink" title="把数组排成最小的数"></a>把数组排成最小的数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">minNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">    string res;</span><br><span class="line">    vector&lt;string&gt; strs;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> a:nums) &#123;</span><br><span class="line">        strs.<span class="built_in">push_back</span>(<span class="built_in">to_string</span>(a));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(strs.<span class="built_in">begin</span>(), strs.<span class="built_in">end</span>(), [](string &amp;x, string &amp;y) &#123;<span class="keyword">return</span> x+y &lt; y+x;&#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> a:strs) &#123;</span><br><span class="line">        res += a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="扑克牌中的顺子"><a href="#扑克牌中的顺子" class="headerlink" title="扑克牌中的顺子"></a>扑克牌中的顺子</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isStraight</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>()<span class="number">-1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            flag++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[i]<span class="number">+1</span> == nums[i<span class="number">+1</span>])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] == nums[i<span class="number">+1</span>])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            flag -= nums[i<span class="number">+1</span>] - nums[i] - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isStraight</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">    unordered_set&lt;<span class="type">int</span>&gt; repeat;</span><br><span class="line">    <span class="type">int</span> maxNum = <span class="number">0</span>, minNum = <span class="number">14</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num:nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        maxNum = <span class="built_in">max</span>(maxNum, num);</span><br><span class="line">        minNum = <span class="built_in">min</span>(minNum, num);</span><br><span class="line">        <span class="keyword">if</span> (repeat.<span class="built_in">find</span>(num) != repeat.<span class="built_in">end</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        repeat.<span class="built_in">insert</span>(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxNum - minNum &lt; <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="数组中重复的数字-1"><a href="#数组中重复的数字-1" class="headerlink" title="数组中重复的数字"></a>数组中重复的数字</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">findRepeatNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    unordered_set&lt;<span class="type">int</span>&gt; repeat;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num:nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (repeat.<span class="built_in">find</span>(num) != repeat.<span class="built_in">end</span>()) <span class="keyword">return</span> num;</span><br><span class="line">        repeat.<span class="built_in">insert</span>(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">findRepeatNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span> , <span class="type">bool</span>&gt; map;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map[num]) <span class="keyword">return</span> num;</span><br><span class="line">        map[num] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="二维数组中的查找"><a href="#二维数组中的查找" class="headerlink" title="二维数组中的查找"></a>二维数组中的查找</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">findNumberIn2DArray</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;matrix, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = matrix.<span class="built_in">size</span>() - <span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;=<span class="number">0</span> &amp;&amp; j &lt; matrix[<span class="number">0</span>].<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix[i][j] == target)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (matrix[i][j] &gt; target)</span><br><span class="line">            i--;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="旋转数组的最小数字"><a href="#旋转数组的最小数字" class="headerlink" title="旋转数组的最小数字"></a>旋转数组的最小数字</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;numbers)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> end = numbers.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (end + start) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (numbers[mid] &lt; numbers[end]) &#123;</span><br><span class="line">            end = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (numbers[mid] &gt; numbers[end])&#123;</span><br><span class="line">            start = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numbers[start];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="第一个只出现一次的数字"><a href="#第一个只出现一次的数字" class="headerlink" title="第一个只出现一次的数字"></a>第一个只出现一次的数字</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> <span class="title">firstUniqChar</span><span class="params">(string s)</span>  </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">bool</span>&gt; dic;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> a : s)</span><br><span class="line">        dic[a] = dic.<span class="built_in">find</span>(a) == dic.<span class="built_in">end</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : s)</span><br><span class="line">        <span class="keyword">if</span> (dic[c]) <span class="keyword">return</span> c;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> <span class="title">firstUniqChar</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">char</span>&gt; keys;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">bool</span>&gt; dic;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : s) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dic.<span class="built_in">find</span>(c) == dic.<span class="built_in">end</span>())</span><br><span class="line">            keys.<span class="built_in">push_back</span>(c);</span><br><span class="line">        dic[c] = dic.<span class="built_in">find</span>(c) == dic.<span class="built_in">end</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : keys) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dic[c]) <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="在排序数组中查找数字"><a href="#在排序数组中查找数字" class="headerlink" title="在排序数组中查找数字"></a>在排序数组中查找数字</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (i + j) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt;= target) i = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> j = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> right = i;</span><br><span class="line">    <span class="keyword">if</span> (j &gt;= <span class="number">0</span> &amp;&amp; nums[j] != target) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    i = <span class="number">0</span>, j = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (i + j) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target) i = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> j = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> left = j;</span><br><span class="line">    <span class="keyword">return</span> right - left - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="0-n-1中缺失的数字"><a href="#0-n-1中缺失的数字" class="headerlink" title="0~n-1中缺失的数字"></a>0~n-1中缺失的数字</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">missingNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> start = <span class="number">0</span>, end = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; mid) end = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> start = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> start<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h3><p>算法框架<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = []</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">路径, 选择列表</span>):</span><br><span class="line">    <span class="keyword">if</span> 满足结束条件:</span><br><span class="line">        result.add(路径)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表:</span><br><span class="line">        做选择</span><br><span class="line">        backtrack(路径, 选择列表)</span><br><span class="line">        撤销选择</span><br></pre></td></tr></table></figure></p>
<h4 id="四皇后问题"><a href="#四皇后问题" class="headerlink" title="四皇后问题"></a>四皇后问题</h4><p>在一个4×4的国际象棋棋盘上，一次一个地摆放4枚皇后棋子，摆好后满足每行、每列和对角线上只允许出现一枚棋子，即棋子间不许相互俘获。</p>
<p>解决策略：</p>
<ol>
<li>初始化一个4x4的数组Q，Q[i][j]=1表示该点有皇后，无皇后的点置为0。</li>
<li>遍历每一行，使用isCorrect判断当前点是否可以放置皇后，可以放置后使用递归将皇后数量+1</li>
<li>确定四个皇后之后将上个确定的皇后置为0进行回溯，继续执行循环。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断皇后是否可以放置到[i][j]</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isCorrect</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> (*QueenArray)[<span class="number">4</span>])</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> s, t;</span><br><span class="line">    <span class="comment">// 判断行</span></span><br><span class="line">    <span class="keyword">for</span> (s = i, t = <span class="number">0</span>; t &lt; <span class="number">4</span>; ++t)</span><br><span class="line">        <span class="keyword">if</span> (QueenArray[s][t] == <span class="number">1</span> &amp;&amp; t != j)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 判断列</span></span><br><span class="line">    <span class="keyword">for</span> (s = <span class="number">0</span>, t = j; s &lt; <span class="number">4</span>; ++s)</span><br><span class="line">        <span class="keyword">if</span> (QueenArray[s][t] == <span class="number">1</span> &amp;&amp; s != i)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 判断左上</span></span><br><span class="line">    <span class="keyword">for</span> (s = i - <span class="number">1</span>, t = j - <span class="number">1</span>; s &gt;= <span class="number">0</span> &amp;&amp; t &gt;= <span class="number">0</span>; s--, t--)</span><br><span class="line">        <span class="keyword">if</span> (QueenArray[s][t] == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 判读右上</span></span><br><span class="line">    <span class="keyword">for</span> (s = i - <span class="number">1</span>, t = j + <span class="number">1</span>; s &gt;= <span class="number">0</span> &amp;&amp; t &lt; <span class="number">4</span>; s--, t++)</span><br><span class="line">        <span class="keyword">if</span> (QueenArray[s][t] == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 判断左下</span></span><br><span class="line">    <span class="keyword">for</span> (s = i + <span class="number">1</span>, t = j - <span class="number">1</span>; s &lt; <span class="number">4</span> &amp;&amp; t &gt;= <span class="number">0</span>; s++, t--)</span><br><span class="line">        <span class="keyword">if</span> (QueenArray[s][t] == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 判读右下</span></span><br><span class="line">    <span class="keyword">for</span> (s = i + <span class="number">1</span>, t = j + <span class="number">1</span>; s &lt; <span class="number">4</span> &amp;&amp; t &lt; <span class="number">4</span>; s++, t++)</span><br><span class="line">        <span class="keyword">if</span> (QueenArray[s][t] == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 回溯法解决4皇后问题</span></span><br><span class="line"><span class="comment"> * @param queenNum 当前皇后数量</span></span><br><span class="line"><span class="comment"> * @param QueenArray 皇后数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Queen</span><span class="params">(<span class="type">int</span> queenNum, <span class="type">int</span> (*QueenArray)[<span class="number">4</span>])</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i, k;</span><br><span class="line">    <span class="comment">// 四个皇后都确定</span></span><br><span class="line">    <span class="keyword">if</span> (queenNum == <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++)</span><br><span class="line">                cout &lt;&lt; QueenArray[i][k] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isCorrect</span>(i, queenNum, QueenArray)) &#123;</span><br><span class="line">            QueenArray[i][queenNum] = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">Queen</span>(queenNum<span class="number">+1</span>, QueenArray);</span><br><span class="line">            QueenArray[i][queenNum] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>算法框架</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"># 初始化 base <span class="keyword">case</span></span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>][...] = base</span><br><span class="line"># 进行状态转移</span><br><span class="line"><span class="keyword">for</span> 状态<span class="number">1</span> in 状态<span class="number">1</span>的所有取值：</span><br><span class="line">    <span class="keyword">for</span> 状态<span class="number">2</span> in 状态<span class="number">2</span>的所有取值：</span><br><span class="line">        <span class="keyword">for</span> ...</span><br><span class="line">            dp[状态<span class="number">1</span>][状态<span class="number">2</span>][...] = 求最值(选择<span class="number">1</span>，选择<span class="number">2.</span>..)</span><br></pre></td></tr></table></figure>
<h4 id="上台阶问题"><a href="#上台阶问题" class="headerlink" title="上台阶问题"></a>上台阶问题</h4><p>有一楼梯共m级，若每次只能跨上一级或二级，要走上第m级，共有多少走法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 上台阶问题</span></span><br><span class="line"><span class="comment"> * @param n 台阶数</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">UpStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">UpStairs</span>(n - <span class="number">1</span>) + <span class="built_in">UpStairs</span>(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用动态规划解决</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">UpStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> *dp = <span class="keyword">new</span> <span class="type">int</span>[n<span class="number">+1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; ++i)</span><br><span class="line">        dp[i] = dp[i<span class="number">-1</span>] + dp[i<span class="number">-2</span>]</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h4><p>已知两个字符串word1和word2，求从word1转化成word2最少需要几步。其中，每一步只能进行以下三个操作之一：</p>
<ul>
<li>插入一个字符</li>
<li>删除一个字符</li>
<li>替换一个字符</li>
</ul>
<p>解决策略：</p>
<ol>
<li>使用一个二维数组dp记录需要的操作数</li>
<li>dp[i][j]表示word1转化为word2需要的最小操作数，有两种状态，word1[i]==word2[j]和word1[i]!=word2[j]，<ul>
<li>word1[i] == word2[j]，则dp[i][j] = dp[i-1][j-1]，</li>
<li>word1[i] !=wrod2[j]，有三条路径：<ol>
<li>比如，”xyz” =&gt; “efg” 的最小编辑距离等于 “xy” =&gt; “efg” 的最小编辑距离 + 1（因为允许插入操作，插入一个 “z”），抽象的描述便是 d[m][n] === d[m-1][n] + 1。</li>
<li>比如，”xyz” =&gt; “efg” 的最小编辑距离等于 “xyzg” =&gt; “efg” 的最小编辑距离 + 1，且因为最后一个字符都是 “g”，根据第一个判断条件，可以再等于 “xyz” =&gt; “ef” 的最小编辑距离 + 1，因此，得到结论：”xyz” =&gt; “efg” 的最小编辑距离等于 “xyz” =&gt; “ef” 的最小编辑距离 + 1，抽象的描述便是：d[m][n] === d[m][n-1] + 1。</li>
<li>比如，”xyz” =&gt; “efg” 的最小编辑距离等于 “xyg” =&gt; “efg” 的最小编辑距离 + 1（因为允许替换操作，可以把 “g” 换成 “z”），再等于 “xy” =&gt; “ef” 的编辑距离 + 1（根据第一个判断条件），抽象的描述便是： d[m][n] === d[m-1][n-1] + 1。<br>上述三种情况都有可能出现，因此，取其中的最小值便是整体上的最小编辑距离。</li>
</ol>
</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 编辑距离</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">miniDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n1 = word<span class="number">1.</span><span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> n2 = word<span class="number">2.</span><span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// vector &lt;vector &lt;int&gt;&gt; dp[n1][n2];</span></span><br><span class="line">    <span class="comment">// 开辟空间</span></span><br><span class="line">    <span class="type">int</span> **dp = <span class="keyword">new</span> <span class="type">int</span>*[n1<span class="number">+1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n1; ++i)</span><br><span class="line">        dp[i] = <span class="keyword">new</span> <span class="type">int</span>[n2<span class="number">+1</span>]();</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n1; ++i)</span><br><span class="line">        dp[i<span class="number">+1</span>][<span class="number">0</span>] = dp[i][<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n2; ++i)</span><br><span class="line">        dp[<span class="number">0</span>][i<span class="number">+1</span>] = dp[<span class="number">0</span>][i] + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>  (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n1; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n2; ++j)</span><br><span class="line">            <span class="keyword">if</span> (word1[i<span class="number">-1</span>] == word2[j<span class="number">-1</span>])</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(<span class="built_in">min</span>(dp[i<span class="number">-1</span>][j<span class="number">-1</span>], dp[i<span class="number">-1</span>][j]), dp[i][j<span class="number">-1</span>]) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放空间</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n1; ++i)</span><br><span class="line">        <span class="keyword">delete</span>[] dp[i];</span><br><span class="line">    <span class="keyword">delete</span>[] dp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[n1][n2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h4><p><img src="/2020/08/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/最长公共子序列.jpeg" alt="最长公共子序列"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string text1, string text2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (text<span class="number">1.</span><span class="built_in">empty</span>() || text<span class="number">2.</span><span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> m = text<span class="number">1.</span><span class="built_in">size</span>(), n = text<span class="number">2.</span><span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (text1[i<span class="number">-1</span>] == text2[j<span class="number">-1</span>])</span><br><span class="line">                dp[i][j] = <span class="number">1</span> + dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="最长回文子序列"><a href="#最长回文子序列" class="headerlink" title="最长回文子序列"></a>最长回文子序列</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(len<span class="number">+1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(len<span class="number">+1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; len; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == s[len<span class="number">-1</span>-j])</span><br><span class="line">                dp[i<span class="number">+1</span>][j<span class="number">+1</span>] = <span class="number">1</span> + dp[i][j];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i<span class="number">+1</span>][j<span class="number">+1</span>] = <span class="built_in">max</span>(dp[i][j<span class="number">+1</span>], dp[i<span class="number">+1</span>][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[len][len];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="完全平方数"><a href="#完全平方数" class="headerlink" title="完全平方数"></a>完全平方数</h4><p>递归<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minNumSquares</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> count = INT32_MAX;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i * i &lt;= n; ++i)</span><br><span class="line">        count = <span class="built_in">min</span>(count, <span class="built_in">minNumSquares</span>(n - i * i) + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 完全平方数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">numSquares</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">minNumSquares</span>(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>非递归<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">numSquares</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n<span class="number">+1</span>, n<span class="number">+1</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j * j &lt;= i; ++j)</span><br><span class="line">            dp[i] = <span class="built_in">min</span>(dp[i], dp[i-j*j] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="杨辉三角2"><a href="#杨辉三角2" class="headerlink" title="杨辉三角2"></a>杨辉三角2</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getRow</span><span class="params">(<span class="type">int</span> rowIndex)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(rowIndex<span class="number">+1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; rowIndex<span class="number">+1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i - <span class="number">1</span> ; j &gt; <span class="number">0</span>; j--)</span><br><span class="line">            res[j] = res[j<span class="number">-1</span>] + res[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="计算平方数"><a href="#计算平方数" class="headerlink" title="计算平方数"></a>计算平方数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">quickMul</span><span class="params">(<span class="type">double</span> x, <span class="type">long</span> <span class="type">long</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> ans = <span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">while</span> (N &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (N &amp; <span class="number">1</span> == <span class="number">1</span>)</span><br><span class="line">            ans *= x;</span><br><span class="line">        x *= x;</span><br><span class="line">        N = N &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">quickMul</span><span class="params">(<span class="type">double</span> x, <span class="type">long</span> <span class="type">long</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">    <span class="type">double</span> half = <span class="built_in">quickMul</span>(x, n / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> half * half;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> half * half * x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> N = n;</span><br><span class="line">    <span class="keyword">return</span> N &gt;= <span class="number">0</span> ? <span class="built_in">quickMul</span>(x, N) : <span class="number">1.0</span> / <span class="built_in">quickMul</span>(x, -N);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="第k个语法符号"><a href="#第k个语法符号" class="headerlink" title="第k个语法符号"></a>第k个语法符号</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">kthGrammar</span><span class="params">(<span class="type">int</span> N, <span class="type">int</span> K)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (N == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">kthGrammar</span>(N - <span class="number">1</span>, (K + <span class="number">1</span>) / <span class="number">2</span>) == <span class="number">0</span> ? (<span class="number">1</span> - (K % <span class="number">2</span>)) : (K % <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="礼物的最大价值"><a href="#礼物的最大价值" class="headerlink" title="礼物的最大价值"></a>礼物的最大价值</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxValue</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (grid.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> m = grid.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m<span class="number">+1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n<span class="number">+1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]) + grid[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="股票的最大利润"><a href="#股票的最大利润" class="headerlink" title="股票的最大利润"></a>股票的最大利润</h4><ul>
<li>一次购买<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> cost = INT32_MAX, profit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> price : prices) &#123;</span><br><span class="line">        cost = <span class="built_in">min</span>(cost, price);</span><br><span class="line">        profit = <span class="built_in">max</span>(profit, price-cost);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> profit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>买卖股票的最佳时机二</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> profit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prices[i] &gt; prices[i<span class="number">-1</span>])</span><br><span class="line">            profit += prices[i] - prices[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> profit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>买卖股票的最佳时机三</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> days = prices.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&gt; <span class="built_in">dp</span>(days, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(<span class="number">3</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>)));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; days; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i - <span class="number">1</span> == <span class="number">-1</span>) &#123;</span><br><span class="line">                dp[i][j][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                dp[i][j][<span class="number">1</span>] = -prices[i];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i][j][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                dp[i][j][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>][<span class="number">1</span>], dp[i<span class="number">-1</span>][<span class="number">0</span>][<span class="number">0</span>]-prices[i]);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i][j][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j][<span class="number">0</span>], dp[i<span class="number">-1</span>][j][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][j][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j][<span class="number">1</span>], dp[i<span class="number">-1</span>][j<span class="number">-1</span>][<span class="number">0</span>]-prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[days<span class="number">-1</span>][<span class="number">2</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>买卖股票的最佳时机四</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> dp_i_0 = <span class="number">0</span>, dp_i_1 = -prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> temp = dp_i_0;</span><br><span class="line">        dp_i_0 = <span class="built_in">max</span>(dp_i_0, dp_i_1 + prices[i]);</span><br><span class="line">        dp_i_1 = <span class="built_in">max</span>(dp_i_1, temp-prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp_i_0;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(<span class="type">int</span> k, vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> days = prices.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (k &gt; days/<span class="number">2</span>)</span><br><span class="line">        <span class="built_in">maxProfit</span>(prices);</span><br><span class="line">    vector&lt;vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&gt; <span class="built_in">dp</span>(days, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(k<span class="number">+1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>)));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; days; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= k; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i - <span class="number">1</span> == <span class="number">-1</span>) &#123;</span><br><span class="line">                dp[i][j][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                dp[i][j][<span class="number">1</span>] = -prices[i];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i][j][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                dp[i][j][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>][<span class="number">1</span>], dp[i<span class="number">-1</span>][<span class="number">0</span>][<span class="number">0</span>]-prices[i]);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i][j][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j][<span class="number">0</span>], dp[i<span class="number">-1</span>][j][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][j][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j][<span class="number">1</span>], dp[i<span class="number">-1</span>][j<span class="number">-1</span>][<span class="number">0</span>]-prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[days<span class="number">-1</span>][k][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a>打家劫舍</h4><ul>
<li>打家劫舍1</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> dp_i_1 = <span class="number">0</span>, dp_i_2 = <span class="number">0</span>, dp_i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        dp_i = <span class="built_in">max</span>(dp_i_1, dp_i_2 + nums[i]);</span><br><span class="line">        dp_i_2 = dp_i_1;</span><br><span class="line">        dp_i_1 = dp_i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp_i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>打家劫舍2</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">dp</span>(nums, <span class="number">0</span>, n<span class="number">-1</span>), <span class="built_in">dp</span>(nums, <span class="number">1</span>, n));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dp</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> start ,<span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> dp_i = <span class="number">0</span>, dp_i_1 = <span class="number">0</span>, dp_i_2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt; end; ++i) &#123;</span><br><span class="line">            dp_i = <span class="built_in">max</span>(dp_i_1, dp_i_2 + nums[i]);</span><br><span class="line">            dp_i_2 = dp_i_1;</span><br><span class="line">            dp_i_1 = dp_i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp_i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>打家劫舍3</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (memo.<span class="built_in">find</span>(root) != memo.<span class="built_in">end</span>()) <span class="keyword">return</span> memo[root];</span><br><span class="line">        <span class="type">int</span> do_it = root-&gt;val + (root-&gt;left == <span class="literal">NULL</span> ? <span class="number">0</span> : <span class="built_in">rob</span>(root-&gt;left-&gt;left)+<span class="built_in">rob</span>(root-&gt;left-&gt;right))</span><br><span class="line">                     + (root-&gt;right == <span class="literal">NULL</span> ? <span class="number">0</span> : <span class="built_in">rob</span>(root-&gt;right-&gt;left) + <span class="built_in">rob</span>(root-&gt;right-&gt;right));</span><br><span class="line">        <span class="type">int</span> not_do = <span class="built_in">rob</span>(root-&gt;left) + <span class="built_in">rob</span>(root-&gt;right);</span><br><span class="line">        <span class="type">int</span> res = <span class="built_in">max</span>(do_it, not_do);</span><br><span class="line">        memo[root] = res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;TreeNode*, <span class="type">int</span>&gt; memo;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><p>算法框架<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算从起点 start 到终点 target 的最近距离</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">BFS</span><span class="params">(Node start, Node target)</span> </span>&#123;</span><br><span class="line">    queue&lt;Node&gt; q; <span class="comment">// 核心数据结构</span></span><br><span class="line">    set&lt;Node&gt; visited; <span class="comment">// 避免走回头路</span></span><br><span class="line"></span><br><span class="line">    q.<span class="built_in">offer</span>(start); <span class="comment">// 将起点加入队列</span></span><br><span class="line">    visited.<span class="built_in">add</span>(start);</span><br><span class="line">    <span class="type">int</span> step = <span class="number">0</span>; <span class="comment">// 记录扩散的步数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q <span class="keyword">not</span> empty) &#123;</span><br><span class="line">        <span class="type">int</span> sz = q.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">/* 将当前队列中的所有节点向四周扩散 */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            Node cur = q.<span class="built_in">poll</span>();</span><br><span class="line">            <span class="comment">/* 划重点：这里判断是否到达终点 */</span></span><br><span class="line">            <span class="keyword">if</span> (cur is target)</span><br><span class="line">                <span class="keyword">return</span> step;</span><br><span class="line">            <span class="comment">/* 将 cur 的相邻节点加入队列 */</span></span><br><span class="line">            <span class="keyword">for</span> (Node x : cur.<span class="built_in">adj</span>())</span><br><span class="line">                <span class="keyword">if</span> (x <span class="keyword">not</span> in visited) &#123;</span><br><span class="line">                    q.<span class="built_in">offer</span>(x);</span><br><span class="line">                    visited.<span class="built_in">add</span>(x);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 划重点：更新步数在这里 */</span></span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="二叉树的最小深度"><a href="#二叉树的最小深度" class="headerlink" title="二叉树的最小深度"></a>二叉树的最小深度</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    queue&lt;TreeNode*&gt; nodes;</span><br><span class="line">    <span class="type">int</span> depth = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    nodes.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (!nodes.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> size = nodes.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nodes.<span class="built_in">front</span>()-&gt;left == <span class="literal">NULL</span> &amp;&amp; nodes.<span class="built_in">front</span>()-&gt;right == <span class="literal">NULL</span>) <span class="keyword">return</span> depth;</span><br><span class="line">            <span class="keyword">if</span> (nodes.<span class="built_in">front</span>()-&gt;left != <span class="literal">NULL</span>) nodes.<span class="built_in">push</span>(nodes.<span class="built_in">front</span>()-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (nodes.<span class="built_in">front</span>()-&gt;right != <span class="literal">NULL</span>) nodes.<span class="built_in">push</span>(nodes.<span class="built_in">front</span>()-&gt;right);</span><br><span class="line">            nodes.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        depth++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> depth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="打开转盘锁"><a href="#打开转盘锁" class="headerlink" title="打开转盘锁"></a>打开转盘锁</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">plusUp</span><span class="params">(string str, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    string s = str;</span><br><span class="line">    <span class="keyword">if</span> (s[i] == <span class="string">&#x27;9&#x27;</span>) s[i] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span> s[i] += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">string <span class="title">plusDown</span><span class="params">(string str, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    string s = str;</span><br><span class="line">    <span class="keyword">if</span> (s[i] == <span class="string">&#x27;0&#x27;</span>) s[i] = <span class="string">&#x27;9&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span> s[i] -= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">openLock</span><span class="params">(vector&lt;string&gt;&amp; deadends, string target)</span> </span>&#123;</span><br><span class="line">    queue&lt;string&gt; q;</span><br><span class="line">    <span class="comment">// 记录死亡密码</span></span><br><span class="line">    unordered_set&lt;string&gt; deads;</span><br><span class="line">    deads.<span class="built_in">insert</span>(deadends.<span class="built_in">begin</span>(), deadends.<span class="built_in">end</span>());</span><br><span class="line">    <span class="comment">// 记录已经穷举过的密码</span></span><br><span class="line">    unordered_set&lt;string&gt; visited;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="string">&quot;0000&quot;</span>);</span><br><span class="line">    visited.<span class="built_in">insert</span>(<span class="string">&quot;0000&quot;</span>);</span><br><span class="line">    <span class="type">int</span> step = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            string temp = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (deads.<span class="built_in">find</span>(temp) != deads.<span class="built_in">end</span>()) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (temp == target) <span class="keyword">return</span> step;</span><br><span class="line">            <span class="comment">// 遍历相邻节点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j) &#123;</span><br><span class="line">                string up = <span class="built_in">plusUp</span>(temp, j);</span><br><span class="line">                <span class="keyword">if</span> (visited.<span class="built_in">find</span>(up) == visited.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(up);</span><br><span class="line">                    visited.<span class="built_in">insert</span>(up);</span><br><span class="line">                &#125;</span><br><span class="line">                string down = <span class="built_in">plusDown</span>(temp, j);</span><br><span class="line">                <span class="keyword">if</span> (visited.<span class="built_in">find</span>(down) == visited.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(down);</span><br><span class="line">                    visited.<span class="built_in">insert</span>(down);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><h4 id="二叉搜索树的后序遍历序列"><a href="#二叉搜索树的后序遍历序列" class="headerlink" title="二叉搜索树的后序遍历序列"></a>二叉搜索树的后序遍历序列</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">recur</span><span class="params">(vector&lt;<span class="type">int</span>&gt; postorder, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt;= end) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> p = start;</span><br><span class="line">    <span class="keyword">while</span> (postorder[p] &lt; postorder[end]) p++;</span><br><span class="line">    <span class="type">int</span> m = p;</span><br><span class="line">    <span class="keyword">while</span> (postorder[p] &gt; postorder[end]) p++;</span><br><span class="line">    <span class="keyword">return</span> p==end &amp;&amp; <span class="built_in">recur</span>(postorder, start, m<span class="number">-1</span>) &amp;&amp; <span class="built_in">recur</span>(postorder, m, end<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">verifyPostorder</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">recur</span>(postorder, <span class="number">0</span>, postorder.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="滑动窗口问题"><a href="#滑动窗口问题" class="headerlink" title="滑动窗口问题"></a><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/solution/hua-dong-chuang-kou-by-powcai/">滑动窗口问题</a></h3><p>算法框架<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">slidingWindow</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; need, window;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : t) need[c]++;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> valid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="comment">// c是将移入窗口的字符</span></span><br><span class="line">        <span class="type">char</span> c = s[right];</span><br><span class="line">        <span class="comment">// 右移窗口</span></span><br><span class="line">        right++;</span><br><span class="line">        <span class="comment">// 进行窗口数据更新</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// *** debug 输出位置 ***</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;window: [%d, %d]\n&quot;</span>, left, right);</span><br><span class="line">        <span class="comment">/****************************/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断左窗口是否要收缩</span></span><br><span class="line">        <span class="keyword">while</span> (window needs shrink) &#123;</span><br><span class="line">            <span class="comment">// d是将要移出窗口的字符</span></span><br><span class="line">            <span class="type">char</span> d = s[left];</span><br><span class="line">            <span class="comment">// 左移窗口</span></span><br><span class="line">            left++;</span><br><span class="line">            <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="最长不含重复字符的子字符串"><a href="#最长不含重复字符的子字符串" class="headerlink" title="最长不含重复字符的子字符串"></a>最长不含重复字符的子字符串</h4><p>使用无序集合<code>unordered_set</code>保存子串并检验是否有重复字符</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    unordered_set&lt;<span class="type">char</span>&gt; dp;</span><br><span class="line">    <span class="type">int</span> maxStr = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (dp.<span class="built_in">find</span>(s[i]) != dp.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            dp.<span class="built_in">erase</span>(s[left]);</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        maxStr = <span class="built_in">max</span>(maxStr, i-left<span class="number">+1</span>);</span><br><span class="line">        dp.<span class="built_in">insert</span>(s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxStr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; window;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="type">char</span> c = s[right];</span><br><span class="line">        right++;</span><br><span class="line">        window[c]++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (window[c] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">char</span> d = s[left];</span><br><span class="line">            left++;</span><br><span class="line">            window[d]--;</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="built_in">max</span>(res, right - left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="最小子串覆盖"><a href="#最小子串覆盖" class="headerlink" title="最小子串覆盖"></a>最小子串覆盖</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">minWindow</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; need, window;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : t) need[c]++;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> valid = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 记录最小覆盖子串的起始索引及长度</span></span><br><span class="line">    <span class="type">int</span> start = <span class="number">0</span>, len = INT32_MAX;</span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="type">char</span> c = s[right];</span><br><span class="line">        right++;</span><br><span class="line">        <span class="keyword">if</span> (need.<span class="built_in">count</span>(c)) &#123;</span><br><span class="line">            window[c]++;</span><br><span class="line">            <span class="keyword">if</span> (window[c] == need[c])</span><br><span class="line">                valid++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (valid == need.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (right - left &lt; len) &#123;</span><br><span class="line">                start = left;</span><br><span class="line">                len = right - left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">char</span> d = s[left];</span><br><span class="line">            left++;</span><br><span class="line">            <span class="keyword">if</span> (need.<span class="built_in">count</span>(d)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (window[d] == need[d])</span><br><span class="line">                    valid--;</span><br><span class="line">                window[d]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len == INT32_MAX ? <span class="string">&quot;&quot;</span> : s.<span class="built_in">substr</span>(start, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="字符串的排列-1"><a href="#字符串的排列-1" class="headerlink" title="字符串的排列"></a>字符串的排列</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">checkInclusion</span><span class="params">(string s1, string s2)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; need, window;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> a : s1) need[a]++;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> valid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (right &lt; s<span class="number">2.</span><span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="type">char</span> c = s2[right];</span><br><span class="line">        right++;</span><br><span class="line">        <span class="keyword">if</span> (need.<span class="built_in">count</span>(c)) &#123;</span><br><span class="line">            window[c]++;</span><br><span class="line">            <span class="keyword">if</span> (window[c] == need[c])</span><br><span class="line">                valid++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (right - left &gt;= s<span class="number">1.</span><span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (valid == need.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="type">char</span> d = s2[left];</span><br><span class="line">            left++;</span><br><span class="line">            <span class="keyword">if</span> (need.<span class="built_in">count</span>(d)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (window[d] == need[d]) valid--;</span><br><span class="line">                window[d]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="找到字符串中索引字母异位词"><a href="#找到字符串中索引字母异位词" class="headerlink" title="找到字符串中索引字母异位词"></a>找到字符串中索引字母异位词</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findAnagrams</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; need, window;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> a : p) need[a]++;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> valid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="type">char</span> c = s[right];</span><br><span class="line">        right++;</span><br><span class="line">        <span class="keyword">if</span> (need.<span class="built_in">count</span>(c)) &#123;</span><br><span class="line">            window[c]++;</span><br><span class="line">            <span class="keyword">if</span> (window[c] == need[c])</span><br><span class="line">                valid++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (right - left &gt;= p.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (valid == need.<span class="built_in">size</span>()) res.<span class="built_in">push_back</span>(left);</span><br><span class="line">            <span class="type">char</span> d = s[left];</span><br><span class="line">            left++;</span><br><span class="line">            <span class="keyword">if</span> (need.<span class="built_in">count</span>(d)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (window[d] == need[d]) valid--;</span><br><span class="line">                window[d]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><h4 id="二进制中1的个数"><a href="#二进制中1的个数" class="headerlink" title="二进制中1的个数"></a>二进制中1的个数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="type">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span> == <span class="number">1</span>) res++;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="不用加减乘除左加法"><a href="#不用加减乘除左加法" class="headerlink" title="不用加减乘除左加法"></a>不用加减乘除左加法</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(b != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> c = (<span class="type">unsigned</span> <span class="type">int</span>)(a &amp; b) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        a ^= b;</span><br><span class="line">        b = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="剪绳子"><a href="#剪绳子" class="headerlink" title="剪绳子"></a>剪绳子</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">3</span>) <span class="keyword">return</span> n<span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> b = n % <span class="number">3</span>, p = <span class="number">1000000007</span>;</span><br><span class="line">    <span class="type">long</span> rem = <span class="number">1</span>, x = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> a = n / <span class="number">3</span> - <span class="number">1</span>; a &gt; <span class="number">0</span>; a /= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a % <span class="number">2</span> == <span class="number">1</span>) rem = (rem * x) % p;</span><br><span class="line">        x = (x * x) % p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">return</span> (<span class="type">int</span>)(rem*<span class="number">3</span>%p);</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">1</span>) <span class="keyword">return</span> (<span class="type">int</span>)(rem*<span class="number">4</span>%p);</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>)(rem*<span class="number">6</span>%p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-n整数中1出现的次数"><a href="#1-n整数中1出现的次数" class="headerlink" title="1~n整数中1出现的次数"></a><a href="https://leetcode-cn.com/leetbook/read/illustration-of-algorithm/57nyhd/">1~n整数中1出现的次数</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">countDigitOne</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> digit = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> high = n / <span class="number">10</span>, cur = n % <span class="number">10</span>, low = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (high != <span class="number">0</span> || cur != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="number">0</span>) res += high * digit;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cur == <span class="number">1</span>) res += high * digit + low + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> res += (high + <span class="number">1</span>) * digit;</span><br><span class="line">        low += cur * digit;</span><br><span class="line">        cur = high % <span class="number">10</span>;</span><br><span class="line">        high /= <span class="number">10</span>;</span><br><span class="line">        digit *= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="数字序列中的某一位数字"><a href="#数字序列中的某一位数字" class="headerlink" title="数字序列中的某一位数字"></a><a href="https://leetcode-cn.com/leetbook/read/illustration-of-algorithm/57vzfh/">数字序列中的某一位数字</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">findNthDigit</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">10</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="type">int</span> digit = <span class="number">1</span>;</span><br><span class="line">    <span class="type">long</span> start = <span class="number">1</span>;</span><br><span class="line">    <span class="type">long</span> count = <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; count) &#123;</span><br><span class="line">        n -= count;</span><br><span class="line">        start *= <span class="number">10</span>;</span><br><span class="line">        digit += <span class="number">1</span>;</span><br><span class="line">        count = digit * start * <span class="number">9</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> num = start + (n - <span class="number">1</span>) / digit;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">to_string</span>(num)[(n - <span class="number">1</span>) % digit] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="构建乘积数组-1"><a href="#构建乘积数组-1" class="headerlink" title="构建乘积数组"></a>构建乘积数组</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">constructArr</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len = a.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(len, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> temp = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; ++i) &#123;</span><br><span class="line">        res[i] = res[i<span class="number">-1</span>] * a[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = len - <span class="number">2</span>; i &gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">        temp *= a[i<span class="number">+1</span>];</span><br><span class="line">        res[i] *= temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h3><h4 id="顺时针打印矩阵"><a href="#顺时针打印矩阵" class="headerlink" title="顺时针打印矩阵"></a>顺时针打印矩阵</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix.<span class="built_in">empty</span>()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = matrix[<span class="number">0</span>].<span class="built_in">size</span>()<span class="number">-1</span>, top = <span class="number">0</span>, down = matrix.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = left; i &lt;= right; ++i) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(matrix[top][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (++top &gt; down) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = top; i &lt;= down; ++i) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(matrix[i][right]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (--right &lt; left) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = right; i &gt;= left; --i) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(matrix[down][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (--down &lt; top) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = down; i &gt;= top; --i) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(matrix[i][left]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (++left &gt; right) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="栈的压入、弹出序列"><a href="#栈的压入、弹出序列" class="headerlink" title="栈的压入、弹出序列"></a>栈的压入、弹出序列</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">validateStackSequences</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; pushed, vector&lt;<span class="type">int</span>&gt;&amp; popped)</span> </span>&#123;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : pushed) &#123;</span><br><span class="line">        stk.<span class="built_in">push</span>(num);</span><br><span class="line">        <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>() &amp;&amp; stk.<span class="built_in">top</span>() == popped[i]) &#123;</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stk.<span class="built_in">empty</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>神经网络结构汇总</title>
    <url>/2019/02/27/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<p>本文收集了一些神经网络的架构，包含常用的一些模型。  </p>
<h2 id="LeNet5"><a href="#LeNet5" class="headerlink" title="LeNet5"></a>LeNet5</h2><p><img src="/2019/02/27/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84%E6%B1%87%E6%80%BB/LeNet5.png" alt="LeNet5"><br>1.Input<br>&emsp;&emsp;输入图像统一归一化为32*32。<br>2.C1卷积层<br>&emsp;&emsp;经过(5*5*1)*6卷积核，stride=1, 生成featuremap为28*28*6。<br>3.S2池化层<br>&emsp;&emsp;经过(2*2)采样核，stride=2，生成featuremap为14*14*6。<br>4.C3卷积层<br>&emsp;&emsp;经过(5*5*6)*16卷积核，stride=1，生成featuremap为10*10*16。<br>5.S4池化层<br>&emsp;&emsp;经过(2*2)采样核，stride=2，生成featuremap为5*5*16。<br>6.C5卷积层<br>&emsp;&emsp;经过(5*5*16)*120卷积核，stride=1， 生成featuremap为1*1*120。<br>7.F6全连接层<br>&emsp;&emsp;输入为1*1*120，输出为1*1*84，总参数量为120*84。<br>8.Output全连接层。<br>&emsp;&emsp;输入为1*1*84，输出为1*1*10，总参数量为84*10。10就是分类的类别数。  </p>
<h2 id="AlexNet"><a href="#AlexNet" class="headerlink" title="AlexNet"></a>AlexNet</h2><p><img src="/2019/02/27/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84%E6%B1%87%E6%80%BB/AlexNet.png" alt="AlexNet"><br>1.Input<br>&emsp;&emsp;输入图像为227*227*3。<br>2.Conv1<br>&emsp;&emsp;经过(11*11*3)*96卷积核，stride=4， (227-11)/4+1=55，生成featuremap为55*55*96。<br>3.Pool1<br>&emsp;&emsp;经过3*3的池化核，stride=2，(55-3)/2+1=27，生成featuremap为27*27*96。<br>4.Norm1<br>&emsp;&emsp;local_size=5，生成featuremap为27*27*96。<br>5.Conv2<br>&emsp;&emsp;经过(5*5*96)*256的卷积核，pad=2，group=2，(27+2*2-5)/1+1=27，生成featuremap为27*27*256。<br>6.Pool2<br>&emsp;&emsp;经过3*3的池化核，stride=2，(27-3)/2+1=13，生成featuremap为13*13*256。<br>7.Norm2<br>&emsp;&emsp;local_size=5, 生成featuremap为13*13*256。<br>8.Conv3<br>&emsp;&emsp;经过(3*3*256)*384卷积核，pad=1， (13+1*2-3)/1+1=13，生成featuremap为13*13*384。<br>9.Conv4<br>&emsp;&emsp;经过(3*3*384)*384卷积核，pad=1，(13+1*2-3)/1+1=13，生成featuremap为13*13*384。<br>10.Conv5<br>&emsp;&emsp;经过(3*3*384)*256卷积核，pad=1，(13+1*2-3)/1+1=13，生成featuremap为13*13*256。<br>11.Pool5<br>&emsp;&emsp;经过(3*3)的池化核，stride=2，(13-3)/2+1=6，生成featuremap为6*6*256。<br>12.Fc6<br>&emsp;&emsp;输入为(6*6*256)*4096全连接，生成featuremap为1*1*4096。<br>13.Dropout6<br>&emsp;&emsp;在训练的时候以1/2概率使得隐藏层的某些神经元的输出为0，这样就丢掉了一半节点的输出，BP的时候也不更新这些节点，以下Droupout同理。<br>14.Fc7<br>&emsp;&emsp;输入为1*1*4096，输出为1*1*4096，总参数量为4096*4096。<br>15.Dropout7<br>&emsp;&emsp;生成featuremap为1*1*4096。<br>16.Fc8<br>&emsp;&emsp;输入为1*1*4096，输出为1000，总参数量为4096*1000。  </p>
<p><strong>总结:</strong></p>
<p><strong>1.网络比LeNet更深，包括5个卷积层和3个全连接层。</strong><br><strong>2.使用relu激活函数，收敛很快，解决了Sigmoid在网络较深时出现的梯度弥散问题。</strong><br><strong>3.加入了dropout层，防止过拟合。</strong><br><strong>4.使用了LRN归一化层，对局部神经元的活动创建竞争机制，抑制反馈较小的神经元放大反应大的神经元，增强了模型的泛化能力。</strong><br><strong>5.使用裁剪翻转等操作做数据增强，增强了模型的泛化能力。预测时使用提取图片四个角加中间五个位置并进行左右翻转一共十幅图片的方法求取平均值，这也是后面刷比赛的基本使用技巧。</strong><br><strong>6.分块训练，当年的GPU没有这么强大，Alexnet创新地将图像分为上下两块分别训练，然后在全连接层合并在一起。</strong><br><strong>7.总体的数据参数大概为240M。</strong>  </p>
<h2 id="VGG"><a href="#VGG" class="headerlink" title="VGG"></a>VGG</h2><p><img src="/2019/02/27/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84%E6%B1%87%E6%80%BB/Vgg.png" alt="Vgg">  </p>
<p>1.Input层<br>&emsp;&emsp;输入图片为224*224*3。<br>2.CONV3-64<br>&emsp;&emsp;经过（3*3*3）*64卷积核，生成featuremap为224*224*64。<br>3.CONV3-64<br>&emsp;&emsp;经过（3*3*64）*64卷积核，生成featuremap为224*224*64。<br>4.Max pool<br>&emsp;&emsp;经过（2*2）max pool核，生成featuremap为112*112*64。<br>5.CONV3-128。<br>&emsp;&emsp;经过（3*3*64）*128卷积核，生成featuremap为112*112*128。<br>6.CONV3-128<br>&emsp;&emsp; 经过（3*3*128）*128卷积，生成featuremap为112*112*128。<br>7.Max pool<br>&emsp;&emsp;经过（2*2）maxpool，生成featuremap为56*56*128。<br>8.CONV3-256<br>&emsp;&emsp;经过（3*3*128）*256卷积核，生成featuremap为56*56*256。<br>9.CONV3-256<br>&emsp;&emsp;经过（3*3*256）*256卷积核，生成featuremap为56*56*256。<br>10.CONV3-256<br>&emsp;&emsp;经过（3*3*256）*256卷积核，生成featuremap为56*56*256。<br>11.Max pool<br>&emsp;&emsp;经过（2*2）maxpool，生成featuremap为28*28*256。<br>12.CONV3-512<br>&emsp;&emsp;经过（3*3*256）*512卷积核，生成featuremap为28*28*512。<br>13.CONV3-512<br>&emsp;&emsp;经过（3*3*512）*512卷积核，生成featuremap为28*28*512。<br>14.CONV3-512<br>&emsp;&emsp;经过（3*3*512）*512卷积核，生成featuremap为28*28*512。<br>15.Max pool<br>&emsp;&emsp;经过（2*2）maxpool,生成featuremap为14*14*512。<br>16.CONV3-512<br>&emsp;&emsp;经过（3*3*512）*512卷积核，生成featuremap为14*14*512。<br>17.CONV3-512<br>&emsp;&emsp;经过（3*3*512）*512卷积核，生成featuremap为14*14*512。<br>18.CONV3-512<br>&emsp;&emsp;经过（3*3*512）*512卷积核，生成featuremap为14*14*512。<br>19.Max pool<br>&emsp;&emsp;经过2*2卷积，生成featuremap为7*7*512。<br>20.FC-4096<br>&emsp;&emsp;输入为7*7*512，输出为1*1*4096，总参数量为7*7*512*4096。<br>21.FC-4096<br>&emsp;&emsp;输入为1*1*4096，输出为1*1*4096，总参数量为4096*4096。<br>22.FC-1000<br>&emsp;&emsp;输入为1*1*4096，输出为1000，总参数量为4096*1000。  </p>
<p><strong>总结:</strong>  </p>
<p><strong>1. 共包含参数约为550M。</strong><br><strong>2. 全部使用3*3的卷积核和2*2的最大池化核。</strong><br><strong>3. 简化了卷积神经网络的结构。</strong>  </p>
<p><a href="https://blog.csdn.net/u011974639/article/details/79199306">MobileNet</a>  </p>
]]></content>
      <categories>
        <category>论文阅读</category>
      </categories>
      <tags>
        <tag>深度学习，计算机视觉，CNN</tag>
      </tags>
  </entry>
  <entry>
    <title>面试问题收集</title>
    <url>/2019/01/23/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%94%B6%E9%9B%86/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/Hanani_Jia/article/details/77950594">GItHub使用指南</a><br><a href="https://blog.csdn.net/ljc_563812704/article/details/53464039">GitHub 编辑指导</a><br><a href="https://www.jianshu.com/p/fd97e1f8f699">GItHub 公式编辑</a><br><a href="https://hacpai.com/guide/markdown">Markdown 教程</a></p>
<h2 id="程序员四大件"><a href="#程序员四大件" class="headerlink" title="程序员四大件"></a>程序员四大件</h2><ul>
<li>数据结构与算法</li>
<li>操作系统</li>
<li>计算机网络</li>
<li>设计模式</li>
</ul>
<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a><a href="https://blog.csdn.net/ThinkWon/article/details/102021274#t3">进程和线程的区别</a></h3><ol>
<li><strong>根本区别：</strong> 进程是资源调度的基本单位，线程是CPU调度和执行的基本单位。</li>
<li><strong>资源开销：</strong> 每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈（保证线程中的局部变量不被别的线程访问到）和程序计数器（为了线程切换后能恢复到正确的执行位置），线程之间切换的开销小。</li>
<li><strong>包含关系：</strong> 如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。</li>
<li><strong>内存分配：</strong> 同一进程的线程共享本进程的地址空间和资源，而进程之间的地址空间和资源是相互独立的。</li>
<li><strong>影响关系：</strong> 一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程比多线程健壮。</li>
<li><strong>执行过程：</strong> 每个独立的进程有程序运行的入口、顺序指向序列和程序出口。但是线程不能独立执行，必须依存在应用程序中，有应用程序提供多个线程指向控制，两者均可并发执行。</li>
</ol>
<p><a href="https://blog.csdn.net/linraise/article/details/12979473">多进程和多线程的区别</a></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>纬度　</th>
<th>多进程</th>
<th>多线程　</th>
<th>　总结　</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据共享、同步　</td>
<td>数据是分开的：共享复杂，需要用IPC；同步简单</td>
<td>多线程共享进程数据：共享简单；同步复杂</td>
<td>各有优势</td>
</tr>
<tr>
<td>内存、CPU</td>
<td>占用内存多，切换复杂，CPU利用率第</td>
<td>占用内存少，切换简单，CPU利用率高</td>
<td>线程占优</td>
</tr>
<tr>
<td>创建销毁、切换</td>
<td>创建销毁、切换复杂，速度慢</td>
<td>创建销毁、切换简单，速度快</td>
<td>线程占优</td>
</tr>
<tr>
<td>编程调试</td>
<td>编程简单，调试简单</td>
<td>编程复杂，调试复杂</td>
<td>进程占优</td>
</tr>
<tr>
<td>可靠性</td>
<td>进程之间不会相互影响</td>
<td>一个线程挂掉将导致整个进程挂掉</td>
<td>进程占优</td>
</tr>
<tr>
<td>分布式</td>
<td>适应于多核、多机分布；如果一台机器不够，扩展到多台机器比较简单</td>
<td>适应于多核分布</td>
<td>进程占优</td>
</tr>
</tbody>
</table>
</div>
<h3 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a><a href="https://blog.csdn.net/qq_33290787/article/details/51790605">并发与并行</a></h3><ol>
<li>并发的实质是一个物理CPU（也可以多个物理CPU）在若干道程序（或线程）之间多路复用，并发性是对有限物理资源强行限制使多用户共享以提高效率。</li>
<li>并行指两个或两个以上的事件（或线程）在同一时刻发生，是真正意义上的不同事件或线程在同一时刻，在不同CPU资源上（多核）同时执行。</li>
</ol>
<h2 id="数据结构和算法问题"><a href="#数据结构和算法问题" class="headerlink" title="数据结构和算法问题"></a>数据结构和算法问题</h2><h3 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a><a href="https://blog.csdn.net/hairetz/article/details/4141043">堆和栈的区别</a></h3><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><p><img src="/2019/01/23/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%94%B6%E9%9B%86/网络协议.png" alt="网络协议"></p>
<p><a href="https://zhuanlan.zhihu.com/p/147370653">TCP/IP协议</a></p>
<h2 id="计算机视觉面试问题"><a href="#计算机视觉面试问题" class="headerlink" title="计算机视觉面试问题"></a>计算机视觉面试问题</h2><h3 id="SVM"><a href="#SVM" class="headerlink" title="SVM"></a><a href="https://blog.csdn.net/v_july_v/article/details/7624837">SVM</a></h3><h3 id="CNN"><a href="#CNN" class="headerlink" title="CNN"></a><a href="https://blog.csdn.net/fengbingchun/article/details/50529500">CNN</a></h3><p><a href="https://blog.csdn.net/weixin_42111770/article/details/80719302">常见网络收集</a>  </p>
<h3 id="softmax函数"><a href="#softmax函数" class="headerlink" title="softmax函数"></a><a href="https://blog.csdn.net/u014380165/article/details/77284921">softmax函数</a></h3><h3 id="attention"><a href="#attention" class="headerlink" title="attention"></a><a href="https://blog.csdn.net/guohao_zhang/article/details/79540014">attention</a></h3><h3 id="data-augmentation"><a href="#data-augmentation" class="headerlink" title="data augmentation"></a>data augmentation</h3><h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><h4 id="随机梯度下降"><a href="#随机梯度下降" class="headerlink" title="随机梯度下降"></a>随机梯度下降</h4><h4 id="交叉熵"><a href="#交叉熵" class="headerlink" title="交叉熵"></a><a href="https://blog.csdn.net/rtygbwwwerr/article/details/50778098">交叉熵</a></h4><h3 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a><a href="https://blog.csdn.net/kyang624823/article/details/78646234">正则化</a></h3><h3 id="泰勒公式"><a href="#泰勒公式" class="headerlink" title="泰勒公式"></a><a href="https://charlesliuyx.github.io/2018/02/16/%E3%80%90%E7%9B%B4%E8%A7%82%E8%AF%A6%E8%A7%A3%E3%80%91%E6%B3%B0%E5%8B%92%E7%BA%A7%E6%95%B0/">泰勒公式</a></h3><h3 id="Batch-Normalization"><a href="#Batch-Normalization" class="headerlink" title="Batch Normalization"></a><a href="https://blog.csdn.net/qq_25737169/article/details/79048516">Batch Normalization</a></h3><h3 id="网络参数是如何计算的"><a href="#网络参数是如何计算的" class="headerlink" title="网络参数是如何计算的"></a>网络参数是如何计算的</h3><h3 id="ShuffleNet"><a href="#ShuffleNet" class="headerlink" title="ShuffleNet"></a><a href="https://blog.csdn.net/u011974639/article/details/79200559">ShuffleNet</a></h3><h3 id="deepwise-separable-conv"><a href="#deepwise-separable-conv" class="headerlink" title="deepwise separable conv"></a><a href="https://yinguobing.com/separable-convolution/#fn2">deepwise separable conv</a></h3><h3 id="最优化方法"><a href="#最优化方法" class="headerlink" title="最优化方法"></a><a href="http://www.cnblogs.com/maybe2030/p/4751804.html#_label0">最优化方法</a></h3><h3 id="深度神经网络全面概述：从基本概念到实际模型和硬件基础"><a href="#深度神经网络全面概述：从基本概念到实际模型和硬件基础" class="headerlink" title="深度神经网络全面概述：从基本概念到实际模型和硬件基础"></a><a href="https://cloud.tencent.com/developer/article/1116764">深度神经网络全面概述：从基本概念到实际模型和硬件基础</a></h3><h3 id="数学概念"><a href="#数学概念" class="headerlink" title="数学概念"></a><a href="https://blog.csdn.net/majinlei121/article/details/47260917">数学概念</a></h3><h3 id="RNN"><a href="#RNN" class="headerlink" title="RNN"></a><a href="https://blog.csdn.net/heyongluoyao8/article/details/48636251">RNN</a></h3><h3 id="LSTM"><a href="#LSTM" class="headerlink" title="LSTM"></a><a href="https://blog.csdn.net/gzj_1101/article/details/79376798">LSTM</a></h3><h3 id="RPN"><a href="#RPN" class="headerlink" title="RPN"></a><a href="https://blog.csdn.net/sloanqin/article/details/51545125">RPN</a></h3><h3 id="PCA"><a href="#PCA" class="headerlink" title="PCA"></a>PCA</h3><h3 id="K-means"><a href="#K-means" class="headerlink" title="K-means"></a>K-means</h3><p>基本流程：</p>
<ol>
<li>初始化k个聚类中心$c_1$, $c_2$,…,$c_k$</li>
<li>对于每个样本$x_i$和每个聚类中心$c_j$，计算样本和聚类中心之间的距离$d_ij$</li>
<li>对于每个样本$x_i$，基于最小的$d_ij$把其分配到第$j$个类$C_j$</li>
<li>对于每个类$C_j$，计算其所有样本的均值作为新的聚类中心，重复步骤2和步骤3直至样本点所属的类不再变化或达到最大迭代次数 </li>
</ol>
<h3 id="KNN"><a href="#KNN" class="headerlink" title="KNN"></a>KNN</h3><p>基本流程：</p>
<ol>
<li>计算测试数据与各个训练数据之间的距离</li>
<li>按照距离的递增关系进行排序</li>
<li>选取距离最小的K个点</li>
<li>确定前K个点所在类别的出现概率</li>
<li>返回前K个点中出现频率最高的类别作为测试数据的预测分类</li>
</ol>
<h3 id="K-means和KNN的区别"><a href="#K-means和KNN的区别" class="headerlink" title="K-means和KNN的区别"></a>K-means和KNN的区别</h3><ul>
<li>K-means是无监督学习算法，KNN是有监督学习算法</li>
<li>K-means是聚类算法，KNN是分类算法</li>
<li>K-means有明显的训练过程（求聚类中心），KNN在学习阶段只是简单的吧所有样本记录</li>
<li>在测试阶段，对于K-means，新的样本点的判别与聚类中心有关，即与所有训练样本有关，对于KNN，新的样本点的判别只是与最近相邻的K个样本有关</li>
</ul>
<h3 id="损失函数-1"><a href="#损失函数-1" class="headerlink" title="损失函数"></a><a href="https://blog.csdn.net/kangyi411/article/details/78969642">损失函数</a></h3><h3 id="梯度消失和梯度爆炸"><a href="#梯度消失和梯度爆炸" class="headerlink" title="梯度消失和梯度爆炸"></a><a href="https://blog.csdn.net/qq_25737169/article/details/78847691">梯度消失和梯度爆炸</a></h3><p>解决方法：</p>
<ol>
<li>预训练加微调</li>
<li>梯度剪切、正则</li>
<li>使用relu、leakrelu、elu等激活函数</li>
<li>batchnorm</li>
<li>残差结构</li>
<li>LSTM</li>
</ol>
<h3 id="SITF"><a href="#SITF" class="headerlink" title="SITF"></a>SITF</h3><h3 id="Dropout"><a href="#Dropout" class="headerlink" title="Dropout"></a>Dropout</h3><h3 id="Pooling"><a href="#Pooling" class="headerlink" title="Pooling"></a>Pooling</h3><h3 id="正则化-1"><a href="#正则化-1" class="headerlink" title="正则化"></a><a href="https://charlesliuyx.github.io/2017/10/03/%E3%80%90%E7%9B%B4%E8%A7%82%E8%AF%A6%E8%A7%A3%E3%80%91%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%A3%E5%88%99%E5%8C%96/#Why-amp-What-%E6%AD%A3%E5%88%99%E5%8C%96">正则化</a></h3><h2 id="计算机视觉及深度学习岗位应聘问题"><a href="#计算机视觉及深度学习岗位应聘问题" class="headerlink" title="计算机视觉及深度学习岗位应聘问题"></a><a href="https://blog.csdn.net/ferriswym/article/details/81331191">计算机视觉及深度学习岗位应聘问题</a></h2>]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>计算机视觉</tag>
        <tag>面试</tag>
        <tag>神经网络</tag>
      </tags>
  </entry>
</search>
